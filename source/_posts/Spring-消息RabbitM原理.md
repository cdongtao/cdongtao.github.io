---
title: RabbitMQ基本原理
tags: [消息队列,RabbitMQ]
categories: [SpringBoot,Spring]
---
## 应用
[RabbitMQ 七战 Kafka](https://mp.weixin.qq.com/s/c_o5HIsQKVQmC6aiCtU8bg)
[发送邮件+SpringBoot+ RabbitMQ+定时任务复发](https://mp.weixin.qq.com/s/G-DbD3F6gbJY_ubXyfg5DA)

## RabiitMQ
![RabbitMq](/rabbitMq/RabbitMq.png "RabbitMq")

* Exchange：生产者将消息发送到Exchange,由交换器将消息路由到一个或者多个队列中。如果路由不到,或许会返回给生产者,或许直接丢弃。
* Binding：RabbitMQ中通过绑定将交换器与队列关联起来,在绑定Queuen的时候一般会指定一个绑定键(BindingKey),这个过程相当给Queue命名,这样RabbitMQ就知道如何正确地将消息路由到队列了。
![BindligKey](/rabbitMq/BindligKey.png "BindligKey")
* RoutingKey：生产者将消息发给交换器的时候,一般会指定一个RountingKey,用来指定这个消息的路由规则,而这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键(BindingKey)固定的情况下,生产者可以在发送消息给交换器时,通过指定RoutingKey来决定消息流向哪里。

生产者将消息发送给交换器时,需要一个RoutingKey,当BindingKey和RoutingKey相匹配时,消息会被路由到对应的队列中。在绑定多个队列到同一个交换器时候,这些绑定允许使用相同的BindingKey。BindingKey并不是在所有的情况下都生效,它依赖于交换器类型,比如fanout类型的交换器就会无视BindingKey,而是将消息路由到所有绑定到该交换器的队列中。
 举例理解：交换器相当于投递包裹的邮箱,RoutingKey相当于填写在包裹上的地址,BindingKey相当于包裹的目的地,当填写在包裹上的地址和实际想要投递的地址相匹配时,那么这个包裹就会被正确投递到目的地。如果填写的地址出错,邮递员不能正确投递到目的地。包裹可能会会退给寄件人,也有可能被丢弃。

### 交换器类型4种
RabbitMQ常用的交换器类型有fanout,direct,topic,headers这四种。
* fanout：它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。
* direct：direct类型的交换器路由规则也很简单,它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。
* topic：topic类型的交换器在匹配规则上进行了扩展,它与direct类型的交换器相似,也是将消息路由到BindingKey和RoutingKey相匹配的队列中,但匹配规则有些不同
    RoutingKey为一个点号“.”分隔的字符串(被点号“.”分隔开的每一段独立的字符串称为一个单词),如“com.rabbitmq.client”,“java.util.concurrent”,“com.hidden.client”；
    BindingKey和RoutingKey一样也是点号“.”分隔的字符串；
    BindingKey中可以存在两种特殊字符串“*”和“#”,用于做模糊匹配,符号“#”匹配路由键的一个或多个词,符号“*”匹配路由键的一个词
* headers：headers类型的交换器不依赖于路由键的匹配规则来路由消息,而是根据发送的消息内容中的headers属性来进行匹配。(不实用,基本上不会看到它的存在)


### RabbitMQ运转流程
* Productor在发送消息的时候：
  1. 生产者连接到RabbitMQ Broker,建立一个连接(Connection),开启一个信道(Channel)。
  2. 生产者声明一个交换器,并设置相关属性,比如交换器类型,是否持久化等。
  3. 生产者声明一个队列并设置相关属性,比如是否排他是否持久化,是否自动删除等。
  4. 生产者通过路由键将交换器和队列绑定起来。
  5. 生产者发送消息至RabbitMQ Broker,其中包含路由键,交换器等信息。
  6. 相应的交换器根据接收到的路由键查找相匹配的队列。
  7. 如果找到,则将从生产者发送过来的消息存入相应的队列中。
  8. 如果没有找到,则根据生产者配置的属性选择丢弃还是回退给生产者。
  9. 关闭信道。
  10. 关闭连接。

* Consumer接受消息的过程：
  1. 消费者连接到RabbitMQ Broker,建立一个连接(Connection),开启一个信道(Channel)。
  2. 消费者向RabbitMQ Broker请求消费相应队列中的消息,可能会设置相应的回调函数,以及做一些准备工作。
  3. 等待RabbitMQ Broker回应并投递相应队列中的消息,消费者接受消息。
  4. 消费者确认(ack)接受到的消息。
  5. RabbitMQ从队列中删除相应已经被确认的消息。
  6. 关闭信道。
  7. 关闭连接。

## 加入中间件三大缺陷
1. 系统高可用性:需要考虑MQ挂掉的风险
2. 系统复杂度提高: 
   * 消息丢失问题
   * 消息有序性问题
   * 消息重复消费问题
3. 数据一致性问题 

### 消息丢失问题
#### 如何确保消息不丢失
保证消息不丢失 = 保证高可用(High Available)
* Productor存在丢失问题:保障消息的成功发出。
* RabbitMQ存在丢失问题:保障MQ节点的成功接收。
* Consumer存在丢失问题:发送端收到MQ节点(Broker)确认应答

##### Productor丢失问题
解决方案:
1. 同步提交模式:A.channel.txselect 开启事务  B.channel commit提交  ---->降低吞吐量,一般不用
2. 异步提交模式(confirm模式): 生产者设置,MQ成功接受返回ack;若MQ没接受消息,可以重复发(限制重复次数),存在批量提交模式

##### MQ消息丢失问题
解决方案:
* 创建Queue时设置持久化,这样的持久化MQ元数据,不持久化消息
* 将消息deliveryMode 设置为2,将消息设置持久化,设置后持久化成功后,才有返回confirm中ack
##### Consumer丢失问题
* 消费默认机制:消费者到数据,MQ会删除数据,以为消费成功
* 解决办法:关闭自动提交机制ack,在消费者消费完成后手动提交

### 重复消费问题
幂等性是什么？简单来说就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的。
我们可以借鉴数据库的乐观锁机制来保障幂等性,或者函数f(n),只要n不变,执行的结果就一样
#### 什么情况下会出现重复消费？
当消费者消费完消息时,在给生产端返回ack时由于网络中断,导致生产端未收到确认信息,该条消息会重新发送并被消费者消费,但实际上该消费者已成功消费了该条消息,这就是重复消费问题。

#### 如何避免消息的重复消费问题？
消费端实现幂等性,就意味着,我们的消息永远不会消费多次,即使我们收到了多条一样的消息
业界主流的幂等性操作：
* 唯一ID + 指纹码机制,利用数据库主键去重
* 利用Redis的原子性去实现

##### 唯一ID+指纹码机制
* 唯一ID + 指纹码机制,插入数据,利用数据库主键去重
* 好处：实现简单
* 坏处：高并发下有数据库写入的性能瓶颈
* 解决方案：跟进ID进行分库分表进行算法路由

整个思路就是首先我们需要根据消息生成一个全局唯一的ID,然后还需要加上一个指纹码。这个指纹码它并不一定是系统去生成的,而是一些外部的规则或者内部的业务规则去拼接,它的目的就是为了保障这次操作是绝对唯一的。
对于高并发下的数据库性能瓶颈,可以跟进ID进行分库分表策略,采用一些路由算法去进行分压分流。应该保证ID通过这种算法,消息即使投递多次都落到同一个数据库分片上,这样就由单台数据库幂等变成多库的幂等。

##### 利用Redis的原子性去实现
使用 redis 的原子性去实现主要需要考虑两个点
* 第一：我们是否要进行数据落库,如果落库的话,关键解决的问题是数据库和缓存如何做到原子性？
* 第二：如果不进行落库,那么都存储到缓存中,如何设置定时同步的策略(同步到关系型数据库)？缓存又如何做到数据可靠性保障呢
  
关于不落库,定时同步的策略,目前主流方案有两种,第一种为双缓存模式,异步写入到缓存中,也可以异步写到数据库,但是最终会有一个回调函数检查,这样能保障最终一致性,不能保证100%的实时性。第二种是定时同步,比如databus同步。

### 消息顺序问题
尽量做到Queue对应一个consumer,保持不出现竞争消费,防止一个queue对多个cosumer
### 消息落库补偿机制(互联网大厂的解决方案)
#### 消息进行打标
![对消息状态进行达标](/rabbitMq/对消息状态进行达标.png "对消息状态进行达标")
* Step1：业务数据落库(BIZ DB)(如订单数据),消息落库(MSG DB init:status = 0)。
* Step2：分布式定时任务查询待发送消息发送至MQ Broker。
* Step3：MQ Broker confirm 机制回调Producer Listener。(如果步骤3出现断连,会出现重复投递问题,需要消费端自己去做幂等)
* Step4：更新消息发送状态(success status = 1)。
* Step5：分布式定时任务查询发送失败(未被confirm)的消息,query the status = 0。
* Step6：重新发送发送失败的消息,count++。
* Step7：重复发送次数达到指定次数(count > 3次,set status =2),不进行再次投递,人工接入处理。

优缺点:
step5可能比step4快,因此在step1需要防止重复存入数据(count > 0),同时消费端要防止消息重复消费
将消息存入数据库,记录消息的状态。可以通过轮询不断获取消息的状态,从而保证消息的成功投递。如下图示所示,这样做有一个很严重的问题就是要多次操作数据库,对于一些高并发、对性能要求较高的业务,这种方式是不太合适的。因为频繁操作数据库会带来严重的性能问题。

#### 消息的延迟投递,做二次确认,回调检查
![生产端可靠性投递](/rabbitMq/生产端可靠性投递.png "生产端可靠性投递")
* Step1：业务上游业务数据落库成功后,发送一条消息M1。
* Step2：一定时间延迟后(延迟时间根据业务需求而定)发送一条延迟消息M2用于追溯M1(可在M1发送得同时发送至延迟队列中)。
* Step3：业务下游接收M1消息之后,完成下游业务逻辑。
* Step4：发送消息M3至MQ Broker(新的得队列)。
* Step5：CallBack端监听M3消息,落入消息库。
* Step6：同时CallBack监听延时到达得M2消息,与MSG DB 中的M3比对。若对比结果M3不存在,则消息补偿(重新发送M1消息)。此时下游业务端可能会消费重复消息(M3消息发送失败),因此需要保证幂等性。

#### 优缺点:
* 优点:
这种方法可以有效的避免对数据库的频繁操作,从而提高性能；同时业务DB和消息DB之间解耦；改方案对比上述方案上游业务端减少一次数据库持久化,并发压力提高,补偿消息机制略差。
* 缺点:
生产端会发送两次消息：
  1. 生产端首先会将业务数据存入DB,之后会向MQ发送一个消息,消费端收到消息后发送确认消息(这里的确认消息不是指ack,而是重新编辑发送一条新消息),回调服务监听到确认消息后将消息存入DB；
  2. 在第一条消息发送出去后一段时间,生产端会再发送一条check消息,回调服务监听到check消息后会检查第一条消息的执行情况,如果消息未能按照预期结果执行的话,回调服务会给生产端发送一条指令让生产端重新发送消息

## RabbitMQ高可用
### 普通集群
多个联通的服务器上安装不同的RabbitMQ的服务,这些服务器上的RabbitMQ服务组成一个个节点,通过RabbitMQ内部提供的命令或者配置来构建集群,形成了RabbitMQ的普通集群模式

![普通集群](/rabbitMq/普通集群.png "普通集群")
* 当用户向服务注册一个队列，该队列会随机保存到某一个服务节点上，然后将对应的元数据同步到各个不同的服务节点上
* RabbitMQ的普通集群模式中，每个RabbitMQ都保存有相同的元数据
* 用户只需要链接到任一一个服务节点中，就可以监听消费到对应队列上的消息数据
* 但是RabbitMQ的实际数据却不是保存在每个RabbitMQ的服务节点中，这就意味着用户可能联系的是RabbitMQ服务节点C，但是C上并没有对应的实际数据，也就是说RabbitMQ服务节点C，并不能提供消息供用户来消费，那么RabbitMQ的普通集群模式如何解决这个问题呢？
* RabbitMQ服务节点C发现自己本服务节点并没有对应的实际数据后，因为每个服务节点上都会保存相同的元数据，所以服务节点C会根据元数据，向服务节点B（该服务节点上有实际数据可供消费）请求实际数据，然后提供给用户进行消费
* 这样给用户的感觉就是，在RabbitMQ的普通集群模式中，用户连接任一服务节点都可以消费到消息

#### 普通集群模式优缺点
##### 优点
  普通集群模式的原理比较简单，提高消费的吞吐量,但是并不能真正意义上的实现高可用
##### 缺点(存在问题)
* 服务在高并发情况下很容易出现性能瓶颈，进而影响整个系统的运行
* 为了请求RabbitMQ的实际数据以提供给用户，可能会在RabbitMQ内部服务节点之间进行频繁的进行数据交互，这样的交互比较耗费资源
* 当其中一个RabbitMQ的服务节点宕机了，那么该节点上的实际数据就会丢失，用户再次请求时，就会请求不到数据，系统的功能就会出现异常

### 镜像集群
![镜像集群](/rabbitMq/镜像集群.png "镜像集群")
* 生产者向任一服务节点注册队列，该队列相关信息会同步到其他节点上
* 任一消费者向任一节点请求消费，可以直接获取到消费的消息，因为每个节点上都有相同的实际数据
* 任一节点宕机，不影响消息在其他节点上进行消费

#### 开启镜像模式
这里简单说下，在普通集群模式的基础上，我们可以通过web控制端来配置数据的同步策略，可以配置同步所有的节点，也可以配置同步到指定数量的服务节点
#### 镜像模式优缺点
##### 优点
虽然镜像集群模式能够解决普通集群模式的缺点，当任一节点宕机了，不能正常提供服务了，也不影响该消息的正常消费，但是其本身也有相应的缺点：
##### 缺点
* 性能开销非常大，因为要同步消息到对应的节点，这个会造成网络之间的数据量的频繁交互，对于网络带宽的消耗和压力都是比较重的,没有扩展可言，rabbitMQ是集群，不是分布式的，所以当某个Queue负载过重，我们并不能通过新增节点来缓解压力，因为所以节点上的数据都是相同的，这样就没办法进行扩展了
* 对于镜像集群而言，当某个queue负载过重，可能会导致集群雪崩，那么如何来减少集群雪崩呢？我们可以通过HA的同步策略来实现

### 高可用(HA)的同步策略
对于镜像集群而言，当某个queue负载过重，可能会导致集群雪崩，那么如何来减少集群雪崩呢？我们可以通过HA的同步策略来实现

|  HA-mode | HA-params | 说明  |
|  ----  | ----  |  ----  |
| all  | 空 | 镜像队列将会在整个集群中复制。当一个新的节点加入后，也会在这个节点上复制一份 |
| exactly  | count |镜像队列将会在集群上复制count份。如果集群数量少于count时候，队列会复制到所有节点上。<br>如果大于Count集群，有一个节点crash后，新进入节点也不会做新的镜像。（可以阻止集群雪崩） |
| nodes  | node name |镜像队列会在node name中复制。如果这个名称不是集群中的一个，这不会触发错误。<br>如果在这个node list中没有一个节点在线，那么这个queue会被声明在client连接的节点。 |

