---
title: Mysql基础知识2
tags: [Mysql,面试知识]
categories: [Database]
---
## Mysql数据存储原理计算
存储单位: 磁盘以扇区为单位=512字节  系统文件文件=4K   Mysql以页为单位=16k

### 计算B+树容量
求高度为H=2时,计算B+树容量?
    1.设:存储一条数据大小=1k,索引键值(默认int类型)=8字节,指针(*P)=6字节
    2.非叶子节点存储索引与指针数=16*1024/(8+6)=1170   //一页为单位可以包含指针数,指针向下指可以是指针,可以是数据
    3.叶子节点包含数据数量=16K/1K=16     //一页为单位可以存储16条数据
    4.H=2时,可以包含数据=1170(非叶子节点)*16(叶子节点)=18000;
      H=3时,可以包含数据=1170(非叶子节点)*1170(非叶子节点)*16(叶子节点)=2100w

### 索引结构(算法)
#### 为什么选B+树做索引?
<font color='red'>提高效率核心是减少访问I/O次数</font>
* B+树:索引(O(log(n)))
* B树:每个节点存储结构(真实数据+key(索引)+指针(*P)),相比B+树(key+(*p))存储结构,B树节点跟多导致树会更高,I/O次数也更多,效率更低;
* 二叉树(二叉查找树):每个节点下面只有两个字节点,时间复杂度为O(log2n),只有左右子树,相同数据量,二叉树高度比B+树高,I/0次数也就更多;
* 红黑叔:每一次写入数据都可能需要反转,变色,还可能要迭代会上一级节点向下遍历,来回操作访问I/O次数变多,效率降低;
* hash索引: 仅仅能满足"=","IN"和"<=>"查询,不能使用范围查询(只有Memory存储引擎支持hash索引)

### 索引类型
#### 普通索引
普通索引是最基本的索引,它没有任何限制,值可以为空;仅加速查询;可以通过以下几种方式来创建或删除:
    CREATE INDEX index_name ON table(column(length))
    ALTER TABLE table_name ADD INDEX index_name ON (column(length))
    DROP INDEX index_name ON table

#### 唯一索引
唯一索引与普通索引类似,不同的就是:索引列的值必须唯一,但允许有空值;如果是组合索引,则列值的组合必须唯一;简单来说:唯一索引是加速查询 + 列值唯一（可以有null）;以通过以下几种方式来创建:
    CREATE UNIQUE INDEX indexName ON table(column(length))
    ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))

#### 主键索引
主键索引是一种特殊的唯一索引,一个表只能有一个主键,不允许有空值;简单来说:主键索引是加速查询 + 列值唯一（不可以有null）+ 表中只有一个
CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );

#### 组合索引
组合索引指在多个字段上创建的索引,只有在查询条件中使用了创建索引时的第一个字段,索引才会被使用;使用组合索引时遵循最左前缀集合;组合索引是多列值组成的一个索引,专门用于组合搜索,其效率大于索引合并
    ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);

#### 全文索引
全文索引主要用来查找文本中的关键字,而不是直接与索引中的值相比较;fulltext索引跟其它索引大不相同,它更像是一个搜索引擎,而不是简单的where语句的参数匹配;fulltext索引配合match against操作使用,而不是一般的where语句加like;它可以在create table,alter table ,create index使用,不过目前只有char、varchar,text 列上可以创建全文索引;值得一提的是,在数据量较大时候,现将数据放入一个没有全局索引的表中,然后再用CREATE index创建fulltext索引,要比先为一张表建立fulltext然后再将数据写入的速度快很多;
    CREATE TABLE `table` (`id` int(11) NOT NULL AUTO_INCREMENT ,FULLTEXT (content));
    ALTER TABLE article ADD FULLTEXT index_content(content)
    CREATE FULLTEXT INDEX index_content ON article(content)

## Mysql优化基础
优化逻辑: <font color='red'>选择存储引擎---->建表---->建索引---->优化sql---->硬件</font>
    
### 选择存储引擎
#### 引擎种类
InnoDby存储引擎,MyIsAm存储引擎,Memory存储引擎
InnoDb引擎:如果数据量比较大,这是需要通过升级架构来解决,比如分表分库,读写分离,而不是单纯地依赖存储引擎

#### 常用引擎比较
| InnoDb引擎|MyIsAm引擎|
|-----------|------------|
|聚簇索引(主键索引和数据是在一起的)|非聚簇索引|
|支持事务(出错还可以回滚还原)|不支持事务|
|行级锁|全表锁|
|全表删除,行级删|全表删除,重建表|
|MVCC控制并发|不控制并发|
|适合读写改删操作|适合写入频繁操作|

聚簇索引:将数据存储与索引放到了一块,索引结构的叶子节点保存了行数据;如果表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 聚簇索引会使用DB_ROW_ID的值来作为主键; 如果表中有主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID了
非聚簇索引:将数据与索引分开存储,索引结构的叶子节点(指针)指向了保存在磁盘上数据对应的位置

聚集索引和非聚集索引的区别如下
1.聚簇索引只需要一次按Page加载数据到缓冲区(一次I/O),已经加载在缓冲区的数据后续不需要再一次(I/O);非聚簇索引结构原因导致数据每一次查找都需要从硬盘加载(I/O)

#### 为什么主键通常建议使用自增id
如果主键不是自增id,B+树不断地调整数据的物理地址、分页。但如果是自增的,索引结构相对紧凑,磁盘碎片少,效率也高;

### 为什么索引是int类型
建议使用int类型的自增,如果主键其他类型值占用的存储空间越大,也就节点会变多,增加B+树的高度,IO操作也会变多。

#### 为什么不适用UUid做聚簇索引
当使用主键为聚簇索引时,主键最好不要使用uuid,因为uuid的值太过离散,不适合排序且可能出线新增加记录的uuid,会插入在索引树中间的位置,导致索引树调整复杂度变大,消耗更多的时间和资源。

### 建表
使用三范式建表/反三范式适当冗余
#### 三范式建表
* 保证表字段原子性
* 完全依赖主键(消除除主键外,表字段对其他字段的唯一依赖)
    字段ABC:主键A->C,B->C //C同时唯一依赖A/B,要消除B->C,让主键唯一依赖
* 消除存在传递性依赖,适当增加中间表
    字段ABC:主键A->B,B->C //可以由A推出B,B推出C,消除C

### 建索引
    建立主键,常用字段为索引,还有考虑联合索引

### 优化sql
#### 使用索引注意
* Select:尽可能不使用select* 问题,select之后只写必要字段,增加索引覆盖率
* Where:使用满足最左匹配索引原则
* and:过于频繁使用and查询,合理使用复合索引,但是尽量少用
* or:防止一边无索引,导致全部查询
* order By:若无索引,则数据将从硬盘分批读取到内存中排序,最后合并结果
* join...in:条件中建立索引
* like:防止“%XXX%”全表查询,但是“XXX%”可以使用索引
* 
注:复合索引原理(A and B)
    1.若AB都有索引树,先在A树找到再到B树找,取交集;
    2.若以A_B拼接成字符串后做成联合索引,则在索引结果中找A,然后二分法找B,但复合索引树高度I/O过多,导致性能效率问题

#### 看执行计划,查看索引使用情况
MySQL 使用 explain + sql 语句查看 执行计划,该执行计划不一定完全正确但是可以参考

