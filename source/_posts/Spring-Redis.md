---
title: Redis详解
tags: [Plugin-Redis]
categories: [Plugin]
---

## Redis简介
Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。
Redis与其他key-value缓存产品有以下三个特点:
* Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
* Redis不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储
* Redis支持数据的备份，即 master - slave 模式的数据备份

## Redis优势
* 性能极高–Redis 读的速度是 110000 次/s, 写的速度是 81000 次/s 。
* 丰富的数据类型-Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 ZSets 数据类型操作。
* 原子性-Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。
* 其他特性-Redis 还支持 publish/subscribe 通知，key 过期等特性。

## Redis数据类型(5种)
Redis支持5种数据类型：string(字符串)，hash(哈希)，list(列表)，set(集合)，zset(sorted set：有序集合)

### string类型
string类型是redis最基本的数据类型,最大能存储512MB,一个key对应一个value
string是二进制安全的。也就是说redis的string 可以包含任何数据。比如jpg图片或者序列化的对象
```
    格式:set key value1  //重复key会覆盖原来的值
    get key 
    set key value2//重复会覆盖value1
```

### hash类型(类似Map)
hash是一个键值对(key-Object),value是String类型(key-value)多个集合,特别适合用于存储对象,无序,Object-key为不能重复
```
    格式:hset key Object-key Object-value //Object-key为不能重复
    hset hash-key sub-key1 value1
    hset hash-key sub-key1 value2 
    hgetall hash-key
```

### List类型(类似Array)
redis list的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销
list就是一个简单的字符串集合,和Java中的list相差不大,区别就是这里的list存放的是字符串.
```
    格式:rpush key value //list内的value元素是可重复的,存在不同下标
    rpush list-key v1
    rpush list-key v2 
    rpush list-key v2
```

### Set类型(字符串)
redis的set是字符串类型的无序集合,集合是通过哈希表实现的，因此添加、删除、查找的复杂度都是 O(1)
redis的set是一个key对应着多个value，但是set和redis的list 不同的是set中的字符串集合元素不能重复，但是list可以。
```
    格式:sadd key value //value也是一个字符串类型的不能重复集合
    sadd k1 v1
    sadd k1 v2
```

### Zset类型(有序)
redis zset和set一样都是字符串类型元素的集合，并且集合内的value元素不能重复。一个key,多个value
不同的是zset每个元素都会关联一个double 类型的分数。redis通过分数来为集合中的成员进行从小到大的排序。
zset的元素是唯一的，但是分数(score)却可以重复。zset是按照分数的大小来排序的。
```
    格式:zadd key score value //不可以重复:用于防重复防并发
    zadd zset-key 728 member1
    zadd zset-key 982 member0
```

### 总结及应用:
#### 总结:
类型简介特性场景string(字符串)二进制安全可以包含任何数据，比如 jpg 图片或者序列化的对象，一个键最大能存储 521M---Hash（哈希）键值对集合，即编程语言中的 Map 类型适合存储对象，并且可以像数据库中 update 一样只修改某一项属性值存储、读取、修改用户属性List（列表）双向链表增删快，提供了操作某一段元素的 API1
#### 应用
* 消息队列Set(集合)哈希表实现，元素不能重复添加删除查找的复杂度都是 O(1);带权重的消息队列;
* 集合操作:为集合提供了求交集、并集、差集等操作共同好友；
* 防重复防并发:利用唯一性，统计访问网站的所有独立 ip；
* 消息排行功能:好友推荐时，根据 tag 求交集，大于某个阈值就可以推荐Zset（有序集合）将 Set 中的元素增加一个权重参数 score，元素按 score 有序排列数据插入集合时，已经进行天然排序排行榜；最新消息朋友圈的时间线

## 发布订阅
一般不用 Redis 做消息发布订阅
Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。

## redis事务
redis事务一次可以执行多条命令，服务器在执行命令期间，不会去执行其他客户端的命令请求。事务中的多条命令被一次性发送给服务器，而不是一条一条地发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。执行具有原子型,事务不具有原子性,也不存在隔离机制

### 执行原理
Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来
  * 批量操作在发送 EXEC 命令前被放入队列缓存。
  * 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余命令依然被执行。也就是说 Redis 事务不保证原子性。
  * 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中
  
单个 Redis 执行命令是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。
事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。队列未提交之前不会执行,不存在隔离机制

### 执行阶段
一个事务从开始到执行会经历以下三个阶段：
  * 开始事务(MULTI)
  * 命令入队
  * 执行事务(EXEC)

### Redis事务命令
下表列出了redis事务的相关命令：
序号命令及描述
    1.DISCARD 取消事务，放弃执行事务块内的所有命令。
    2.EXEC 执行所有事务块内的命令。
    3.MULTI 标记一个事务块的开始。
    4.UNWATCH 取消 WATCH 命令对所有 key 的监视。
    5.WATCH key [key ...] 监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断。

## Redis持久化
Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上

### RDB持久化
将某个时间点的所有数据都存放到硬盘上。可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。
如果系统发生故障，将会丢失最后一次创建快照之后的数据。如果数据量大，保存快照的时间会很长。

### AOF持久化(append only file)
将写命令添加到 AOF 文件末尾;使用 AOF 持久化需要设置同步选项，文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。
#### 选项同步频率
  * always每个写命令都同步,选项会严重减低服务器的性能
  * eyerysec每秒同步一次,选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器几乎没有任何影响。
  * no让操作系统来决定何时同步,选项并不能给服务器性能带来多大的提升，而且会增加系统崩溃时数据丢失的数量。
随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

## Redis缓存的过时(6种)淘汰策略
核心思想:如果一个数据最近一段时间没被使用,将来被使用可能性很小,可以淘汰

### noeviction
不淘汰策略，若超过最大内存，返回错误信息

### volitile-ttl
从已设置过期时间的KV集中优先对剩余时间短(time to live)的数据淘汰

###　volitile-random
从已设置过期时间的KV集中随机选择数据淘汰

### allKeys-random
从所有KV集中随机选择数据淘汰

### volatile-lru
从已设置过期时间的KV集中优先对最近最少使用(less recently used)的数据淘汰

### allkeys-lru
从所有KV集中优先对最近最少使用(less recently used)的数据淘汰

### LRU(less recently used)算法
一种缓存置换算法:作用缓存满后(超出容量),需要淘汰老数据,淘汰链标最后一个数据

* 基于linkedHashMap实现:超出定义容量capacity容量,淘汰链标最后一个数据
  1.定义容量capacity 2.重写removeEldest方法 3.构造两个初始化构造器:内引父类构造器,现函数LRUcahe(1参数),LRUcahe(4参数)
* 手写算法:(链表)
  1.定义节点类Node对象:包含前节点对象HeadNode,NodeTail对象
  2.定义LRU内容包括capcity,NodeMap<k,Node>;NodeHead,NodeTail
  3.实现put,add,remove方法

## 缓存常见问题
### 缓存击穿
大量高并发访问,在失效某时刻某个key,导致数据承压
#### 解决方法
* 1.加互斥锁,被锁时,(再访问缓存,还没有结果sleep一会)[循环访问-自旋],一会再递归

### 缓存穿透
大量并发访问Redis没有的key,穿过Redis直接访问数据库,使得数据库承受压力.(主要是查数据库返回null,不会写入缓存)
#### 解决方法
* 1.查到数据库为null要缓存,同时设置过时
* 2.查到数据库为null时做[<font color='red'>BitMap算法</font>](/BitMap算法详解)映射表解析

### 缓存雪崩
设置大量的key时间同时失效,或者某时间缓存宕机
#### 解决方法
* 1.设置时间加入随机因子,使得缓存时间分布均匀
* 2.设置手动刷新缓存
* 3.设置二级缓存,主要缓存时间短,备存时间长
* 4.加锁或队列实现减压
  
## Redis集群
### master-slave模式(主从模式)
通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。一个从服务器只能有一个主服务器，并且不支持主主复制。

### 连接过程
主服务器创建快照文件，即 RDB 文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始像从服务器发送存储在缓冲区的写命令。
从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。
主服务器每执行一次写命令，就向从服务器发送相同的写命令。

### 主从链
随着负载不断上升，主服务器无法很快的更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器
![Redis-Master](/img/Redis-Master.png "Redis-Master")

### 哨兵机制4种原理
Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举处新的主服务器。
[哨兵机制](/img/哨兵机制.png "哨兵机制")

#### 哨兵监控原理
1. 每个哨兵每10s向主从点发送info命令获取最新拓扑结果图(其实只对主节点监控即可,通过主节点发送info获取信息,只要有从节点更新立马感知)
2. 每个哨兵每隔2秒,向主Redis节点订阅其他哨兵节点信息和发布自己节点信息
3. 每个哨兵每隔1秒向主从节点发送ping命令做一次心跳检测
   [哨兵监控机制](/img/哨兵监控机制.png "哨兵监控机制.png")
#### 哨兵判断原理
1. 主观下线:由心跳检测超时,哨兵节点认为该节点错误或下线,可能会存在错误判断
2. 客观下线:当主观下线为主节点时,需要其他通知哨兵节点判断,当哨兵判断超过没定法定人数quorum个数,此哨兵节点则认为主节点有问题(其实就是其他哨兵同意下线)

#### 哨兵选举原理
1. 每个哨兵都可以成为领导,每个哨兵都可以推选自己或同意别人或拒绝别人选举
2. 满足设定当选人数,成为领导并负债故障转移

#### 哨兵故障处理原理
1. 从节点脱离原节点,选择从节点优先级最高,升级为主节点,其他从节点将以此节点为主节点,原主节点变为从节点
2. 将最后更新拓扑图信息通知个节点


## 分片机制
分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。
### 分片2种方法
假设有 4 个 Redis 实例 R0, R1, R2, R3, 还有很多表示用户的键 user:1, user:2, ... , 有不同的方式来选择一个指定的键存储在哪个实例中。
#### 范围分片(最简单,代价高):
例如用户 id 从 0 ~ 1000 的存储到实例 R0 中，用户 id 从 1001 ~ 2000 的存储到实例 R1中等等。但是这样需要维护一张映射范围表，维护操作代价高。
####　哈希分片
使用哈希函数将键转换为一个数字，再对实例数量求模就能知道存储的实例。

#### 处理片3种位置
根据执行分片的位置，可以分为三种分片方式：
  * 客户端分片：客户端使用一致性哈希等算法决定应当分布到哪个节点。
  * 代理分片：将客户端的请求发送到代理上，由代理转发到正确的节点上。
  * 服务器分片：Redis Cluster

## Redis和Memcached的区别
* 存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。
* 数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。
* 使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
* value的大小：redis可以达到1GB，而memcache只有1MB。
