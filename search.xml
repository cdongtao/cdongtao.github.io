<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RESTful-API设计指南</title>
    <url>/2021/01/10/Design-RESTful%20API%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful-API"></a>RESTful-API</h2><p>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷(手机、平板、桌面电脑、其他专用设备……)。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>API与用户的通信协议，总是使用<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">HTTPs协议:防止中间人攻击机制原理(SSL攻击)</a>。</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>应该尽量将API部署在专用域名之下: <a href="https://api.example.com" target="_blank" rel="noopener">https://api.example.com</a><br>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下:<a href="https://example.org/api/" target="_blank" rel="noopener">https://example.org/api/</a></p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>应该将API的版本号放入URL:<a href="https://api.example.com/v1/" target="_blank" rel="noopener">https://api.example.com/v1/</a><br>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>路径又称”终点”(endpoint)，表示API的具体网址。在RESTful架构中，每个网址代表一种资源(resource)，所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”(collection)，所以API中的名词也应该使用复数。<br>举例来说，有一个API提供动物园(zoo)的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;zoos</span><br><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;animals</span><br><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;employees</span><br></pre></td></tr></table></figure>

<h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个(括号里是对应的SQL命令)</p>
<ul>
<li>GET(SELECT):从服务器取出资源(一项或多项)。</li>
<li>POST(CREATE):在服务器新建一个资源。</li>
<li>PUT(UPDATE):在服务器更新资源(客户端提供改变后的完整资源)。</li>
<li>PATCH(UPDATE):在服务器更新资源(客户端提供改变的属性)。</li>
<li>DELETE(DELETE):从服务器删除资源。</li>
</ul>
<p>还有两个不常用的HTTP动词</p>
<ul>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
<p>下面是一些例子</p>
<ul>
<li>GET /zoos：列出所有动物园</li>
<li>POST /zoos：新建一个动物园</li>
<li>GET /zoos/ID：获取某个指定动物园的信息</li>
<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>
<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>
<li>DELETE /zoos/ID：删除某个动物园</li>
<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>
<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>
</ul>
<h3 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h3><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数:</p>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=10：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）</p>
<ul>
<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>
<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>
<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>
<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>
<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>
<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>
<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>
<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>
<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>
<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>
<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可<br>{<br>    error: “Invalid API key”<br>}</p>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><ul>
<li>针对不同操作，服务器向用户返回的结果应该符合以下规范</li>
<li>GET /collection：返回资源对象的列表（数组）</li>
<li>GET /collection/resource：返回单个资源对象</li>
<li>POST /collection：返回新生成的资源对象</li>
<li>PUT /collection/resource：返回完整的资源对象</li>
<li>PATCH /collection/resource：返回完整的资源对象</li>
<li>DELETE /collection/resource：返回一个空文档</li>
</ul>
<h3 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h3><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;link&quot;: &#123;</span><br><span class="line">  &quot;rel&quot;:   &quot;collection https:&#x2F;&#x2F;www.example.com&#x2F;zoos&quot;,</span><br><span class="line">  &quot;href&quot;:  &quot;https:&#x2F;&#x2F;api.example.com&#x2F;zoos&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of zoos&quot;,</span><br><span class="line">  &quot;type&quot;:  &quot;application&#x2F;vnd.yourformat+json&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>API的身份认证应该使用OAuth 2.0框架。</li>
<li>服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</li>
</ul>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Restful</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerFile解析</title>
    <url>/2020/11/21/DevOps-DockerFile%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="OpenShift配置文件"><a href="#OpenShift配置文件" class="headerlink" title="OpenShift配置文件"></a>OpenShift配置文件</h1><p><a href="https://blog.csdn.net/niugang0920/article/details/102726763" target="_blank" rel="noopener">https://blog.csdn.net/niugang0920/article/details/102726763</a></p>
<p>两小时入门 Docker<br><a href="https://mp.weixin.qq.com/s/wquwxxGP2vW7dPfGBvR_Hg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wquwxxGP2vW7dPfGBvR_Hg</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DockerFile/CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门</title>
    <url>/2021/01/09/DevOps-Docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/wquwxxGP2vW7dPfGBvR_Hg" target="_blank" rel="noopener">Docker入门</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker/CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S配置</title>
    <url>/2020/11/24/DevOps-K8S%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="K8S配置文件详解"><a href="#K8S配置文件详解" class="headerlink" title="K8S配置文件详解"></a>K8S配置文件详解</h1><h2 id="K8s-YAML"><a href="#K8s-YAML" class="headerlink" title="K8s YAML"></a>K8s YAML</h2><p>使用命令 kubectl api-versions，查看当前版本支持的apiVersion；<br>Kubernetes 版本 Deployment 版本<br>v1.5-v1.15 extensions/v1beta1<br>v1.7-v1.15 apps/v1beta1<br>v1.8-v1.15 apps/v1beta2<br>v1.9+ apps/v1</p>
<h2 id="创建Deployment-YAML文件"><a href="#创建Deployment-YAML文件" class="headerlink" title="创建Deployment YAML文件"></a>创建Deployment YAML文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1  # 指定api版本，此值必须在kubectl api-versions中  </span><br><span class="line">kind: Deployment  # 指定创建资源的角色&#x2F;类型   </span><br><span class="line">metadata:  # 资源的元数据&#x2F;属性 </span><br><span class="line">  name: demo  # 资源的名字，在同一个namespace中必须唯一</span><br><span class="line">  namespace: default # 部署在哪个namespace中</span><br><span class="line">  labels:  # 设定资源的标签</span><br><span class="line">    app: demo</span><br><span class="line">    version: stable</span><br><span class="line">spec: # 资源规范字段</span><br><span class="line">  replicas: 1 # 声明副本数目</span><br><span class="line">  revisionHistoryLimit: 3 # 保留历史版本</span><br><span class="line">  selector: # 选择器</span><br><span class="line">    matchLabels: # 匹配标签</span><br><span class="line">      app: demo</span><br><span class="line">      version: stable</span><br><span class="line">  strategy: # 策略</span><br><span class="line">    rollingUpdate: # 滚动更新</span><br><span class="line">      maxSurge: 30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数</span><br><span class="line">      maxUnavailable: 30% # 示在更新过程中能够进入不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span><br><span class="line">    type: RollingUpdate # 滚动更新策略</span><br><span class="line">  template: # 模版</span><br><span class="line">    metadata: # 资源的元数据&#x2F;属性 </span><br><span class="line">      annotations: # 自定义注解列表</span><br><span class="line">        sidecar.istio.io&#x2F;inject: &quot;false&quot; # 自定义注解名字</span><br><span class="line">      labels: # 设定资源的标签</span><br><span class="line">        app: demo</span><br><span class="line">        version: stable</span><br><span class="line">    spec: # 资源规范字段</span><br><span class="line">      containers:</span><br><span class="line">      - name: demo # 容器的名字   </span><br><span class="line">        image: demo:v1 # 容器使用的镜像地址   </span><br><span class="line">        imagePullPolicy: IfNotPresent # 每次Pod启动拉取镜像策略，三个选择 Always、Never、IfNotPresent</span><br><span class="line">                                      # Always，每次都检查；Never，每次都不检查（不管本地是否有）；IfNotPresent，如果本地有就不检查，如果没有就拉取（手动测试时，</span><br><span class="line">                                      # 已经打好镜像存在docker容器中时，使用存在不检查级别，</span><br><span class="line">                                      # 默认为每次都检查，然后会进行拉取新镜像，因镜像仓库不存在，导致部署失败）</span><br><span class="line">        resources: # 资源管理</span><br><span class="line">          limits: # 最大使用</span><br><span class="line">            cpu: 300m # CPU，1核心 &#x3D; 1000m</span><br><span class="line">            memory: 500Mi # 内存，1G &#x3D; 1000Mi</span><br><span class="line">          requests:  # 容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">        livenessProbe: # pod 内部健康检查的设置</span><br><span class="line">          httpGet: # 通过httpget检查健康，返回200-399之间，则认为容器正常</span><br><span class="line">            path: &#x2F;healthCheck # URI地址</span><br><span class="line">            port: 8080 # 端口</span><br><span class="line">            scheme: HTTP # 协议</span><br><span class="line">            # host: 127.0.0.1 # 主机地址</span><br><span class="line">          initialDelaySeconds: 30 # 表明第一次检测在容器启动后多长时间后开始</span><br><span class="line">          timeoutSeconds: 5 # 检测的超时时间</span><br><span class="line">          periodSeconds: 30 # 检查间隔时间</span><br><span class="line">          successThreshold: 1 # 成功门槛</span><br><span class="line">          failureThreshold: 5 # 失败门槛，连接失败5次，pod杀掉，重启一个新的pod</span><br><span class="line">        readinessProbe: # Pod 准备服务健康检查设置</span><br><span class="line">          httpGet:</span><br><span class="line">            path: &#x2F;healthCheck</span><br><span class="line">            port: 8080</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">      	#也可以用这种方法   </span><br><span class="line">      	#exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常   </span><br><span class="line">      	#  command:   </span><br><span class="line">      	#    - cat   </span><br><span class="line">      	#    - &#x2F;tmp&#x2F;health   </span><br><span class="line">      	#也可以用这种方法   </span><br><span class="line">      	#tcpSocket: # 通过tcpSocket检查健康  </span><br><span class="line">      	#  port: number </span><br><span class="line">        ports:</span><br><span class="line">          - name: http # 名称</span><br><span class="line">            containerPort: 8080 # 容器开发对外的端口 </span><br><span class="line">            protocol: TCP # 协议</span><br><span class="line">      imagePullSecrets: # 镜像仓库拉取密钥</span><br><span class="line">        - name: harbor-certification</span><br><span class="line">      affinity: # 亲和性调试</span><br><span class="line">        nodeAffinity: # 节点亲和力</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution: # pod 必须部署到满足条件的节点上</span><br><span class="line">            nodeSelectorTerms: # 节点满足任何一个条件就可以</span><br><span class="line">            - matchExpressions: # 有多个选项，则只有同时满足这些逻辑选项的节点才能运行 pod</span><br><span class="line">              - key: beta.kubernetes.io&#x2F;arch</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - amd64</span><br></pre></td></tr></table></figure>

<h2 id="创建Service-YAML文件"><a href="#创建Service-YAML文件" class="headerlink" title="创建Service YAML文件"></a>创建Service YAML文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1 # 指定api版本，此值必须在kubectl api-versions中 </span><br><span class="line">kind: Service # 指定创建资源的角色&#x2F;类型 </span><br><span class="line">metadata: # 资源的元数据&#x2F;属性</span><br><span class="line">  name: demo # 资源的名字，在同一个namespace中必须唯一</span><br><span class="line">  namespace: default # 部署在哪个namespace中</span><br><span class="line">  labels: # 设定资源的标签</span><br><span class="line">    app: demo</span><br><span class="line">spec: # 资源规范字段</span><br><span class="line">  type: ClusterIP # ClusterIP 类型</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8080 # service 端口</span><br><span class="line">      targetPort: http # 容器暴露的端口</span><br><span class="line">      protocol: TCP # 协议</span><br><span class="line">      name: http # 端口名称</span><br><span class="line">  selector: # 选择器</span><br><span class="line">    app: demo</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>K8S/CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装</title>
    <url>/2021/01/09/DevOps-Docker%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/wquwxxGP2vW7dPfGBvR_Hg" target="_blank" rel="noopener">Docker入门</a></p>
<h2 id="安装docker-适用CentOS-7-x-Docker-CE"><a href="#安装docker-适用CentOS-7-x-Docker-CE" class="headerlink" title="安装docker(适用CentOS 7.x / Docker CE)"></a>安装docker(适用CentOS 7.x / Docker CE)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># repo建议使用阿里云的，官方的docker，国内连接起来不稳定</span><br><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line">yum clean all # 清理yum</span><br><span class="line">yum makecache fast # 生成yum repo缓存</span><br><span class="line">yum install docker-ce # 安装docker社区版本</span><br><span class="line">systemctl enable docker # 设置为开机启动</span><br><span class="line">systemctl start docker # 启动docker服务</span><br></pre></td></tr></table></figure>

<h3 id="设置镜像加速器"><a href="#设置镜像加速器" class="headerlink" title="设置镜像加速器"></a>设置镜像加速器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;docker.service</span><br><span class="line"># registry-mirror用的是阿里云的Hub加速器，可以在https:&#x2F;&#x2F;dev.aliyun.com&#x2F;search.html申请自己的专属加速器地址</span><br><span class="line"># 找到ExecStart&#x3D;这行，添加 --registry-mirror&#x3D;https:&#x2F;&#x2F;xxxx.mirror.aliyuncs.com #使用阿里云加速</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd --registry-mirror&#x3D;https:&#x2F;&#x2F;xxxx.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure>

<h3 id="配置docker私服地址（可选）"><a href="#配置docker私服地址（可选）" class="headerlink" title="配置docker私服地址（可选）"></a>配置docker私服地址（可选）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;docker.service</span><br><span class="line"># 找到ExecStart&#x3D;这行，添加 --insecure-registry&#x3D;hub.xxx.com</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd --registry-mirror&#x3D;https:&#x2F;&#x2F;xxxx.mirror.aliyuncs.com --insecure-registry&#x3D;hub.xxx.com</span><br></pre></td></tr></table></figure>

<h3 id="自定义docker存储目录（可选）"><a href="#自定义docker存储目录（可选）" class="headerlink" title="自定义docker存储目录（可选）"></a>自定义docker存储目录（可选）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;docker.service</span><br><span class="line"># 找到ExecStart&#x3D;这行，添加  --graph &#x2F;opt1&#x2F;docker</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd --registry-mirror&#x3D;https:&#x2F;&#x2F;xxxx.mirror.aliyuncs.com --insecure-registry&#x3D;hub.xxx.com  --graph &#x2F;opt1&#x2F;docker</span><br></pre></td></tr></table></figure>

<h3 id="重启Docker"><a href="#重启Docker" class="headerlink" title="重启Docker"></a>重启Docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload # 重新加载daemon</span><br><span class="line">systemctl restart docker # 重启docker</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker/CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx基础使用教程</title>
    <url>/2021/02/19/Devops-Nginx%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><a href="https://www.toutiao.com/i6692127248272589315" target="_blank" rel="noopener">除了负载均衡，Nginx还可以做很多，限流、缓存、黑白名单等</a><br><a href="https://mp.weixin.qq.com/s/ZhNzkNC2Kxs5OnRni21Z5w" target="_blank" rel="noopener">Nginx 反向代理和负载均衡策略实战案例</a></p>
<h2 id="Nginx基础使用教程"><a href="#Nginx基础使用教程" class="headerlink" title="Nginx基础使用教程"></a>Nginx基础使用教程</h2><h3 id="什么是-Nginx"><a href="#什么是-Nginx" class="headerlink" title="什么是 Nginx"></a>什么是 Nginx</h3><p>Nginx (engine x) 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。</p>
<h3 id="正向代理-amp-amp-反向代理"><a href="#正向代理-amp-amp-反向代理" class="headerlink" title="正向代理 &amp;&amp; 反向代理"></a>正向代理 &amp;&amp; 反向代理</h3><p>，反向代理隐藏真实服务端</p>
<h4 id="什么是正向代理"><a href="#什么是正向代理" class="headerlink" title="什么是正向代理"></a>什么是正向代理</h4><p>正向代理:意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。<font color ="red">正向代理隐藏真实客户端</font></p>
<ul>
<li>例子:用浏览器访问 google网站时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。<br><img src="/devops/1.png" alt="正向代理" title="正向代理"></li>
</ul>
<h4 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理"></a>什么是反向代理</h4><p>反向代理（Reverse Proxy）:是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。<font color ="red">反向代理隐藏了真实的服务端</font></p>
<ul>
<li>例子:当我们请求 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。<br><img src="/devops/2.png" alt="反向代理" title="反向代理"></li>
</ul>
<h3 id="Nignx-安装"><a href="#Nignx-安装" class="headerlink" title="Nignx 安装"></a>Nignx 安装</h3><p><a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">Nignx下载</a><br><a href="https://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">Nignx安装及配置教程</a></p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>运维基础知识</title>
    <url>/2020/09/12/DevOps-%E8%BF%90%E7%BB%B4%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架0</title>
    <url>/2018/02/14/Framework-Spring%E6%A1%86%E6%9E%B60/</url>
    <content><![CDATA[<h2 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h2><p>解释型语言：不需要编译，在运行的时候逐行翻译解释；修改代码时可以直接修改，可以快速部署，不过性能上会比编译型语言稍差；比如 JavaScript、Python ；</p>
<p>编译型语言：需要通过编译器将源代码编译成机器码才能执行；编译之后如果需要修改代码，在执行之前就需要重新编译。比如 C 语言；</p>
<p>Java 严格来说也是编译型语言，但又介于编译型和解释型之间；Java 不直接生成机器码而是生成中间码：编译期间，是将源码交给编译器生成 class 文件（字节码），这个过程中只做了翻译的工作，并没有把代码放入内存运行；当进入运行期，字节码才被 Java 虚拟机加载、解释成机器语言并运行。</p>
<p><img src="/img/Java%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png" alt="Java加载机制" title="Java加载机制"></p>
<h2 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h2><p>动态语言：是指程序在运行时可以改变自身结构，在运行时确定数据类型，一个对象是否能执行某操作，只取决于它有没有对应的方法，而不在乎它是否是某种类型的对象；比如 JavaScript、Python。</p>
<p>静态语言：相对于动态语言来说，在编译时变量的数据类型就已经确定（使用变量之前必须声明数据类型），在编译时就会进行类型是否匹配；比如 C 语言、Java ；</p>
<h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>Java 反射机制：在运行过程中，对于任意一个类，都能知道其所有的属性和方法；对于任意一个对象，都能调用其属性和方法；这种动态获取类信息和调用对象方法的功能，就是 Java 反射机制。</p>
<p>既然反射里面有一个“反”字，那么我们先看看何为“正”。</p>
<p>在 Java 中，要使用一个类中的某个方法，“正向”都是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList list &#x3D; new ArrayList(); &#x2F;&#x2F;实例化</span><br><span class="line">list.add(&quot;reflection&quot;);  &#x2F;&#x2F;执行方法</span><br></pre></td></tr></table></figure>
<p>那么反向（反射）要如何实现？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;java.util.ArrayList&quot;);</span><br><span class="line">Method method_add &#x3D; clz.getMethod(&quot;add&quot;,Object.class);</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Object object &#x3D; constructor.newInstance();</span><br><span class="line">method_add.invoke(object, &quot;reflection&quot;);</span><br><span class="line"></span><br><span class="line">Method method_get &#x3D; clz.getMethod(&quot;get&quot;,int.class);</span><br><span class="line">System.out.println(method_get.invoke(object, 0));</span><br></pre></td></tr></table></figure>
<p>两段代码执行的结果是一样的，但是“正向”代码在编译前，就已经明确了要运行的类是什么（ArrayList），而第二段代码，只有在代码运行时，才知道运行的类是 java.util.ArrayList。</p>
<h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>讲到这里，有些同学可能会有疑问：“反射有什么用？我明明都已经知道了要使用的类是 ArrayList ，我不能直接 new 一个对象然后执行里面的方法么？”</p>
<p>当然可以！不过很多场景中，在代码运行之前并不知道需要使用哪个类，或者说在运行的时候才决定使用哪个类；</p>
<p>比如有这么一个功能：“调用阿里云的人脸识别 API ”；这还不简单，参考对方的 API 文档，很快就能实现。</p>
<p>上线一个月后，领导说：“咱公司开始和腾讯云合作了，人脸识别的接口改一下吧”。<br>修改上线运行了两个月，领导说：“换回来吧”…  …</p>
<p>当然有聪明的程序员会想到设置一个开关配置，让开关决定走哪段代码逻辑，如果领导哪天想变成亚马逊云的服务，继续写 if-else 就好了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">faceRecognition(Object faceImg)&#123;</span><br><span class="line">if(&quot;AL&quot;.equals(configStr))&#123;</span><br><span class="line">    &#x2F;&#x2F;调用阿里云的人脸识别 API</span><br><span class="line">  &#125;else if(&quot;TX&quot;.equals(configStr))&#123;</span><br><span class="line">    &#x2F;&#x2F;调用腾讯云的人脸识别 API</span><br><span class="line">  &#125;else if(&quot;AM&quot;.equals(configStr))&#123;</span><br><span class="line">    &#x2F;&#x2F;调用亚马逊云的人脸识别 API</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface FaceRecognitionInterface()&#123;</span><br><span class="line">  faceRecognition(Object faceImg) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个实现类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ALFaceRecognition implements FaceRecognitionInterface&#123;</span><br><span class="line">&#x2F;&#x2F;调用阿里云的人脸识别 API 的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TXFaceRecognition implements FaceRecognitionInterface&#123;</span><br><span class="line">&#x2F;&#x2F;调用腾讯云的人脸识别 API 的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用人脸识别功能的代码中：<br>String configStr = “读取配置，走阿里云还是腾讯云”;<br>FaceRecognitionInterface faceRe = Class.forName(configStr).newInstance();<br>faceRe.faceRecognition(faceImg);    </p>
<p>如果上面这个例子，你依然觉得在调用方法中做 if-else 判断，和使用反射实现并没有差太多，但是如果程序员 A 提供接口，程序员 B 提供实现，程序员 C 写客户端呢？</p>
<p>回忆一下 JDBC 的使用，比如创建一个连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Connection getConnection() throws Exception&#123;</span><br><span class="line">  Connection conn &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;初始化驱动类</span><br><span class="line">  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;url&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">return conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：<br>程序员 A 提供接口：Oracle 公司（之前的 Sun）提供 JDBC 标准（接口）。<br>程序员 B 提供实现：各个数据库厂商提供针对自家数据库的实现。<br>程序员 C 写客户端：我等码农在 Java 中敲代码访问数据库。</p>
<p>总结一下Java 反射的作用：可以设计出更为通用和灵活的架构，很多框架为了保证其通用性，可以根据配置加载不用的类，这时候要用到反射。除此之外：</p>
<p>动态代理：在不改变目标对象方法的情况下对方法进行增强，比如使用 AOP 拦截某些方法打印日志，这就需要通过反射执行方法中的内容。</p>
<p>注解：利用反射机制，获取注解并执行对应的行为。</p>
<h3 id="用反射的用法"><a href="#用反射的用法" class="headerlink" title="用反射的用法"></a>用反射的用法</h3><p>上文中我们知道了 Java 运行期的源文件是 class 文件（字节码），所以要使用反射，那么就需要获取到字节码文件对象，在 Java 中，获取字节码文件对象有三种方式：</p>
<p>调用某个类的 class 属性：类名.class<br>调用对象的 getClass() 方法：对象.getClass()<br>使用 Class 类中的 forName() 静态方法：Class.forName(类的全路径) ，建议使用这种方法<br>java.lang.reflect 类库提供了对反射的支持：<br>Field ：可以使用 get 和 set 方法读取和修改对象的属性；<br>Method ：可以使用 invoke() 方法调用对象中的方法；<br>Constructor ：可以用 newInstance() 创建新的对象。</p>
<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><p>优点：在运行时动态获取类和对象中的内容，极大地提高系统的灵活性和扩展性；夸张一些说，反射是框架设计的灵魂。</p>
<p>缺点：会有一定的性能损耗，JVM 无法对这些代码进行优化；破坏类的封装性。</p>
<p>总之，可能大家在平时的开发过程中，感觉自己并没有写过反射相关的代码，但是在我们用到的各种开源框架中，反射无处不在。</p>
]]></content>
      <categories>
        <category>FrameWork</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架2</title>
    <url>/2018/03/02/Framework-Spring%E6%A1%86%E6%9E%B62/</url>
    <content><![CDATA[<h2 id="依赖注入-Dependency-Injection"><a href="#依赖注入-Dependency-Injection" class="headerlink" title="依赖注入(Dependency Injection)"></a>依赖注入(Dependency Injection)</h2><p>注入方式：<br>1.使用构造器注入(xml配置)<br>2.setter方式注入(xml配置,传统方式)<br>3.注解方式(流行springBoot)</p>
<blockquote>
<p>3种方式都是手工装配依赖对象</p>
</blockquote>
<h2 id="手工装配依赖对象-amp-amp-自动装配依赖对象"><a href="#手工装配依赖对象-amp-amp-自动装配依赖对象" class="headerlink" title="手工装配依赖对象 &amp;&amp; 自动装配依赖对象"></a>手工装配依赖对象 &amp;&amp; 自动装配依赖对象</h2><h3 id="手工装配依赖对象"><a href="#手工装配依赖对象" class="headerlink" title="手工装配依赖对象"></a>手工装配依赖对象</h3><p>1.手工装配依赖对象，在这种方式中又有两种编程方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在xml配置文件中，通过在bean节点下配置，如</span><br><span class="line">&lt;bean id&#x3D;&quot;orderService&quot; class&#x3D;&quot;cn.itcast.service.OrderServiceBean&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F;构造器注入</span><br><span class="line">    &lt;constructor-arg index&#x3D;“0” type&#x3D;“java.lang.String” value&#x3D;“xxx”&#x2F;&gt;</span><br><span class="line">    &#x2F;&#x2F;属性setter方法注入</span><br><span class="line">    &lt;property name&#x3D;“name” value&#x3D;“zhao&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>2.中在java代码使用@Autowired或@Resource注解方式进行装配。但我们需要在xml配置文件中配置以下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-2.5.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-2.5.xsd&quot;&gt;</span><br><span class="line">&lt;context:annotation-config&#x2F;&gt;&#x2F;&#x2F;开启注解</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个配置隐式注册了多个对注释进行解析处理的处理器:<br>AutowiredAnnotationBeanPostProcessor，CommonAnnotationBeanPostProcessor，PersistenceAnnotationBeanPostProcessor，RequiredAnnotationBeanPostProcessor<br>注： @Resource注解在spring安装目录的lib\j2ee\common-annotations.jar</p>
</blockquote>
<h3 id="自动装配依赖对象"><a href="#自动装配依赖对象" class="headerlink" title="自动装配依赖对象"></a>自动装配依赖对象</h3><p>自动装配，了解一下就可以，实际应用中并不被推荐使用。例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;com.zhidisoft.service.DeptService&quot; autowire&#x3D;&quot;byName&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="autowire取值属性"><a href="#autowire取值属性" class="headerlink" title="autowire取值属性"></a>autowire取值属性</h4><p> byType:<br>按照类型自动装配，可以根据属性的类型，在容器中寻找跟类型匹配的bean。如果发现<br>多个，那么会抛出异常。如果没有找到，即属性值为null.<br> byname:<br>按照名称装配，可以根据属性的名称，在容器中寻找跟该属性名相同的bean,如果没有<br>找到，即属性值为null。<br> constructor<br>与byType的方式类似，不同之处在于它应用于构造器参数。如果在人那个其中没有找<br>到，即属性值为null。<br> autodetect<br>通过bean类的自省机制（introspection）来决定是使用constructor还是byType方式进行自动装配。（如果发现默认的构造器，那么将使用byType方式）</p>
<h2 id="注入的原理"><a href="#注入的原理" class="headerlink" title="注入的原理"></a>注入的原理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;orderDao&quot; class&#x3D;&quot;cn.itcast.service.OrderDao&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;orderService&quot; class&#x3D;&quot;cn.itcast.service.OrderServiceBean&quot;&gt;</span><br><span class="line">  &#x2F;&#x2F;用来给Bean内部一个对象的属性设置初始值,setter方法注入</span><br><span class="line">  &lt;property name&#x3D;&quot;orderDao&quot; ref&#x3D;&quot;orderDao&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;初始化Bean对象包含的属性值,setter方法注入</span><br><span class="line">  &lt;property name&#x3D;“name” value&#x3D;“zhao&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;构造器注入 index&#x3D;0,type对应第一个参数和类型</span><br><span class="line">  &lt;constructor-arg index&#x3D;“0” type&#x3D;“java.lang.String” value&#x3D;“xxx”&#x2F;&gt;</span><br><span class="line">  &#x2F;&#x2F;index&#x3D;1,type对应第二个参数和类型</span><br><span class="line">  &lt;constructor-arg index&#x3D;“1” type&#x3D;“java.lang.String” value&#x3D;“xxx”&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">集合类型的配置：List,map,set,properties类型属性都可以配置在xml的bean里</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&lt;BeanDefinition&gt; beanDefines &#x3D; new ArrayList&lt;BeanDefinition&gt;();</span><br><span class="line">private Map&lt;String, Object&gt; sigletons &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">&#x2F;&#x2F;定义一个Bean对象</span><br><span class="line">public class BeanDefinition &#123;</span><br><span class="line">	private String id;</span><br><span class="line">	private String className;</span><br><span class="line">  &#x2F;&#x2F;bean里面的属性</span><br><span class="line">	private List&lt;PropertyDefinition&gt; propertys &#x3D; new ArrayList&lt;PropertyDefinition&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义一个Bean包含的属性对象</span><br><span class="line">public class PropertyDefinition &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private String ref;</span><br><span class="line">	private String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取并解析XML文件"><a href="#读取并解析XML文件" class="headerlink" title="读取并解析XML文件"></a>读取并解析XML文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void readXML(String filename) &#123;</span><br><span class="line">	  SAXReader saxReader &#x3D; new SAXReader();   </span><br><span class="line">	  Document document&#x3D;null;   </span><br><span class="line">	  try&#123;</span><br><span class="line">	     URL xmlpath &#x3D; this.getClass().getClassLoader().getResource(filename);</span><br><span class="line">	     document &#x3D; saxReader.read(xmlpath);</span><br><span class="line">	     Map&lt;String,String&gt; nsMap &#x3D; new HashMap&lt;String,String&gt;();</span><br><span class="line">	     nsMap.put(&quot;ns&quot;,&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;);&#x2F;&#x2F;加入命名空间</span><br><span class="line">	     XPath xsub &#x3D; document.createXPath(&quot;&#x2F;&#x2F;ns:beans&#x2F;ns:bean&quot;);&#x2F;&#x2F;创建beans&#x2F;bean查询路径</span><br><span class="line">	     xsub.setNamespaceURIs(nsMap);&#x2F;&#x2F;设置命名空间</span><br><span class="line">	     List&lt;Element&gt; beans &#x3D; xsub.selectNodes(document);&#x2F;&#x2F;获取文档下所有bean节点 </span><br><span class="line">	     for(Element element: beans)&#123;</span><br><span class="line">	       String id &#x3D; element.attributeValue(&quot;id&quot;);&#x2F;&#x2F;获取id属性值</span><br><span class="line">	       String clazz &#x3D; element.attributeValue(&quot;class&quot;); &#x2F;&#x2F;获取class属性值        </span><br><span class="line">	       BeanDefinition beanDefine &#x3D; new BeanDefinition(id, clazz);</span><br><span class="line">	       XPath propertysub &#x3D;  element.createXPath(&quot;ns:property&quot;);</span><br><span class="line">	       propertysub.setNamespaceURIs(nsMap);&#x2F;&#x2F;设置命名空间</span><br><span class="line">	       List&lt;Element&gt; propertys &#x3D; propertysub.selectNodes(element);</span><br><span class="line">	       for(Element property : propertys)&#123;	            	</span><br><span class="line">	         String propertyName &#x3D; property.attributeValue(&quot;name&quot;);</span><br><span class="line">	         String propertyref &#x3D; property.attributeValue(&quot;ref&quot;);</span><br><span class="line">	         String propertyValue &#x3D; property.attributeValue(&quot;value&quot;);</span><br><span class="line">	         PropertyDefinition propertyDefinition &#x3D; </span><br><span class="line">                    new PropertyDefinition(propertyName, propertyref, propertyValue);</span><br><span class="line">	            beanDefine.getPropertys().add(propertyDefinition);</span><br><span class="line">	       &#125;</span><br><span class="line"></span><br><span class="line">	      beanDefines.add(beanDefine);</span><br><span class="line">	      &#125; </span><br><span class="line">	  &#125;catch(Exception e)&#123;   </span><br><span class="line">	      e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="bean的实例化"><a href="#bean的实例化" class="headerlink" title="bean的实例化"></a>bean的实例化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void instanceBeans() &#123;</span><br><span class="line">for(BeanDefinition beanDefinition : beanDefines)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    if(beanDefinition.getClassName()!&#x3D;null &amp;&amp; !&quot;&quot;.equals(beanDefinition.getClassName().trim()))</span><br><span class="line">      &#x2F;&#x2F;new 的对象里面的属性为空，还没注入需要注入属性值</span><br><span class="line">      sigletons.put(beanDefinition.getId(), Class.forName(beanDefinition.getClassName()).newInstance());</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="为bean初始化对象属性注入值"><a href="#为bean初始化对象属性注入值" class="headerlink" title="为bean初始化对象属性注入值"></a>为bean初始化对象属性注入值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void injectObject() &#123;</span><br><span class="line">  &#x2F;&#x2F;遍历已经实例化的bean对象容器</span><br><span class="line">  for(BeanDefinition beanDefinition : beanDefines)&#123;</span><br><span class="line">    Object bean &#x3D; sigletons.get(beanDefinition.getId());</span><br><span class="line">    if(bean!&#x3D;null)&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F;获取当前实例化对象里属性描述</span><br><span class="line">        PropertyDescriptor[] ps &#x3D; </span><br><span class="line">               Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();</span><br><span class="line">        &#x2F;&#x2F;遍历当前Bean对象里面包含的属性</span><br><span class="line">        for(PropertyDefinition propertyDefinition : beanDefinition.getPropertys())&#123;</span><br><span class="line">          &#x2F;&#x2F;遍历当前Bean对象里的属性描述</span><br><span class="line">          for(PropertyDescriptor properdesc : ps)&#123;</span><br><span class="line">            if(propertyDefinition.getName().equals(properdesc.getName()))&#123;</span><br><span class="line">              &#x2F;&#x2F;获取属性的setter方法 ,private</span><br><span class="line">              Method setter &#x3D; properdesc.getWriteMethod();</span><br><span class="line">              if(setter!&#x3D;null)&#123;</span><br><span class="line">                Object value &#x3D; null;</span><br><span class="line">                if(propertyDefinition.getRef()!&#x3D;null </span><br><span class="line">                        &amp;&amp; !&quot;&quot;.equals(propertyDefinition.getRef().trim()))&#123;</span><br><span class="line">                  &#x2F;&#x2F;bean 的ref 属性注入(内部包含其他javaBean的注入：orderDao)</span><br><span class="line">                  value &#x3D; sigletons.get(propertyDefinition.getRef());</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                  &#x2F;&#x2F;bean的value属性注入(java基本类型):将字符串专成对应的类型值</span><br><span class="line">                  value &#x3D; ConvertUtils.convert(propertyDefinition.getValue(), properdesc.getPropertyType());</span><br><span class="line">                &#125;</span><br><span class="line">                setter.setAccessible(true);</span><br><span class="line">                &#x2F;&#x2F;把引用对象注入到属性</span><br><span class="line">                setter.invoke(bean, value);</span><br><span class="line">              &#125;</span><br><span class="line">              break;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过注解实现注入依赖对象"><a href="#通过注解实现注入依赖对象" class="headerlink" title="通过注解实现注入依赖对象"></a>通过注解实现注入依赖对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void annotationInject() &#123;</span><br><span class="line">  &#x2F;&#x2F;遍历spring容器里所有bean对象</span><br><span class="line">  for(String beanName : sigletons.keySet())&#123;</span><br><span class="line">    Object bean &#x3D; sigletons.get(beanName);</span><br><span class="line">    if(bean!&#x3D;null)&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F;获取某个bean对象的所有属性</span><br><span class="line">        PropertyDescriptor[] ps &#x3D; </span><br><span class="line">                  Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();</span><br><span class="line">        &#x2F;&#x2F;遍历每个setter属性,将注解的值注入</span><br><span class="line">        for(PropertyDescriptor properdesc : ps)&#123;</span><br><span class="line">          &#x2F;&#x2F;获取方法属性的setter方法注解</span><br><span class="line">          Method setter &#x3D; properdesc.getWriteMethod();</span><br><span class="line">          if(setter!&#x3D;null &amp;&amp; setter.isAnnotationPresent(ItcastResource.class))&#123;</span><br><span class="line"></span><br><span class="line">            ItcastResource resource &#x3D; setter.getAnnotation(ItcastResource.class);</span><br><span class="line">            Object value &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F;方法属性注解里有name对应属性,存在有值就注入</span><br><span class="line">            if(resource.name()!&#x3D;null &amp;&amp; !&quot;&quot;.equals(resource.name()))&#123;</span><br><span class="line">              value &#x3D; sigletons.get(resource.name());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">              &#x2F;&#x2F;处理@resource&#x2F;autowired注解</span><br><span class="line">              &#x2F;&#x2F;在方法属性注解上,没name属性的以set字段名字(开头字母小写)来bean容器取对象注入</span><br><span class="line">              value &#x3D; sigletons.get(properdesc.getName());</span><br><span class="line">              if(value&#x3D;&#x3D;null)&#123;</span><br><span class="line">              &#x2F;&#x2F;如果按照名称没找到对应对象,则注解会按照方法属性入参类型来容器取对象注入</span><br><span class="line">                for(String key : sigletons.keySet())&#123;</span><br><span class="line">                  if(properdesc.getPropertyType()</span><br><span class="line">                  .isAssignableFrom(sigletons.get(key).getClass()))&#123;</span><br><span class="line">                    value &#x3D; sigletons.get(key);</span><br><span class="line">                    break;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;								</span><br><span class="line">            &#125;</span><br><span class="line">            setter.setAccessible(true);</span><br><span class="line">            setter.invoke(bean, value);&#x2F;&#x2F;把引用对象注入到属性</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;对字段注解处理：取得对象所有的声明字段</span><br><span class="line">        Field[] fields &#x3D; bean.getClass().getDeclaredFields();</span><br><span class="line">        for(Field field : fields)&#123;</span><br><span class="line">          &#x2F;&#x2F;遍历每一个字段是否存在对应注解</span><br><span class="line">          if(field.isAnnotationPresent(ItcastResource.class))&#123;</span><br><span class="line">            ItcastResource resource &#x3D; field.getAnnotation(ItcastResource.class);</span><br><span class="line">            Object value &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F;字段上对应的注解存在name属性,取name属性值去容器里拿对象注入</span><br><span class="line">            if(resource.name()!&#x3D;null &amp;&amp; !&quot;&quot;.equals(resource.name()))&#123;</span><br><span class="line">              value &#x3D; sigletons.get(resource.name());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;字段上没有name属性,直接取字段名在容器中取对象</span><br><span class="line">              value &#x3D; sigletons.get(field.getName());</span><br><span class="line">              if(value&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;字段名没有直接取字段对应类型在容器中取对象</span><br><span class="line">                for(String key : sigletons.keySet())&#123;</span><br><span class="line">                  if(field.getType().isAssignableFrom(sigletons.get(key).getClass()))&#123;</span><br><span class="line">                    value &#x3D; sigletons.get(key);</span><br><span class="line">                    break;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;								</span><br><span class="line">            &#125;</span><br><span class="line">            field.setAccessible(true);&#x2F;&#x2F;允许访问private字段</span><br><span class="line">            field.set(bean, value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;car&quot; class&#x3D;&quot;com.baiding.model.Car&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destory&quot;&gt;</span><br><span class="line"></span><br><span class="line">@Bean 注解默认创建单实例的bean,</span><br><span class="line">1.对于单实例的bean来说：</span><br><span class="line">@Bean(initMethod &#x3D; &quot;init&quot;)</span><br><span class="line">当对象创建完成，并完成赋值操作之后，开始调用初始化方法 init()</span><br><span class="line">初始化之后执行： @PostConstruct  &gt; init-method</span><br><span class="line">@Bean(destroyMethod &#x3D; &quot;destory&quot;)</span><br><span class="line">当容器关闭的时候，执行销毁方法 destory()</span><br><span class="line">销毁之前执行：@preDestroy &gt; destoryMethod</span><br><span class="line"></span><br><span class="line">2.对于多实例的bean来说:(只需将bean的@Scope设置为prototype)</span><br><span class="line">每次获取bean时都会创建一个实例，容器不会管理这个bean,也就是说容器关闭的时候不会调用多实例bean的销毁方法。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FrameWork</category>
      </categories>
      <tags>
        <tag>注入原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架3</title>
    <url>/2018/03/03/Framework-Spring%E6%A1%86%E6%9E%B63/</url>
    <content><![CDATA[<h2 id="AOP-Aspect-Oriented-Programming"><a href="#AOP-Aspect-Oriented-Programming" class="headerlink" title="AOP(Aspect Oriented Programming)"></a>AOP(Aspect Oriented Programming)</h2><p>OOP允许开发者定义纵向的关系,在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块(抽象出全局方法)，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<blockquote>
<p>SpringAOP、事物原理、日志打印、权限控制、远程调用、安全代理 可以隐蔽真实角色<br>Spring声明式事务管理器类：<br>Jdbc技术：DataSourceTransactionManager<br>Hibernate技术：HibernateTransactionManager</p>
</blockquote>
<h2 id="提出问题及解决思路"><a href="#提出问题及解决思路" class="headerlink" title="提出问题及解决思路"></a>提出问题及解决思路</h2><p>现在提出这样一个需求：</p>
<p>1.拦截某个类或全部业务方法。<br>2.判断用户是否有权限，有权限就允许他执行业务方法，没有权限就不允许他执行业务方法。(是否有权限是根据user是否为null作为判断依据的)<br><img src="/img/AOP.png" alt="AOP解决方案" title="AOP解决方案"></p>
<p>解决方法：<br>1.最直接得方法是：所有方法都加上判断.//不是实际<br>2.做个过滤器：适合拦截所有业务；但是不是合适拦截某个类得业务<br>3.AOP使用代理处理：适合所有业务或某个业务；在执行目标前创建代理，在代理这一层做处理,满足处理条件后再调用真实对象处理得方法处理业务(动态代理就是动态得将需要处理业务包装成一个新类新方法里面，这样就能在包装得新方法处理业务前后处理切面需求)</p>
<h2 id="AOP代理技术"><a href="#AOP代理技术" class="headerlink" title="AOP代理技术"></a>AOP代理技术</h2><h4 id="JDK动态代理-amp-amp-Cglib技术-差异"><a href="#JDK动态代理-amp-amp-Cglib技术-差异" class="headerlink" title="JDK动态代理 &amp;&amp; Cglib技术 差异"></a>JDK动态代理 &amp;&amp; Cglib技术 差异</h4><p>1.JDK的动态代理有个限制，就是使用动态代理的目标对象必须实现至少一个接口，由此，没有实现接口但是想要使用代理的目标对象，就可以使用Cglib代理。<br>2.Cglib是强大的高性能的代码生成包，它可以在运行期间拓展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和synaop，为他们提供方法的interception(拦截)。<br>3.Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类，不鼓励直接只使用ASM，因为它要求你必须对JVM内部结构，包括class文件的格式和指令集都很熟悉。</p>
<h4 id="JDK动态代理技术"><a href="#JDK动态代理技术" class="headerlink" title="JDK动态代理技术"></a>JDK动态代理技术</h4><p>必须条件：<br>1.存在接口(原对象必须是以接口形式实现得对象)<br>2.实现InvocationHandler接口，重写invoke方法<br>或 Proxy.newProxyInstance实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JDKProxyFactory implements InvocationHandler &#123;</span><br><span class="line">    private Object targetObject; &#x2F;&#x2F; 代理的目标对象</span><br><span class="line"></span><br><span class="line">    public Object createProxyInstance(Object targetObject) &#123;</span><br><span class="line">        this.targetObject &#x3D; targetObject; </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 第一个参数设置代码使用的类装载器，一般采用跟目标类相同的类装载器</span><br><span class="line">         * 第二个参数设置代理类实现的接口</span><br><span class="line">         * 第三个参数设置回调对象，当代理对象的方法被调用时，会委派给该参数指定对象的invoke方法</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return Proxy.newProxyInstance(this.targetObject.getClass().getClassLoader(), </span><br><span class="line">                this.targetObject.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        PersonServiceBean bean &#x3D; (PersonServiceBean)this.targetObject;</span><br><span class="line">        Object result &#x3D; null;</span><br><span class="line">        if (bean.getUser() !&#x3D; null) &#123; &#x2F;&#x2F; 有权限</span><br><span class="line">            result &#x3D; method.invoke(targetObject, args); &#x2F;&#x2F; 把方法调用委派给目标对象</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object getProxyInstance() &#123;</span><br><span class="line">    return Proxy.newProxyInstance(</span><br><span class="line">     target.getClass().getClassLoader(),target.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                    System.out.println(&quot;日志打印： before&quot;);</span><br><span class="line">                    &#x2F;&#x2F;执行目标对象方法</span><br><span class="line">                    Object returnValue &#x3D; method.invoke(target,args;</span><br><span class="line">                    System.out.println(&quot;日志打印： after&quot;);</span><br><span class="line">                    return returnValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="CGLIB动态代理技术"><a href="#CGLIB动态代理技术" class="headerlink" title="CGLIB动态代理技术"></a>CGLIB动态代理技术</h4><p>Cglib代理，也叫做子类代理，它是在内存中构件一个子类对象，从而实现对目标对象的功能拓展。<br>注：通过类继承方式实现动态代理(不存在接口);实现MethodInterceptor 接口重写intercept方法<br>在Maven中可以直接在POM.xml中添加下列引用即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;cglib&#x2F;cglib --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不是maven项目，除了到cglib包还需要导入asm.jar包，不然会报异常</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyProxyByGclib implements MethodInterceptor &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;维护目标对象</span><br><span class="line">    private Object target;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    public MyProxyByGclib(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object getProxyInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;1. 实例化工具类</span><br><span class="line">        Enhancer en &#x3D; new Enhancer();</span><br><span class="line">        &#x2F;&#x2F;2. 设置父类对象</span><br><span class="line">        en.setSuperclass(this.target.getClass());</span><br><span class="line">        &#x2F;&#x2F;3. 设置回调函数</span><br><span class="line">        en.setCallback(this);</span><br><span class="line">        &#x2F;&#x2F;4. 创建子类，也就是代理对象</span><br><span class="line">        return en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override &#x2F;&#x2F; @Around---&gt;从另一种角度看：整个方法可看作环绕通知,代理生产最新整个方法</span><br><span class="line">    public Object intercept(Object proxy, Method method, Object[] objects, MethodProxy arg3)&#123;</span><br><span class="line">        System.out.println(&quot;Begin Transaction&quot;);</span><br><span class="line">            &#x2F;&#x2F; @Before----&gt; 前置通知(所谓通知，就是我们拦截到业务方法之后所要干的事情)</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;执行目标对象的方法</span><br><span class="line">            Object returnValue &#x3D; method.invoke(target, objects);</span><br><span class="line">            &#x2F;&#x2F;@AfterReturning ----&gt; 后置通知</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;@AfterThrowing ----&gt; 异常通知</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; @After ----&gt; 最终通知</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(&quot;End Transaction&quot;);</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;目标对象</span><br><span class="line">        MyServiceImpl myService &#x3D; new MyServiceImpl();</span><br><span class="line">        &#x2F;&#x2F;生成代理对象</span><br><span class="line">        MyServiceImpl myProxy &#x3D; (MyServiceImpl)new MyProxyByGclib(myService).getProxyInstance();</span><br><span class="line">        &#x2F;&#x2F;调用对象方法</span><br><span class="line">        myProxy.eat();</span><br><span class="line">        myProxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现AOP方式-xml配置-注解方式"><a href="#实现AOP方式-xml配置-注解方式" class="headerlink" title="实现AOP方式(xml配置 || 注解方式)"></a>实现AOP方式(xml配置 || 注解方式)</h2><h3 id="AOP-核心概念"><a href="#AOP-核心概念" class="headerlink" title="AOP 核心概念"></a>AOP 核心概念</h3><p><img src="/img/AOP%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.png" alt="AOP核心概念" title="AOP核心概念"></p>
<ol>
<li><p>切面（Aspect）<br>　　对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。切面就是在一个怎么样的环境中工作。类是对物体特征的抽象，切面就是对横切关注点的抽象。比如数据库的事务直接贯穿了整个代码层面，这就是一个切面，它能够在被代理对象的方法之前,之后,产生异常或者正常返回后切入你的代码，甚至代替原来被代理对象的方法，在动态代理中可以把它理解成一个拦截器。</p>
</li>
<li><p>通知（Adice）<br>　　•通知是切面开启后，切面的方法。它根据在代理对象真实方法调用前、后的顺序和逻辑区分，它和约定游戏的例子里的拦截器的方法十分接近。<br>　　•前置通知（before）：在动态代理反射原有对象方法或者执行环绕通知前执行的通知功能。<br>　　•后置通知（after）： 在动态代理反射原有对象方法或者执行环绕通知后执行的通知功能。无论是否抛出异常，它都会被执行。<br>　　•返回通知（afterReturning）：在动态代理反射原有对象方法或者执行环绕通知后执行的通知功能。<br>　　•异常通知（afterThrowing）：在动态代理反射原有对象方法或者执行环绕通知产生异常后执行的通知功能。<br>　　•环绕通知（aroundThrowing）：在动态代理中，它可以取代当前被拦截对象的方法，通过参数或反射调用被拦截对象的方法。</p>
</li>
</ol>
<blockquote>
<p>afterReturning处理&lt; after处理:afterReturning 在处理在after处理后</p>
</blockquote>
<ol start="3">
<li><p>引入（Introduction）<br>　　在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段.</p>
</li>
<li><p>切入点（Pointcut）<br>　　在动态代理中，被切面拦截的方法就是一个切点，切面将可以将其切点和被拦截的方法按照一定的逻辑织入到约定流程当中.</p>
</li>
<li><p>连接点（join point）<br>　　连接点是一个判断条件，由它可以指定哪些是切点。对于指定的切点，Spring会生成代理对象去使用对应的切面对其拦截，否则就不会拦截它。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
</li>
<li><p>织入（Weaving）<br>　　织入是一个生成代理对象的过程。实际代理的方法分为静态代理和动态代理。静态代理是在编译class文件时生成的代码逻辑，但是在Spring中并不使用这样的方式，所以我们就不展开讨论了。一种是通过ClassLoader也就是在类加载的时候生成的代码逻辑，但是它在应用程序代码运行前就生成对应的逻辑。还有一种是运行期，动态生成代码的方式，这是Spring AOP所采用的方式，Spring是以JDK和CGLIB动态代理来生成代理对象的</p>
</li>
</ol>
<h3 id="1-Spring-xml配置文件"><a href="#1-Spring-xml配置文件" class="headerlink" title="1.Spring xml配置文件"></a>1.Spring xml配置文件</h3><p>下面给出一个Spring AOP的.xml文件模板，名字叫做aop.xml，之后的内容都在aop.xml上进行扩展：</p>
<p>使用Spring AOP，只用Spring提供给开发者的jar包是不够的，请额外上网下载两个jar包：<br>1、aopalliance.jar<br>2、aspectjweaver.jar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.2.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;helloWorldImpl1&quot; class&#x3D;&quot;com.xrq.aop.HelloWorldImpl1&quot; &#x2F;&gt;</span><br><span class="line">        &lt;bean id&#x3D;&quot;helloWorldImpl2&quot; class&#x3D;&quot;com.xrq.aop.HelloWorldImpl2&quot; &#x2F;&gt;</span><br><span class="line">        &lt;bean id&#x3D;&quot;timeHandler&quot; class&#x3D;&quot;com.xrq.aop.TimeHandler&quot; &#x2F;&gt;</span><br><span class="line">        &lt;bean id&#x3D;&quot;logHandler&quot; class&#x3D;&quot;com.xrq.aop.LogHandler&quot; &#x2F;&gt;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 要想让logHandler在timeHandler前使用有两个办法：</span><br><span class="line">        &#x2F;&#x2F;（1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序</span><br><span class="line">        &#x2F;&#x2F;（2）把logHandler定义在timeHandler前面，Spring默认以aspect的定义顺序作为织入顺序</span><br><span class="line">        &lt;aop:config&gt;</span><br><span class="line">            &lt;aop:aspect id&#x3D;&quot;time&quot; ref&#x3D;&quot;timeHandler&quot; order&#x3D;&quot;1&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id&#x3D;&quot;addTime&quot; expression&#x3D;&quot;execution(* com.xrq.aop.HelloWorld.print*(..))&quot; &#x2F;&gt;</span><br><span class="line">                &lt;aop:before method&#x3D;&quot;printTime&quot; pointcut-ref&#x3D;&quot;addTime&quot; &#x2F;&gt;</span><br><span class="line">                &lt;aop:after method&#x3D;&quot;printTime&quot; pointcut-ref&#x3D;&quot;addTime&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;aop:aspect&gt;</span><br><span class="line">            &lt;aop:aspect id&#x3D;&quot;log&quot; ref&#x3D;&quot;logHandler&quot; order&#x3D;&quot;2&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id&#x3D;&quot;printLog&quot; expression&#x3D;&quot;execution(* com.xrq.aop.HelloWorld.do*(..))&quot; &#x2F;&gt;</span><br><span class="line">                &lt;aop:before method&#x3D;&quot;LogBefore&quot; pointcut-ref&#x3D;&quot;printLog&quot; &#x2F;&gt;</span><br><span class="line">                &lt;aop:after method&#x3D;&quot;LogAfter&quot; pointcut-ref&#x3D;&quot;printLog&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;aop:aspect&gt;</span><br><span class="line">        &lt;&#x2F;aop:config&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">强制使用CGLIB生成代理</span><br><span class="line">前面说过Spring使用动态代理或是CGLIB生成代理是有规则的，高版本的Spring会自动选择是使用动态代理还是CGLIB生成代理内容，当然我们也可以强制使用CGLIB生成代理，那就是&lt;aop:config&gt;里面有一个&quot;proxy-target-class&quot;属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用</span><br></pre></td></tr></table></figure>

<h3 id="实现AOP的注解方式"><a href="#实现AOP的注解方式" class="headerlink" title="实现AOP的注解方式"></a>实现AOP的注解方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启事物注解权限：传统spring xml配置开启注解模式</span><br><span class="line">    &lt;aop:aspectj-autoproxy&gt;&lt;&#x2F;aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure>
<p>五个注解:<br>@Aspect 指定一个类为切面类<br>@Pointcut(“execution(* com.itmayiedu.service.UserService.add(…))”) 指定切入点表达式<br>@Before(“pointCut_()”) 前置通知: 目标方法之前执行<br>@After(“pointCut_()”) 后置通知：目标方法之后执行（始终执行）<br>@AfterReturning(“pointCut_()”) 返回后通知： 执行方法结束前执行(异常不执行)<br>@AfterThrowing(“pointCut_()”) 异常通知: 出现异常时候执行<br>@Around(“pointCut_()”) 环绕通知： 环绕目标方法执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyInterceptor &#123;</span><br><span class="line">    @Pointcut(&quot;execution (* cn.itcast.service.impl.PersonServiceImpl.*(..))&quot;)</span><br><span class="line">    private void anyMethod() &#123;&#125; &#x2F;&#x2F; 声明一个切入点，anyMethod为切入点名称</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 声明该方法是一个前置通知：在目标方法开始之前执行 </span><br><span class="line">   1. @Before(&quot;anyMethod()&quot;)</span><br><span class="line">    public void doAccessCheck() &#123;</span><br><span class="line">        System.out.println(&quot;前置通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   2. @AfterReturning(&quot;anyMethod()&quot;)</span><br><span class="line">    public void doAfterReturning() &#123;</span><br><span class="line">        System.out.println(&quot;后置通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   3. @After(&quot;anyMethod()&quot;)</span><br><span class="line">    public void doAfter() &#123;</span><br><span class="line">        System.out.println(&quot;最终通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   4. @AfterThrowing(&quot;anyMethod()&quot;)</span><br><span class="line">    public void doAfterThrowing() &#123;</span><br><span class="line">        System.out.println(&quot;异常通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   5. @Around(&quot;anyMethod()&quot;)</span><br><span class="line">    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;进入方法&quot;);</span><br><span class="line">        Object result &#x3D; pjp.proceed();</span><br><span class="line">        System.out.println(&quot;退出方法&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注解执行顺序"><a href="#注解执行顺序" class="headerlink" title="注解执行顺序"></a>注解执行顺序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override &#x2F;&#x2F; @Around---&gt;从另一种角度看：整个方法可看作环绕通知,代理生产最新整个方法</span><br><span class="line">public Object intercept(Object proxy, Method method, Object[] objects, MethodProxy arg3)&#123;</span><br><span class="line">        &#x2F;&#x2F;@Around进入方法</span><br><span class="line">        &#x2F;&#x2F; @Before----&gt; 前置通知(所谓通知，就是我们拦截到业务方法之后所要干的事情)</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;执行目标对象的方法</span><br><span class="line">        Object returnValue &#x3D; method.invoke(target, objects);</span><br><span class="line">        &#x2F;&#x2F;@AfterReturning ----&gt; 后置通知</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        &#x2F;&#x2F;@AfterThrowing ----&gt; 异常通知</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; @After ----&gt; 最终通知</span><br><span class="line">        &#125;</span><br><span class="line">    System.out.println(&quot;End Transaction&quot;);</span><br><span class="line">    return returnValue;</span><br><span class="line">        &#x2F;&#x2F;@Around退出方法 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Around进入方法–&gt;@Before–&gt;目标函数–&gt;@AfterReturning(or @AfterThrowing)–&gt;@After–&gt;@Around退出方法 </p>
</blockquote>
<p>不同切面间的执行顺序:多个切面嵌套<br>如果知道上面的执行顺序，不同 Aspect 切面的执行顺序很好理解。<br>首先根据 @Order 注解，或者 xml 中的顺序，先进入到顺序靠前的切面。<br>然后我们只需要把上面执行顺序中执行目标函数位置替换为第二个切面的执行顺序，同理，第三个切面的执行位置，就是把第二个切面的执行顺序里面执行目标函数替换即可，以此类推。</p>
<p>需要注意的是异常的抛出，我们的环绕通知是有能力捕获目标函数异常并且不抛出的，如果捕获并且不抛出，会触发后置返回通知而不会触发后置异常通知，同时也会影响其他切面的执行。所以我们捕获处理后，还要抛出去。</p>
<h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><h5 id="切入点指示符"><a href="#切入点指示符" class="headerlink" title="切入点指示符"></a>切入点指示符</h5><p>　　切入点指示符用来指示切入点表达式目的，在Spring AOP中目前只有执行方法这一个连接点，Spring AOP支持的AspectJ切入点指示符如下：</p>
<p>execution：用于匹配方法执行的连接点；<br>within：用于匹配指定的类及其子类中的所有方法。<br>this：匹配可以向上转型为this指定的类型的代理对象中的所有方法。<br>target：匹配可以向上转型为target指定的类型的目标对象中的所有方法。<br>args：用于匹配运行时传入的参数列表的类型为指定的参数列表类型的方法；<br>@within：用于匹配持有指定注解的类的所有方法；<br>@target：用于匹配的持有指定注解目标对象的所有方法；<br>@args：用于匹配运行时 传入的参数列表的类型持有 注解列表对应的注解 的方法；<br>@annotation：用于匹配持有指定注解的方法；<br>　　AspectJ切入点支持的切入点指示符还有： call、get、set、preinitialization、staticinitialization、initialization、handler、adviceexecution、withincode、cflow、cflowbelow、if、@this、@withincode；但Spring AOP目前不支持这些指示符，使用这些指示符将抛出IllegalArgumentException异常。</p>
<h5 id="类型匹配语法"><a href="#类型匹配语法" class="headerlink" title="类型匹配语法"></a>类型匹配语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) *：匹配任何数量字符；</span><br><span class="line">(2) ..：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包；而在方法参数模式中匹配任何数量参数</span><br><span class="line">(3) +：匹配指定类型的子类型；仅能作为后缀放在类型模式后边。</span><br><span class="line">AspectJ使用 且（&amp;&amp;）、或（||）、非（！）来组合切入点表达式。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Schema风格下，由于在XML中使用“&amp;&amp;”需要使用转义字符“&amp;&amp;”来代替之，所以很不&gt;方便，因此Spring ASP 提供了and、or、not来代替&amp;&amp;、||、！。</p>
</blockquote>
<h4 id="常见切入点表达式"><a href="#常见切入点表达式" class="headerlink" title="常见切入点表达式"></a>常见切入点表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任意公共方法的执行： </span><br><span class="line">execution(public * *(..)) </span><br><span class="line"></span><br><span class="line">任何一个以“set”开始的方法的执行： </span><br><span class="line">execution(* set*(..)) </span><br><span class="line"></span><br><span class="line">AccountService 接口的任意方法的执行： </span><br><span class="line">execution(* com.xyz.service.AccountService.*(..)) </span><br><span class="line"></span><br><span class="line">定义在service包里的任意方法的执行： </span><br><span class="line">execution(* com.xyz.service.*.*(..)) </span><br><span class="line"></span><br><span class="line">定义在service包或者子包里的任意方法的执行： </span><br><span class="line">execution(* com.xyz.service..*.*(..)) </span><br><span class="line"></span><br><span class="line">在service包里的任意连接点（在Spring AOP中只是方法执行） ： </span><br><span class="line">within(com.xyz.service.*) </span><br><span class="line"></span><br><span class="line">在service包或者子包里的任意连接点（在Spring AOP中只是方法执行） ： </span><br><span class="line">within(com.xyz.service..*) </span><br><span class="line"></span><br><span class="line">实现了 AccountService 接口的代理对象的任意连接点（在Spring AOP中只是方法执行） ： </span><br><span class="line">this(com.xyz.service.AccountService) </span><br><span class="line"></span><br><span class="line">实现了 AccountService 接口的目标对象的任意连接点（在Spring AOP中只是方法执行） ： </span><br><span class="line">target(com.xyz.service.AccountService) </span><br><span class="line"></span><br><span class="line">任何一个只接受一个参数，且在运行时传入的参数实现了 Serializable 接口的连接点 （在Spring AOP中只是方法执行） </span><br><span class="line">args(java.io.Serializable) </span><br><span class="line"></span><br><span class="line">有一个 @Transactional 注解的目标对象中的任意连接点（在Spring AOP中只是方法执行） </span><br><span class="line">@target(org.springframework.transaction.annotation.Transactional) </span><br><span class="line"></span><br><span class="line">任何一个目标对象声明的类型有一个 @Transactional 注解的连接点（在Spring AOP中只是方法执行） </span><br><span class="line">@within(org.springframework.transaction.annotation.Transactional) </span><br><span class="line"></span><br><span class="line">任何一个执行的方法有一个 @Transactional annotation的连接点（在Spring AOP中只是方法执行） </span><br><span class="line">@annotation(org.springframework.transaction.annotation.Transactional) </span><br><span class="line"></span><br><span class="line">任何一个接受一个参数，并且传入的参数在运行时的类型实现了 @Classified annotation的连接点（在Spring AOP中只是方法执行） </span><br><span class="line">@args(com.xyz.security.Classified)</span><br></pre></td></tr></table></figure>

<h4 id="切入点指示符详解"><a href="#切入点指示符详解" class="headerlink" title="切入点指示符详解"></a>切入点指示符详解</h4><h5 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h5><p>execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?)<br>除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。<br>参数模式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">():匹配一个不接受任何参数的方法</span><br><span class="line">(..):匹配一个接受任意数量参数的方法</span><br><span class="line">(*):匹配了一个接受一个任何类型的参数的方法</span><br><span class="line">(*,String):匹配了一个接受两个参数的方法，其中第一个参数是任意类型，第二个参数必须是String类型</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">匹配所有目标类的public方法</span><br><span class="line">execution(public * *(..))</span><br><span class="line"></span><br><span class="line">匹配所有以To为后缀的方法</span><br><span class="line">execution(* *To(..))</span><br><span class="line"></span><br><span class="line">匹配Waiter接口中的所有方法</span><br><span class="line">execution(* com.aop.learn.service.Writer.*(..))</span><br><span class="line"></span><br><span class="line">匹配Waiter接口中及其实现类的方法</span><br><span class="line">execution(* com.aop.learn.service.Writer+.*(..))</span><br><span class="line"></span><br><span class="line">匹配 com.aop.learn.service 包下所有类的所有方法</span><br><span class="line">execution(* com.aop.learn.service.*(..))</span><br><span class="line"></span><br><span class="line">匹配 com.aop.learn.service 包,子孙包下所有类的所有方法</span><br><span class="line">execution(* com.aop.learn.service..*(..))</span><br><span class="line"></span><br><span class="line">匹配 包名前缀为com的任何包下类名后缀为ive的方法,方法必须以Smart为前缀</span><br><span class="line">execution(* com..*.*ive.Smart*(..))</span><br><span class="line"></span><br><span class="line">匹配 save(String name,int age) 函数</span><br><span class="line">execution(* save(String,int))</span><br><span class="line"></span><br><span class="line">匹配 save(String name,*) 函数 第二个参数为任意类型</span><br><span class="line">execution(* save(String,*))</span><br><span class="line"></span><br><span class="line">匹配 save(String name,..) 函数 除第一个参数固定外,接受后面有任意个入参且入参类型不限</span><br><span class="line">execution(* save(String,..))</span><br><span class="line"></span><br><span class="line">匹配 save(String+) 函数  String+ 表示入参类型是String的子类</span><br><span class="line">execution(* save(String+))</span><br></pre></td></tr></table></figure>

<h5 id="with"><a href="#with" class="headerlink" title="with"></a>with</h5><p>within是用来指定类型的，指定类型中的所有方法将被拦截。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表示匹配包aop_part以及子包的所有方法</span><br><span class="line">within(aop_part..*) </span><br><span class="line"></span><br><span class="line">匹配UserServiceImpl类对应对象的所有方法外部调用，而且这个对象只能是UserServiceImpl类型，不能是其子类型。</span><br><span class="line">within(com.elim.spring.aop.service.UserServiceImpl)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于execution可以匹配包、类、方法，而within只能匹配包、类，因此execution完全可以代替within的功能。</p>
</blockquote>
<h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>Spring Aop是基于代理的，this就表示代理对象。this类型的Pointcut表达式的语法是this(type)，当生成的代理对象可以转换为type指定的类型时则表示匹配。基于JDK接口的代理和基于CGLIB的代理生成的代理对象是不一样的。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表示匹配了当前给出具体代理对象,即实现了IGodInterface接口的具体代理对象的所有连接点()</span><br><span class="line">this(aop_part.service.IGodInterface)&#x2F;&#x2F;连接IGodInterface接口实现了的某一个具体对象</span><br></pre></td></tr></table></figure>

<h5 id="target"><a href="#target" class="headerlink" title="target"></a>target</h5><p>Spring Aop是基于代理的，target则表示被代理的目标对象。当被代理的目标对象可以被转换为指定的类型时则表示匹配。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表示匹配实现了IGodInterface接口的目标对象的所有连接点</span><br><span class="line">target(aop_part.service.IGodInterface)&#x2F;&#x2F;连接只要IGodInterface接口实现了的具体对象</span><br></pre></td></tr></table></figure>

<h5 id="args"><a href="#args" class="headerlink" title="args"></a>args</h5><p>args用来匹配方法参数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“args()”匹配任何不带参数的方法。</span><br><span class="line">“args(java.lang.String)”匹配任何只带一个参数，而且这个参数的类型是String的方法。</span><br><span class="line">“args(..)”带任意参数的方法。</span><br><span class="line">“args(java.lang.String,..)”匹配带任意个参数，但是第一个参数的类型是String的方法。</span><br><span class="line">“args(..,java.lang.String)”匹配带任意个参数，但是最后一个参数的类型是String的方法。</span><br></pre></td></tr></table></figure>

<h5 id="target-1"><a href="#target-1" class="headerlink" title="@target"></a>@target</h5><p>匹配当被代理的目标对象对应的类型及其父类型上拥有指定的注解时。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">匹配被代理的目标对象对应的类型上拥有MyAnnotation注解时</span><br><span class="line">@target(com.elim.spring.support.MyAnnotation)</span><br></pre></td></tr></table></figure>

<h5 id="args-1"><a href="#args-1" class="headerlink" title="@args"></a>@args</h5><p>匹配被调用的方法上含有参数，且对应的参数类型上拥有指定的注解的情况。<br>“@args(com.elim.spring.support.MyAnnotation)”匹配方法参数类型上拥有MyAnnotation注解的方法调用。如我们有一个方法add(MyParam param)接收一个MyParam类型的参数，而MyParam这个类是拥有注解MyAnnotation的，则它可以被Pointcut表达式“@args(com.elim.spring.support.MyAnnotation)”匹配上。</p>
<h5 id="within"><a href="#within" class="headerlink" title="@within"></a>@within</h5><p>用于匹配被代理的目标对象对应的类型或其父类型拥有指定的注解的情况，但只有在调用拥有指定注解的类上的方法时才匹配。</p>
<p>“@within(com.elim.spring.support.MyAnnotation)”匹配被调用的方法声明的类上拥有MyAnnotation注解的情况。比如有一个ClassA上使用了注解MyAnnotation标注，并且定义了一个方法a()，那么在调用ClassA.a()方法时将匹配该Pointcut；如果有一个ClassB上没有MyAnnotation注解，但是它继承自ClassA，同时它上面定义了一个方法b()，那么在调用ClassB().b()方法时不会匹配该Pointcut，但是在调用ClassB().a()时将匹配该方法调用，因为a()是定义在父类型ClassA上的，且ClassA上使用了MyAnnotation注解。但是如果子类ClassB覆写了父类ClassA的a()方法，则调用ClassB.a()方法时也不匹配该Pointcut。</p>
<h5 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h5><p>用于匹配方法上拥有指定注解的情况。<br>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">匹配所有的方法上拥有MyAnnotation注解的方法外部调用。</span><br><span class="line">@annotation(com.elim.spring.support.MyAnnotation)</span><br></pre></td></tr></table></figure>

<h5 id="bean"><a href="#bean" class="headerlink" title="@bean"></a>@bean</h5><p>用于匹配当调用的是指定的Spring的某个bean的方法时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“bean(abc)”匹配Spring Bean容器中id或name为abc的bean的方法调用。</span><br><span class="line">“bean(user*)”匹配所有id或name为以user开头的bean的方法调用。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FrameWork</category>
      </categories>
      <tags>
        <tag>AOP原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架1</title>
    <url>/2021/01/05/Framework-Spring%E6%A1%86%E6%9E%B61/</url>
    <content><![CDATA[<p>Spring 核心几大特点：控制反转(IOC),依赖注入(Dependency Injection),与切面编程(AsOP),Spring Framework还提供了AOP技术,事务管理服务(注入控制事务传播),消息服务；Spring支持使用集成Hibernate,JPA,Struts等框架；</p>
<h2 id="Spring-Framework-架构图"><a href="#Spring-Framework-架构图" class="headerlink" title="Spring Framework 架构图"></a>Spring Framework 架构图</h2><p><img src="/img/Spring_Framework3.x%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Spring_Framework3.x架构图" title="Spring_Framework3.x架构图"></p>
<h2 id="控制反转-IOC-Inversion-Of-Control"><a href="#控制反转-IOC-Inversion-Of-Control" class="headerlink" title="控制反转(IOC:Inversion Of Control)"></a>控制反转(IOC:Inversion Of Control)</h2><p>Spring启动的时,会主动初始化注册在bean的xml里面的bean,使得这些bean之间使用解耦;</p>
<h3 id="不使用Spring："><a href="#不使用Spring：" class="headerlink" title="不使用Spring："></a>不使用Spring：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PersonServiceBean&#123;</span><br><span class="line">  &#x2F;&#x2F;没有初始化PersonDao，需要在代码里强关联</span><br><span class="line">  private PersonDao personDao &#x3D; new PersonDao();</span><br><span class="line"></span><br><span class="line">  public void save(PersonDao personDao)&#123;</span><br><span class="line">    personDao.save();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Spring："><a href="#使用Spring：" class="headerlink" title="使用Spring："></a>使用Spring：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PersonServiceBean&#123;</span><br><span class="line">  &#x2F;&#x2F;在Spring启动的时候已经初始化PersonDao，存在Spring容器里类似写好的全局变量一样,有需要就去取</span><br><span class="line">  private PersonDao personDao;</span><br><span class="line"></span><br><span class="line">  public void save(PersonDao personDao)&#123;</span><br><span class="line">    personDao.save();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖注入-Dependency-Injection"><a href="#依赖注入-Dependency-Injection" class="headerlink" title="依赖注入(Dependency Injection)"></a>依赖注入(Dependency Injection)</h2><p>DI定义:运行期，由外部容器动态的将依赖对象注入到组件中(从xml的spring容器拿到bean 注入到代码里)<br>因此：将创建bean的过程交给spring创建的过程就是IOC,一个类在使用到相关bean对象的时候自动注入相关bean；</p>
<blockquote>
<p>注入过程就是如何赋值过程,如spring new好了的personDao对象A，在PersonServiceBean中需要将A赋值给personDao</p>
</blockquote>
<h2 id="切面编程-AOP-Aspect-Oriented-Programming"><a href="#切面编程-AOP-Aspect-Oriented-Programming" class="headerlink" title="切面编程(AOP:Aspect Oriented Programming)"></a>切面编程(AOP:Aspect Oriented Programming)</h2><p>面向切面编程可以使用权限拦截，运行监控，日志等</p>
<blockquote>
<p>切面编程就如一个全局函数一样</p>
</blockquote>
<hr>
<h2 id="Spring-XML文件配置使用"><a href="#Spring-XML文件配置使用" class="headerlink" title="Spring XML文件配置使用"></a>Spring XML文件配置使用</h2><h4 id="Spring配置模板"><a href="#Spring配置模板" class="headerlink" title="Spring配置模板"></a>Spring配置模板</h4><p><img src="/img/Spring%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF.png" alt="Spring配置模板" title="Spring配置模板"><br><img src="/img/Spring%E9%85%8D%E7%BD%AEBean%E4%B8%8D%E8%83%BD%E8%81%94%E6%83%B3.png" alt="Spring配置Bean不能联想" title="Spring配置Bean不能联想"></p>
<h4 id="代码实例化Spring容器常用的两种方式："><a href="#代码实例化Spring容器常用的两种方式：" class="headerlink" title="代码实例化Spring容器常用的两种方式："></a>代码实例化Spring容器常用的两种方式：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一:</span><br><span class="line">在类路径下寻找配置文件来实例化容器</span><br><span class="line"></span><br><span class="line">ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(new String[]&#123;&quot;beans.xml&quot;&#125;);</span><br><span class="line"></span><br><span class="line">方法二:</span><br><span class="line">在文件系统路径下寻找配置文件来实例化容器</span><br><span class="line">ApplicationContext ctx &#x3D; new FileSystemXmlApplicationContext(new String[]&#123;“d:\\beans.xml“&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Spring-实例化bean"><a href="#Spring-实例化bean" class="headerlink" title="Spring 实例化bean"></a>Spring 实例化bean</h2><h3 id="Spring-xml中配置三种实例化bean的方式："><a href="#Spring-xml中配置三种实例化bean的方式：" class="headerlink" title="Spring xml中配置三种实例化bean的方式："></a>Spring xml中配置三种实例化bean的方式：</h3><p>1.使用类构造器实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;“orderService&quot; class&#x3D;&quot;cn.itcast.OrderServiceBean&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>2.使用静态工厂方法实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;personService&quot; class&#x3D;&quot;cn.itcast.service.OrderFactory&quot; factory-method&#x3D;&quot;createOrder&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">public class OrderFactory &#123;</span><br><span class="line">    public static OrderServiceBean createOrder()&#123;</span><br><span class="line">      return new OrderServiceBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用实例工厂方法实例化:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;personServiceFactory&quot; class&#x3D;&quot;cn.itcast.service.OrderFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;personService&quot; factory-bean&#x3D;&quot;personServiceFactory&quot; factory-method&#x3D;&quot;createOrder&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">public class OrderFactory &#123;</span><br><span class="line">    public OrderServiceBean createOrder()&#123;</span><br><span class="line">      return new OrderServiceBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模仿Spring注册：代码手动解析xml-实例化xml的bean"><a href="#模仿Spring注册：代码手动解析xml-实例化xml的bean" class="headerlink" title="模仿Spring注册：代码手动解析xml,实例化xml的bean"></a>模仿Spring注册：代码手动解析xml,实例化xml的bean</h3><p><img src="/img/%E8%A7%A3%E6%9E%90xml%E6%B3%A8%E5%86%8Cbean.png" alt="解析xml注册bean" title="解析xml注册bean"></p>
<h2 id="配置bean的作用域-Scope"><a href="#配置bean的作用域-Scope" class="headerlink" title="配置bean的作用域(Scope)"></a>配置bean的作用域(Scope)</h2><blockquote>
<p>定义Bean可以使用的范围,类似定义变量时候,设置变量为局部变量还是全局变量,强调创建bean后的结果作用域</p>
</blockquote>
<h4 id="1-singleton-（单例）"><a href="#1-singleton-（单例）" class="headerlink" title="1.singleton （单例）"></a>1.singleton （单例）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;ServiceImpl&quot; class&#x3D;&quot;cn.csdn.service.ServiceImpl&quot; scope&#x3D;&quot;singleton&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>在每个Spring IoC容器中一个bean定义只有一个对象实例。默认情况下会在容器启动时初始化bean，但我们可以指定Bean节点的lazy-init=“true”来延迟初始化bean，这时候，只有第一次获取bean会才初始化bean。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;xxx&quot; class&#x3D;&quot;cn.itcast.OrderServiceBean&quot; lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>如果想对所有bean都应用延迟初始化，可以在根节点beans设置default-lazy-init=“true“，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans default-lazy-init&#x3D;&quot;true“ ...&gt;</span><br></pre></td></tr></table></figure>
<p>实际应用中不把这个属性设置为true.</p>
<h4 id="2-prototype-原型"><a href="#2-prototype-原型" class="headerlink" title="2.prototype (原型)"></a>2.prototype (原型)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;account&quot; class&#x3D;&quot;com.foo.DefaultAccount&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>每次从容器获取bean都是新的对象。每次调用getBean方法，都获取新的实例。<br>调用调用getBean方法时,bean才实例化(此时相当于new xxxBean())</p>
<h4 id="3-request-请求"><a href="#3-request-请求" class="headerlink" title="3.request(请求)"></a>3.request(请求)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;loginAction&quot; class&#x3D;cn.csdn.LoginAction&quot; scope&#x3D;&quot;request&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>一个HTTP请求会产生一个Bean对象，也就是说，每一个HTTP请求都有自己的Bean实例。只适用于web的Spring ApplicationContext中</p>
<h4 id="4-session-会话"><a href="#4-session-会话" class="headerlink" title="4.session(会话)"></a>4.session(会话)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userPreferences&quot; class&#x3D;&quot;com.foo.UserPreferences&quot; scope&#x3D;&quot;session&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>限定一个Bean的作用域为HTTPsession的生命周期。同样，只适用于web的Spring ApplicationContext中</p>
<h4 id="5-global-session-全局会话"><a href="#5-global-session-全局会话" class="headerlink" title="5.global session(全局会话)"></a>5.global session(全局会话)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.foo.Preferences &quot;scope&#x3D;&quot;globalSession&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>限定一个Bean的作用域为全局HTTPSession的生命周期。通常用于门户网站场景，同样，只适用于web的Spring ApplicationContext中</p>
<p>五种作用域中，request、session和global session三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<p>在配置文件中指定Bean的初始化方法和销毁方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;xxx&quot; class&#x3D;&quot;cn.itcast.OrderServiceBean&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;close&quot;&#x2F;&gt;</span><br><span class="line">Bean实例化后 ，就会执行init方法， Spring容器通过反射机制来调用。</span><br><span class="line">AbstractApplicationContext ctx&#x3D;new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">ctx.close();&#x2F;&#x2F;正常关闭spring容器。</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Bean生命周期"><a href="#Spring-Bean生命周期" class="headerlink" title="Spring Bean生命周期"></a>Spring Bean生命周期</h2><blockquote>
<p>创建Bean的过程,即实例化过程，强调创建过程<br><img src="/img/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Bean实例化过程" title="Bean实例化过程"></p>
</blockquote>
<h3 id="Bean实例生命周期的执行过程如下："><a href="#Bean实例生命周期的执行过程如下：" class="headerlink" title="Bean实例生命周期的执行过程如下："></a>Bean实例生命周期的执行过程如下：</h3><p>1.Spring对bean进行实例化，默认bean是单例；</p>
<p>2.Spring对bean进行依赖注入；</p>
<p>3.如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；</p>
<p>4.如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；</p>
<p>5.如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；</p>
<p>6.如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；</p>
<p>7.如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</p>
<p>8.如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；</p>
<p>9.此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>10.若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</p>
<p>其实很多时候我们并不会真的去实现上面说描述的那些接口，那么下面我们就除去那些接口，针对bean的单例和非单例来描述下bean的生命周期：</p>
<h4 id="单例管理的对象"><a href="#单例管理的对象" class="headerlink" title="单例管理的对象"></a>单例管理的对象</h4><p>默认情况下，Spring在读取xml文件的时候,就会创建对象.在创建对象的时候先调用构造器,然后调用init-method属性值中所指定的方法。对象在被销毁的时候,会调用destroy-method属性值中所指定的方法(例如调用Container.destroy()方法的时候)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;life_singleton&quot; class&#x3D;&quot;com.bean.LifeBean&quot; scope&#x3D;&quot;singleton&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destory&quot; lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">public class LifeBean &#123;</span><br><span class="line">    private String name;  </span><br><span class="line"></span><br><span class="line">    public LifeBean()&#123;  </span><br><span class="line">        System.out.println(&quot;LifeBean()构造函数&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public String getName() &#123;  </span><br><span class="line">        return name;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;  </span><br><span class="line">        System.out.println(&quot;setName()&quot;);  </span><br><span class="line">        this.name &#x3D; name;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void init()&#123;  </span><br><span class="line">        System.out.println(&quot;this is init of lifeBean&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void destory()&#123;  </span><br><span class="line">        System.out.println(&quot;this is destory of lifeBean &quot; + this);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">public class LifeTest &#123;</span><br><span class="line">    @Test </span><br><span class="line">    public void test() &#123;</span><br><span class="line">        AbstractApplicationContext container &#x3D; </span><br><span class="line">        new ClassPathXmlApplicationContext(&quot;life.xml&quot;);</span><br><span class="line">        LifeBean life1 &#x3D; (LifeBean)container.getBean(&quot;life&quot;);</span><br><span class="line">        System.out.println(life1);</span><br><span class="line">        container.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下</span><br><span class="line">LifeBean()构造函数</span><br><span class="line">this is init of lifeBean</span><br><span class="line">com.bean.LifeBean@573f2bb1</span><br><span class="line">……</span><br><span class="line">this is destory of lifeBean com.bean.LifeBean@573f2bb1</span><br></pre></td></tr></table></figure>

<h4 id="非单例管理的对象"><a href="#非单例管理的对象" class="headerlink" title="非单例管理的对象"></a>非单例管理的对象</h4><p>当scope=”prototype”时，容器也会延迟初始化bean，Spring读取xml文件的时候，并不会立刻创建对象，而是在第一次请求该bean时才初始化（如调用getBean方法时）。在第一次请求每一个prototype的bean时，Spring容器都会调用其构造器创建这个对象，然后调用init-method属性值中所指定的方法。对象销毁的时候，Spring容器不会帮我们调用任何方法，因为是非单例，这个类型的对象有很多个，Spring容器一旦把这个对象交给你之后，就不再管理这个对象了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;life_prototype&quot; class&#x3D;&quot;com.bean.LifeBean&quot; scope&#x3D;&quot;prototype&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destory&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">public class LifeTest &#123;</span><br><span class="line">    @Test </span><br><span class="line">    public void test() &#123;</span><br><span class="line">        AbstractApplicationContext container &#x3D; new ClassPathXmlApplicationContext(&quot;life.xml&quot;);</span><br><span class="line">        LifeBean life1 &#x3D; (LifeBean)container.getBean(&quot;life_singleton&quot;);</span><br><span class="line">        System.out.println(life1);</span><br><span class="line"></span><br><span class="line">        LifeBean life3 &#x3D; (LifeBean)container.getBean(&quot;life_prototype&quot;);</span><br><span class="line">        System.out.println(life3);</span><br><span class="line">        container.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line">LifeBean()构造函数</span><br><span class="line">this is init of lifeBean</span><br><span class="line">com.bean.LifeBean@573f2bb1</span><br><span class="line">LifeBean()构造函数</span><br><span class="line">this is init of lifeBean</span><br><span class="line">com.bean.LifeBean@5ae9a829</span><br><span class="line">……</span><br><span class="line">this is destory of lifeBean com.bean.LifeBean@573f2bb1</span><br></pre></td></tr></table></figure>

<p>可以发现，对于作用域为prototype的bean，其destroy方法并没有被调用。如果bean的scope设为prototype时，当容器关闭时，destroy方法不会被调用。对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由客户端来处理。</p>
<p>　　Spring容器可以管理singleton作用域下bean的生命周期，在此作用域下，Spring能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的bean，Spring只负责创建，当容器创建了bean的实例后，bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
]]></content>
      <categories>
        <category>FrameWork</category>
      </categories>
      <tags>
        <tag>Spring-容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架4</title>
    <url>/2018/03/03/Framework-Spring%E6%A1%86%E6%9E%B64/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>FrameWork</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax</title>
    <url>/2021/01/09/FroEnd-Ajax/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/5kkJLUADEZ0Yuu733jIWow" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系</a></p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookies &amp; Session &amp; Token &amp; JWT</title>
    <url>/2018/12/26/FroEnd-Cookies%20&amp;%20Session%20&amp;%20Token%20&amp;%20JWT/</url>
    <content><![CDATA[<h2 id="Cookies-amp-amp-Session"><a href="#Cookies-amp-amp-Session" class="headerlink" title="Cookies &amp;&amp; Session"></a>Cookies &amp;&amp; Session</h2><p>http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</p>
<p>但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.</p>
<h5 id="基于session认证所显露的问题"><a href="#基于session认证所显露的问题" class="headerlink" title="基于session认证所显露的问题"></a>基于session认证所显露的问题</h5><p>Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p>
<p>扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p>
<p>CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<h6 id="流程上是这样的："><a href="#流程上是这样的：" class="headerlink" title="流程上是这样的："></a>流程上是这样的：</h6><p>1.用户使用用户名密码来请求服务器<br>2.服务器进行验证用户的信息<br>3.服务器通过验证发送给用户一个token<br>4.客户端存储token，并在每次请求时附送上这个token值<br>5.服务端验证token值，并返回数据<br>6.这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享,跨域请求)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。</p>
<h2 id="JWT-Json-Web-Token"><a href="#JWT-Json-Web-Token" class="headerlink" title="JWT(Json Web Token)"></a>JWT(Json Web Token)</h2><p>该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<h2 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h2><h4 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h4><p>第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).</p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>jwt的头部承载两部分信息：</p>
<p>声明类型，这里是jwt<br>声明加密的算法 通常直接使用 HMAC SHA256<br>完整的头部就像下面这样的JSON：</p>
<p>{<br>  ‘typ’: ‘JWT’,<br>  ‘alg’: ‘HS256’<br>}<br>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.<br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p>
<h4 id="playload"><a href="#playload" class="headerlink" title="playload"></a>playload</h4><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<p>标准中注册的声明<br>公共的声明<br>私有的声明<br>标准中注册的声明 (建议但不强制使用) ：</p>
<p>iss: jwt签发者<br>sub: jwt所面向的用户<br>aud: 接收jwt的一方<br>exp: jwt的过期时间，这个过期时间必须要大于签发时间<br>nbf: 定义在什么时间之前，该jwt都是不可用的.<br>iat: jwt的签发时间<br>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。<br>公共的声明 ：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p>
<p>私有的声明 ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>定义一个payload:</p>
<p>{<br>  “sub”: “1234567890”,<br>  “name”: “John Doe”,<br>  “admin”: true<br>}</p>
<p>然后将其进行base64加密，得到Jwt的第二部分。<br>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</p>
<h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<h5 id="header-base64后的"><a href="#header-base64后的" class="headerlink" title="header (base64后的)"></a>header (base64后的)</h5><h5 id="payload-base64后的"><a href="#payload-base64后的" class="headerlink" title="payload (base64后的)"></a>payload (base64后的)</h5><h5 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h5><p>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var encodedString &#x3D; base64UrlEncode(header) + &#39;.&#39; + base64UrlEncode(payload);</span><br><span class="line">var signature &#x3D; HMACSHA256(encodedString, &#39;secret&#39;); </span><br><span class="line">&#x2F;&#x2F; TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br><span class="line">将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</span><br><span class="line">  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br><span class="line">注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</span><br></pre></td></tr></table></figure>

<h4 id="JWT认证原理"><a href="#JWT认证原理" class="headerlink" title="JWT认证原理"></a>JWT认证原理</h4><p>最后再解释一下application server如何认证用户发来的JWT是否合法，首先application server 和 authentication server必须要有个约定，例如双方同时知道加密用的secret（这里假设用的就是简单的对称加密算法），那么在applicaition 收到这个JWT是，就可以利用JWT前两段（别忘了JWT是个三段的拼成的字符串哦）数据作为输入，用同一套hash算法和同一个secret自己计算一个签名值，然后把计算出来的签名值和收到的JWT第三段比较，如果相同则认证通过，如果不相同，则认证不通过。就这么简单，当然，上面是假设了这个hash算法是对称加密算法,其实如果用非对称加密算法也是可以的，比方说我就用非对称的算法，那么对应的key就是一对，而非一个，那么一对公钥+私钥可以这样分配：私钥由authentication server保存，公钥由application server保存，application server验证的时候，用公钥解密收到的signature,这样就得到了header和payload的拼接值，用这个拼接值跟前两段比较，相同就验证通过。总之，方法略不同，但大方向完全一样。</p>
<h2 id="JWT应用考虑的问题"><a href="#JWT应用考虑的问题" class="headerlink" title="JWT应用考虑的问题"></a>JWT应用考虑的问题</h2><p>一个实战问题:jwt如何实现logout?</p>
<p>一种是设置expire time, 这种可以称为”被动logout”,即超过了一定时间自动失效,但是如果等不及,就是想主动logout怎么办呢?由于jwt的这种”无状态”的天然属性,理论上是没有办法直接主动logout的,但是有一个间接的方法,就是可以在服务器后台存一个”黑名单”,这个黑名单专门用来存尚未过期但又想主动标明失效的的token,然后登录状态检查的时候多做一步黑名单检查即可.</p>
<h4 id="提两个best-practice"><a href="#提两个best-practice" class="headerlink" title="提两个best practice:"></a>提两个best practice:</h4><p>1.发送JWT要用https，原因前面说了，JWT本身不保证数据安全<br>2.JWT的payload中设置expire时间，为什么要这样做其实跟cookie为什么要设置过期时间一样，都是为了安全。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Eslint规范</title>
    <url>/2019/11/02/FroEnd-Eslint%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="添加包"><a href="#添加包" class="headerlink" title="添加包"></a>添加包</h2><p>  npm install eslint –save-dev<br>  npm install eslint-config-airbnb –save-dev //Airbnb的标准（配置文件的extends里没用airbnb的话可以不装）<br>  npm install eslint-plugin-import –save-dev  //Airbnb标准必需。用来校验 import 的，比如不能加 .js 后缀<br>  npm install eslint-plugin-jsx-a11y –save-dev //Airbnb标准必需<br>  npm install eslint-plugin-react –save-dev  //支持 react 语法<br>  npm install babel-eslint –save-dev  //兼容ES处于实验性阶段的语法，如类属性用”=“赋值<br>  npm install eslint-loader –save-dev //在webpack中解析<br>  npm install eslint-plugin-babel //兼容处于实验阶段的特征<br>  npm install eslint-plugin-vue</p>
<h2 id="创建修改-eslintrc文件"><a href="#创建修改-eslintrc文件" class="headerlink" title="创建修改.eslintrc文件"></a>创建修改.eslintrc文件</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>eslint –init 命令自动生成，也可以自己新建。<br>.eslintrc.js - 使用 .eslintrc.js 然后输出一个配置对象<br>.eslintrc（已弃用） </p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>添加规则；rules中的值0、1、2分别表示不开启检查、警告、错误</p>
<h4 id="plugin属性"><a href="#plugin属性" class="headerlink" title="plugin属性"></a>plugin属性</h4><p>ESLint 支持使用第三方插件（以eslint-plugin-开头的npm包），在使用插件之前，必须使用 npm 安装。如eslint-plugin-react、eslint-plugin-vue等</p>
<h4 id="extends属性"><a href="#extends属性" class="headerlink" title="extends属性"></a>extends属性</h4><p>一个配置文件可以被基础配置中的已启用的规则继承。可以使用以下规则继承：</p>
<ol>
<li><p>“extends”: “eslint:recommended”,</p>
</li>
<li><p>“extends”: “standard”,   //使用别人写好的规则包（以eslint-config-开头的npm包），如eslint-config-standard</p>
</li>
<li><p>“extends”: “eslint:all”  //使用”eslint:all”，继承Eslint中所有的核心规则项</p>
</li>
<li><p>“extends”: “airbnb”,    //使用Eslint插件中命名的配置:airbnb标准公认最好</p>
<ol>
<li>设置多个标准</li>
</ol>
<p>plugins: [<br> ‘react’<br>],<br>extends: [<br> ‘eslint:recommended’,<br> ‘plugin:react/recommended’<br>],</p>
</li>
</ol>
<h4 id="rules属性-根据自己的需要进行配置"><a href="#rules属性-根据自己的需要进行配置" class="headerlink" title="rules属性(根据自己的需要进行配置)"></a>rules属性(根据自己的需要进行配置)</h4><h5 id="Eslint部分核心规则"><a href="#Eslint部分核心规则" class="headerlink" title="Eslint部分核心规则"></a>Eslint部分核心规则</h5><p>  “rules”: {<br>      //这些规则与 JavaScript 代码中可能的错误或逻辑错误有关<br>      “for-direction”:2,//强制 “for” 循环中更新子句的计数器朝着正确的方向移动<br>      “getter-return”:2,//强制在 getter 属性中出现一个 return 语句<br>      “no-await-in-loop”:2,//禁止在循环中 出现 await<br>      “no-compare-neg-zer”:2,//禁止与 -0 进行比较<br>      “no-cond-assign”:[ 2, “always”],//禁止在条件语句中出现赋值操作符<br>      “no-console”:2,<br>      “no-constant-condition”:2,//禁止在条件中使用常量表达式<br>      “no-control-regex”:2,//禁止在正则表达式中使用控制字符<br>      “no-debugger”:2,//禁用 debugger<br>      “no-dupe-args”:2,//禁止在 function 定义中出现重复的参数<br>      “no-dupe-keys”:2,//禁止在对象字面量中出现重复的键<br>      “no-duplicate-case”:2,//禁止重复 case 标签<br>      “no-empty”:2,//禁止空块语句<br>      “no-empty-character-class”:2,//禁止在正则表达式中出现空字符集<br>      “no-ex-assign”:2,//禁止对 catch 子句中的异常重新赋值<br>      “no-extra-boolean-cast”:2,//禁止不必要的布尔类型转换<br>      “no-extra-parens”:2,//禁止冗余的括号<br>      “no-extra-semi”:2,//禁用不必要的分号<br>      “no-func-assign”:2,//禁止对 function 声明重新赋值<br>      “no-inner-declarations”:2,//禁止在嵌套的语句块中出现变量或 function 声明<br>      “no-invalid-regexp”:2,//禁止在 RegExp 构造函数中出现无效的正则表达式<br>      “no-irregular-whitespace”:2,//禁止不规则的空白<br>      “no-obj-calls”:2,//禁止将全局对象当作函数进行调用<br>      “no-prototype-builtins”:2,//禁止直接使用 Object.prototypes 的内置属性<br>      “no-regex-spaces”:2,//禁止正则表达式字面量中出现多个空格<br>      “no-sparse-arrays”: 2,//禁用稀疏数组<br>      “no-template-curly-in-string”:2,//禁止在常规字符串中出现模板字面量占位符语法<br>      “no-unexpected-multiline”:2,//禁止使用令人困惑的多行表达式<br>      “no-unreachable”:2,//禁止在 return、throw、continue 和 break 语句后出现不可达代码<br>      “no-unsafe-finally”:2,//禁止在 finally 语句块中出现控制流语句<br>      “no-unsafe-negation”:2,//禁止对关系运算符的左操作数使用否定操作符<br>      “use-isnan”:2,//要求调用 isNaN()检查 NaN<br>      “valid-jsdoc”:2,//强制使用有效的 JSDoc 注释<br>      “valid-typeof”:2,//强制 typeof 表达式与有效的字符串进行比较<br>      “accessor-pairs”:2,//强制getter/setter成对出现在对象中<br>      “array-callback-return”:2,//强制数组方法的回调函数中有 return 语句<br>      “block-scoped-var”:2,//把 var 语句看作是在块级作用域范围之内<br>      “class-methods-use-this”:2,//强制类方法使用 this<br>      “complexity”:2//限制圈复杂度<br>    }  </p>
<h5 id="eslint-plugin-vue中的规则"><a href="#eslint-plugin-vue中的规则" class="headerlink" title="eslint-plugin-vue中的规则"></a>eslint-plugin-vue中的规则</h5><pre><code>rules: {
  /* for vue */
  // 禁止重复的二级键名
  // @off 没必要限制
  &apos;vue/no-dupe-keys&apos;: &apos;off&apos;,
  // 禁止出现语法错误
  &apos;vue/no-parsing-error&apos;: &apos;error&apos;,
  // 禁止覆盖保留字
  &apos;vue/no-reservered-keys&apos;: &apos;error&apos;,
  // 组件的 data 属性的值必须是一个函数
  // @off 没必要限制
  &apos;vue/no-shared-component-data&apos;: &apos;off&apos;,
  // 禁止 &lt;template&gt; 使用 key 属性
  // @off 太严格了
  &apos;vue/no-template-key&apos;: &apos;off&apos;,
  // render 函数必须有返回值
  &apos;vue/require-render-return&apos;: &apos;error&apos;,
  // prop 的默认值必须匹配它的类型
  // @off 太严格了
  &apos;vue/require-valid-default-prop&apos;: &apos;off&apos;,
  // 计算属性必须有返回值
  &apos;vue/return-in-computed-property&apos;: &apos;error&apos;,
  // template 的根节点必须合法
  &apos;vue/valid-template-root&apos;: &apos;error&apos;,
  // v-bind 指令必须合法
  &apos;vue/valid-v-bind&apos;: &apos;error&apos;,
  // v-cloak 指令必须合法
  &apos;vue/valid-v-cloak&apos;: &apos;error&apos;,
  // v-else-if 指令必须合法
  &apos;vue/valid-v-else-if&apos;: &apos;error&apos;,
  // v-else 指令必须合法
  &apos;vue/valid-v-else&apos;: &apos;error&apos;,
  // v-for 指令必须合法
  &apos;vue/valid-v-for&apos;: &apos;error&apos;,
  // v-html 指令必须合法
  &apos;vue/valid-v-html&apos;: &apos;error&apos;,
  // v-if 指令必须合法
  &apos;vue/valid-v-if&apos;: &apos;error&apos;,
  // v-model 指令必须合法
  &apos;vue/valid-v-model&apos;: &apos;error&apos;,
  // v-on 指令必须合法
  &apos;vue/valid-v-on&apos;: &apos;error&apos;,
  // v-once 指令必须合法
  &apos;vue/valid-v-once&apos;: &apos;error&apos;,
  // v-pre 指令必须合法
  &apos;vue/valid-v-pre&apos;: &apos;error&apos;,
  // v-show 指令必须合法
  &apos;vue/valid-v-show&apos;: &apos;error&apos;,
  // v-text 指令必须合法
  &apos;vue/valid-v-text&apos;: &apos;error&apos;,
  // @fixable html 的结束标签必须符合规定
  // @off 有的标签不必严格符合规定，如 &lt;br&gt; 或 &lt;br/&gt; 都应该是合法的
  &apos;vue/html-end-tags&apos;: &apos;off&apos;,
  // 计算属性禁止包含异步方法
  &apos;vue/no-async-in-computed-properties&apos;: &apos;error&apos;,
  // 禁止出现难以理解的 v-if 和 v-for
  &apos;vue/no-confusing-v-for-v-if&apos;: &apos;error&apos;,
  // 禁止出现重复的属性
  &apos;vue/no-duplicate-attributes&apos;: &apos;error&apos;,
  // 禁止在计算属性中对属性修改
  // @off 太严格了
  &apos;vue/no-side-effects-in-computed-properties&apos;: &apos;off&apos;,
  // 禁止在 &lt;textarea&gt; 中出现 {{message}}
  &apos;vue/no-textarea-mustache&apos;: &apos;error&apos;,
  // 组件的属性必须为一定的顺序
  &apos;vue/order-in-components&apos;: &apos;error&apos;,
  // &lt;component&gt; 必须有 v-bind:is
  &apos;vue/require-component-is&apos;: &apos;error&apos;,
  // prop 必须有类型限制
  // @off 没必要限制
  &apos;vue/require-prop-types&apos;: &apos;off&apos;,
  // v-for 指令的元素必须有 v-bind:key
  &apos;vue/require-v-for-key&apos;: &apos;error&apos;,
  // @fixable 限制自定义组件的属性风格
  // @off 没必要限制
  &apos;vue/attribute-hyphenation&apos;: &apos;off&apos;,
  // html 属性值必须用双引号括起来
  &apos;vue/html-quotes&apos;: &apos;error&apos;,
  // @fixable 没有内容时，组件必须自闭和
  // @off 没必要限制
  &apos;vue/html-self-closing&apos;: &apos;off&apos;,
  // 限制每行允许的最多属性数量
  // @off 没必要限制
  &apos;vue/max-attributes-per-line&apos;: &apos;off&apos;,
  // @fixable 限制组件的 name 属性的值的风格
  // @off 没必要限制
  &apos;vue/name-property-casing&apos;: &apos;off&apos;,
  // @fixable 禁止出现连续空格
  // TODO: 李德广  触发 新版本 typeerror：get &apos;range&apos; of undefined
  // &apos;vue/no-multi-spaces&apos;: &apos;error&apos;,
  // @fixable 限制 v-bind 的风格
  // @off 没必要限制
  &apos;vue/v-bind-style&apos;: &apos;off&apos;,
  // @fixable 限制 v-on 的风格
  // @off 没必要限制
  &apos;vue/v-on-style&apos;: &apos;off&apos;,
  // 定义了的 jsx element 必须使用
  &apos;vue/jsx-uses-vars&apos;: &apos;error&apos;,</code></pre><p>  },</p>
<h5 id="eslint-plugin-react中的规则"><a href="#eslint-plugin-react中的规则" class="headerlink" title="eslint-plugin-react中的规则"></a>eslint-plugin-react中的规则</h5><pre><code>&apos;react/boolean-prop-naming&apos;: [2, { rule: &apos;^is[A-Z]([A-Za-z0-9]?)+&apos; }], // bool类型的props强制固定命名
&apos;react/button-has-type&apos;: [2, { reset: false }], // 强制按钮的type属性必须是&quot;button&quot;,&quot;submit&quot;,&quot;reset&quot;三者之一
&apos;react/default-props-match-prop-types&apos;: [2, { allowRequiredDefaults: false }], // 强制所有defaultProps有对应的non-required PropType
&apos;react/destructuring-assignment&apos;: [1, &apos;always&apos;], // 强制将props,state,context解构赋值
&apos;react/forbid-component-props&apos;: [1], // 禁止在自定义组件中使用(className, style)属性
&apos;react/forbid-dom-props&apos;: [1, { forbid: [&apos;style&apos;] }], // 禁止在dom元素上使用禁止的属性
&apos;react/forbid-elements&apos;: [1, { forbid: [&apos;button&apos;] }], // 禁止某些元素用于其他元素
&apos;react/no-access-state-in-setstate&apos;: 2, // 禁止在setState中使用this.state
&apos;react/no-children-prop&apos;: [1], // 不要把Children当做属性
&apos;react/no-string-refs&apos;: [1], // 不要使用string类型的ref
&apos;react/no-unused-state&apos;: [1], // 不要在state中定义未使用的变量
&apos;react/display-name&apos;: [1, { ignoreTranspilerName: false }], // react组件中强制定义displayName
&apos;react/jsx-no-undef&apos;: [1, { allowGlobals: false }], // 不允许使用未声明的变量
&apos;react/forbid-prop-types&apos;: [1], // 禁止某些propTypes属性类型
&apos;react/jsx-key&apos;: [1], // 遍历使用key</code></pre><h2 id="配置-eslintignore"><a href="#配置-eslintignore" class="headerlink" title="配置.eslintignore"></a>配置.eslintignore</h2><p>  build/<em>.js<br>  config/</em>.js</p>
<h2 id="禁用-启用-eslint"><a href="#禁用-启用-eslint" class="headerlink" title="禁用/启用 eslint"></a>禁用/启用 eslint</h2><p>  /* eslint-disable <em>/<br>  /</em> eslint-enable */</p>
<h2 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h2><p>用 webpack-dev-server 起的服务会用 eslint 对代码进行检验，并把检验结果输出在控制台。<br>如果只要每个人 VSCode 对代码进行检验就不用配置了</p>
<pre><code>{
    test: /.(js|jsx|mjs)$/,
    enforce: &apos;pre&apos;,
    use: [
    {
      options: {
      formatter: eslintFormatter,
      eslintPath: require.resolve(&apos;eslint&apos;),

      },
      loader: require.resolve(&apos;eslint-loader&apos;),
    },
    ],
    include: paths.appSrc, //也可以用exclude排除不需要检查的目录或者用.eslintignore
}</code></pre><p>一般使用的配置</p>
<pre><code>module.exports = {
  parser: &apos;babel-eslint&apos;,
  plugins: [&apos;react&apos;],
  extends: &apos;airbnb&apos;,
  settings: {
    &apos;import/ignore&apos;: [&apos;node_modules&apos;],
  },
  parserOptions: {
    ecmaFeatures: {
      experimentalObjectRestSpread: true,
    },
  },
  rules: {
    quotes: [2, &apos;single&apos;], // 单引号
    semi: 2, // 不强制使用分号
    camelcase: 2, // 强制驼峰法命名
    &apos;no-console&apos;: 0, // 不禁用console
    &apos;no-debugger&apos;: 2, // 禁用debugger
    &apos;no-var&apos;: 0, // 对var警告
    &apos;no-irregular-whitespace&apos;: 0, // 不规则的空白不允许
    &apos;no-trailing-spaces&apos;: 1, // 一行结束后面有空格就发出警告
    &apos;eol-last&apos;: 0, // 文件以单一的换行符结束
    &apos;no-unused-vars&apos;: [2, { vars: &apos;all&apos;, args: &apos;after-used&apos; }], // 不能有声明后未被使用的变量或参数
    &apos;no-underscore-dangle&apos;: 0, // 标识符不能以_开头或结尾
    &apos;no-alert&apos;: 2, // 禁止使用alert confirm prompt
    &apos;no-lone-blocks&apos;: 0, // 禁止不必要的嵌套块
    &apos;no-class-assign&apos;: 2, // 禁止给类赋值
    &apos;no-cond-assign&apos;: 2, // 禁止在条件表达式中使用赋值语句
    &apos;no-const-assign&apos;: 2, // 禁止修改const声明的变量
    &apos;no-delete-var&apos;: 2, // 不能对var声明的变量使用delete操作符
    &apos;no-dupe-keys&apos;: 2, // 在创建对象字面量时不允许键重复
    &apos;no-duplicate-case&apos;: 2, // switch中的case标签不能重复
    &apos;no-dupe-args&apos;: 2, // 函数参数不能重复
    &apos;no-empty&apos;: 2, // 块语句中的内容不能为空
    &apos;no-func-assign&apos;: 2, // 禁止重复的函数声明
    &apos;no-invalid-this&apos;: 0, // 禁止无效的this，只能用在构造器，类，对象字面量
    &apos;no-redeclare&apos;: 2, // 禁止重复声明变量
    &apos;no-spaced-func&apos;: 2, // 函数调用时 函数名与()之间不能有空格
    &apos;no-this-before-super&apos;: 0, // 在调用super()之前不能使用this或super
    &apos;no-undef&apos;: 2, // 不能有未定义的变量
    &apos;no-use-before-define&apos;: 2, // 未定义前不能使用
    &apos;jsx-quotes&apos;: [2, &apos;prefer-double&apos;], // 强制在JSX属性（jsx-quotes）中一致使用双引号
    &apos;react/display-name&apos;: 0, // 防止在React组件定义中丢失displayName
    &apos;react/forbid-prop-types&apos;: [2, { forbid: [&apos;any&apos;] }], // 禁止某些propTypes
    &apos;react/jsx-boolean-value&apos;: 2, // 在JSX中强制布尔属性符号
    &apos;react/jsx-closing-bracket-location&apos;: 1, // 在JSX中验证右括号位置
    &apos;react/jsx-curly-spacing&apos;: [2, { when: &apos;never&apos;, children: true }], // 在JSX属性和表达式中加强或禁止大括号内的空格。
    &apos;react/jsx-indent-props&apos;: [2, 4], // 验证JSX中的props缩进
    &apos;react/jsx-key&apos;: 2, // 在数组或迭代器中验证JSX具有key属性
    &apos;react/jsx-max-props-per-line&apos;: [1, { maximum: 1 }], // 限制JSX中单行上的props的最大数量
    &apos;react/jsx-no-bind&apos;: 0, // JSX中不允许使用箭头函数和bind
    &apos;react/jsx-no-duplicate-props&apos;: 2, // 防止在JSX中重复的props
    &apos;react/jsx-no-literals&apos;: 0, // 防止使用未包装的JSX字符串
    &apos;react/jsx-no-undef&apos;: 1, // 在JSX中禁止未声明的变量
    &apos;react/jsx-pascal-case&apos;: 0, // 为用户定义的JSX组件强制使用PascalCase
    &apos;react/jsx-sort-props&apos;: 2, // 强化props按字母排序
    &apos;react/jsx-uses-react&apos;: 1, // 防止反应被错误地标记为未使用
    &apos;react/jsx-uses-vars&apos;: 2, // 防止在JSX中使用的变量被错误地标记为未使用
    &apos;react/no-danger&apos;: 0, // 防止使用危险的JSX属性
    &apos;react/no-did-mount-set-state&apos;: 0, // 防止在componentDidMount中使用setState
    &apos;react/no-did-update-set-state&apos;: 1, // 防止在componentDidUpdate中使用setState
    &apos;react/no-direct-mutation-state&apos;: 2, // 防止this.state的直接变异
    &apos;react/no-multi-comp&apos;: 2, // 防止每个文件有多个组件定义
    &apos;react/no-set-state&apos;: 0, // 防止使用setState
    &apos;react/no-unknown-property&apos;: 2, // 防止使用未知的DOM属性
    &apos;react/prefer-es6-class&apos;: 2, // 为React组件强制执行ES5或ES6类
    &apos;react/prop-types&apos;: 0, // 防止在React组件定义中丢失props验证
    &apos;react/react-in-jsx-scope&apos;: 2, // 使用JSX时防止丢失React
    &apos;react/self-closing-comp&apos;: 0, // 防止没有children的组件的额外结束标签
    &apos;react/sort-comp&apos;: 2, // 强制组件方法顺序
    &apos;no-extra-boolean-cast&apos;: 0, // 禁止不必要的bool转换
    &apos;react/no-array-index-key&apos;: 0, // 防止在数组中遍历中使用数组key做索引
    &apos;react/no-deprecated&apos;: 1, // 不使用弃用的方法
    &apos;react/jsx-equals-spacing&apos;: 2, // 在JSX属性中强制或禁止等号周围的空格
    &apos;no-unreachable&apos;: 1, // 不能有无法执行的代码
    &apos;comma-dangle&apos;: 2, // 对象字面量项尾不能有逗号
    &apos;no-mixed-spaces-and-tabs&apos;: 0, // 禁止混用tab和空格
    &apos;prefer-arrow-callback&apos;: 0, // 比较喜欢箭头回调
    &apos;arrow-parens&apos;: 0, // 箭头函数用小括号括起来
    &apos;arrow-spacing&apos;: 0, //= &gt;的前/后括号
  },
};</code></pre>]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>VSsetting</tag>
        <tag>Eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>Framework Path</title>
    <url>/2019/04/22/FroEnd-Framework-Path/</url>
    <content><![CDATA[<h2 id="前端学习体系-1"><a href="#前端学习体系-1" class="headerlink" title="前端学习体系 1"></a>前端学习体系 1</h2><p><a href="/file/FrontEnd-KnowledgePath.pdf">小码哥前端学习架构路线</a><br><a href="http://xiaomage.ke.qq.com/#category=15733794887010602&tab=1" target="_blank" rel="noopener">小码哥前端学习体系</a></p>
<h2 id="前端学习体系-2"><a href="#前端学习体系-2" class="headerlink" title="前端学习体系 2"></a><a href="http://www.wolfcode.cn/article/index/id/1592" target="_blank" rel="noopener">前端学习体系 2</a></h2><h3 id="第一阶段-HTML5-CSS3"><a href="#第一阶段-HTML5-CSS3" class="headerlink" title="第一阶段(HTML5+CSS3)"></a>第一阶段(HTML5+CSS3)</h3><p>主讲内容：<br>前端开发软件、HTML5、CSS2、CSS3、框架实战项目、前端必备的 UI 技能</p>
<p>知识要点：<br>1、前端开发软件：Webstorm 安装与使用。<br>2、HTML5：HTML5 语法与发展史、HTML 标签与 H5 新标签、HTML5 语义化、表单与表格。<br>3、CSS2：CSS2 基本语法、选择器讲解、内嵌式、行内式、外链式、文本样式控制、px、em、rem、vw/vh 和百分比。<br>4、CSS3：Chrome-debug、投影/圆角/阴影、CSS3 2D,CSS3 3D 变换、 CSS3 动画特效、H5+C3 炫酷页面开发、Flex 伸缩布局、圣杯布局、双飞翼布局、瀑布流，流式布局、sprite 技术、 移动端主流适配方案、常见移动端样式兼容方案。<br>5、框架实战项目：favicon 与 iconfont、企业站开发、移动端 M 站开发、响应式网站开发、部署项目到线上、预处理语言、Bootstrap 框架、SEO 搜索引擎优化、lazyload 懒加载。<br>6、前端必备的 UI 技能：用户界面设计原理、思维导图（脑图）、PS 切图与快捷键、前端与设计的协同开发平台、原型图、Axure RP 与 firefox。</p>
<p>学习目标：<br>1、打造学员编程思维；<br>2、快速入门 HTML5 与 CSS3 两门语言，并掌握网站动态特效的制作方法；<br>3、帮助学员掌握页面布局方法；<br>4、帮助学员掌握 PC 端企业站开发、移动端 M 站开发；<br>5、项目线上部署，让学员了解真正的前端开发流程；<br>6、掌握 css 预处理语言，提升 css 书写速度；<br>7、掌握 BS 框架，帮助学员掌握快速构建项目的技巧；<br>8、掌握 lazyload 方法；</p>
<h3 id="第二阶段-第二阶段"><a href="#第二阶段-第二阶段" class="headerlink" title="第二阶段(第二阶段)"></a>第二阶段(第二阶段)</h3><p>主讲内容：<br>JS 语法基础、JS-WebApi</p>
<p>知识要点：<br>1、JS 语法基础：打印与弹框、变量、基本数据类型与复杂数据类型、数据类型转换、内置对象、JSON 技术、预加载。<br>2、JS-WebApi：ECMAScript、DOM、BOM、JS 兼容性测试、动画函数封装、轮播图、购物预览、tab 切换栏等特效。</p>
<p>学习目标：<br>1、带领学生入门 JS 语言，打下坚实基础；<br>2、使用原生 JS 实现网站特效。</p>
<h2 id="第三阶段-JQuery-与动效框架"><a href="#第三阶段-JQuery-与动效框架" class="headerlink" title="第三阶段(JQuery 与动效框架)"></a>第三阶段(JQuery 与动效框架)</h2><p>主讲内容：<br>JQuery 语法、zepto 与 weui 框架、动效框架、动效轮播</p>
<p>知识要点：<br>1、JQuery 语法：讲解 JQuery 语法及优势、对比原生 JS 开发、JQuery 操作 DOM、快速制作动画效果、链式编程。<br>2、zepto 与 weui 框架：zepto 入门、插件引用、源码阅读与修改、weui 框架、微信公众号页面开发、fastclick。<br>3、动效框架：AnimateCss 框架、wowJs 框架、scrollRevealJs 框架。<br>4、动效轮播：swiper 框架、MouseWheel 插件、滚滚屏实现。</p>
<p>学习目标：<br>1、在学员掌握原生 JS 开发后，迅速上手 JQuery 框架，实现对“面向过程”开发的理解；<br>2、使用 zepto 和 weui 开发微信公众号网页；<br>3、解决书写移动端页面出现的 bug；<br>4、借用三大动效框架，完成页面动态效果；<br>5、使用 swiper 框架快速制作动效轮播图；<br>6、使用 mousewheel 插件实现滚滚屏。</p>
<h3 id="第四阶段-JavaScript-高级"><a href="#第四阶段-JavaScript-高级" class="headerlink" title="第四阶段(JavaScript 高级)"></a>第四阶段(JavaScript 高级)</h3><p>主讲内容：<br>ES6/ES7、JS 面向对象</p>
<p>知识要点：<br>1、ES6/ES7：新增语法、Promise、Async-await、解构、内置对象扩展。<br>2、JavaScript 面向对象思想、对象的创建、闭包、详解原型与原型链、ES6 面向对象、详解 this、作用域、Class、constructor 与 super 等。</p>
<p>学习目标：<br>1、掌握 JavaScript 最新语法，区别于 ES5，并将 ES6/7 与 ES5 对比进行教学;<br>2、熟练掌握 ES5/6 的面向对象思想及用法，能将面向过程的开发思维逐渐转变为面向对象。</p>
<h3 id="第五阶段-NodeJS"><a href="#第五阶段-NodeJS" class="headerlink" title="第五阶段(NodeJS)"></a>第五阶段(NodeJS)</h3><p>主讲内容：<br>AJAX、NodeJs、Express、会话存储、数据库、综合案例、Linux、Nginx、MySQL</p>
<p>知识要点：<br>1、AJAX：http 请求、原生 AJAX、异步与同步、AJAX 封装、基于 JQuery 的 AJAX、跨域、Formdata、axios。<br>2、NodeJs：环境安装、包管理器、模块使用。<br>3、Express：express 安装与入门、路由、静态资源管理、中间件、模板引擎、API 介绍、RESTful。<br>4、会话存储：cookie 与 storage、cookie 封装、加密、Base64 与 https。<br>5、数据库：同源策略、MongoDB 的安装与 CRUD、可视化工具、Mongoose。<br>6、综合案例：结合 Ajax、NodeJs 与 MongoDB 完成案例。<br>7、Linux：Linux 概念与安装、Linux 使用方法 。<br>8、Nginx：Nginx 安装配置、Nginx 命令行操作、使用 Nginx 进行反向代理。<br>9、了解关系型数据库含义、图形化界面使用及工具安装、常见增删改查处理。</p>
<p>学习目标：<br>1、让学员了解数据请求的原理及方法；<br>2、解决跨域问题；<br>3、深入学习 NodeJs 相关技术点；<br>4、掌握 express 框架、会话存储与 MongoDB 数据库操作，并通过完整项目实战来加强；<br>5、帮助学员了解 Linux 操作系统；<br>6、帮助学员了解 Nginx 常用操作；<br>7、掌握 MySQL 数据库的用法；</p>
<h3 id="第六阶段-移动端商城项目"><a href="#第六阶段-移动端商城项目" class="headerlink" title="第六阶段(移动端商城项目)"></a>第六阶段(移动端商城项目)</h3><p>主讲内容：<br>Git/github/gulp、移动 Web 实战项目</p>
<p>知识要点：<br>1、Git/github/gulp：深入讲解 git 的使用、深入讲解 gulp 的使用。<br>2、移动 Web 实战项目：原生 JS 构建移动端项目。</p>
<p>学习目标：<br>掌握 git 与 gulp 的使用，并使用原生 JS 构建移动端项目。</p>
<h3 id="第七阶段-VueJs"><a href="#第七阶段-VueJs" class="headerlink" title="第七阶段(VueJs)"></a>第七阶段(VueJs)</h3><p>主讲内容：<br>VueJS 入门、vue 全家桶、vue 进阶、vue 项目实战、可视化大数据</p>
<p>知识要点：<br>1、VueJS 入门：MVVM 模式详解、vue 双向数据绑定、生命周期、methods、computed 与 watch、v-if、v-for、自定义指令、组件、父子、兄弟组件通信、vueDevTools。<br>2、vue 全家桶：项目构建工具 vue-cli、路由 vue-router、数据请求 axios、状态管理 vuex。<br>3、vue 进阶：request 封装。<br>4、vue 项目实战：nextTick、发布订阅模式、双向数据绑定原理与实现、移动端商城项目、后台管理系统项目。<br>5、可视化大数据：Echarts 图标、canvas 绘图。</p>
<p>学习目标：<br>1、掌握 vue 的基本语法；<br>2、掌握目前市面上最火的 vue 全家桶开发；<br>3、深入了解 vue 使用技能与底层原理；<br>4、使用 vue 全家桶完成移动端与 PC 端项目开发，PC 端项目搭配 Gitee；<br>5、可视化图表操作与绘图。</p>
<h3 id="第八阶段-微信小程序"><a href="#第八阶段-微信小程序" class="headerlink" title="第八阶段(微信小程序)"></a>第八阶段(微信小程序)</h3><p>主讲内容：<br>小程序入门、小程序进阶</p>
<p>知识要点：<br>1、小程序入门：组件使用、事件处理、WXS。<br>2、小程序进阶：自定义对话框、构建 npm、网络请求、文件操作、数据缓存、登录与跳转、API 兼容、小米商城项目。</p>
<p>学习目标：<br>1、掌握 vue 的基本语法；<br>2、调用 API，并最终完成商城项目。</p>
<h3 id="第九阶段-React"><a href="#第九阶段-React" class="headerlink" title="第九阶段(React)"></a>第九阶段(React)</h3><p>主讲内容：<br>React.js 入门、项目实战</p>
<p>主讲内容：<br>1、React.js 入门：webpack 复习、前端三大主流框架对比、React 核心概念虚拟 DOM,DIFF 算法、创建虚拟 DOM JSX 语法、React 组件，组件通信，组件拆分、Class 组件、组件样式管理 CSS 模块化、生命周期、React 双向数据绑定、React 路由。<br>2、项目实战：WolfMovie 综合项目。</p>
<p>学习目标：<br>1、掌握 react 的基本语法；<br>2、完成 MolfMovie 项目。</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Path</tag>
        <tag>FroEnd-Path</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML&amp;&amp;CSS</title>
    <url>/2019/05/08/FroEnd-HTML&amp;&amp;CSS/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6基础</title>
    <url>/2019/06/17/FroEnd-ES6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="let-amp-amp-const-关键字"><a href="#let-amp-amp-const-关键字" class="headerlink" title="let &amp;&amp; const 关键字"></a>let &amp;&amp; const 关键字</h2><p>const 定义变量必须赋初始值，let 不需要赋初始值</p>
<h3 id="let-关键字作用"><a href="#let-关键字作用" class="headerlink" title="let 关键字作用"></a>let 关键字作用</h3><pre><code>1.let声明变量，没有变量提升
2.是一个块作用域
3.不能重复声明</code></pre><h3 id="const-关键字作用"><a href="#const-关键字作用" class="headerlink" title="const 关键字作用"></a>const 关键字作用</h3><pre><code>作用1:for循环是个经典例子
const arr = [];
//var i=0 与 let i =0 结果不一样
for (let i = 0; i &lt; 10; i++) {
    //数组存的是整个函数对象;
    arr[i] = function() {
        return i;
    }
}
//var i =0;var声明变为全局,导致每个函数最后取到i=10
console.log(arr[5]());// var -&gt; 10
//let 声明只在当前的作用域有效
console.log(arr[5]());// let-&gt;5

作用2:不会污染全局变量
let RegExp = 10;
console.log(RegExp);
console.log(window.RegExp);

// 建议：在默认情况下用const,而只有在你知道变量值需要被修改的情况使用let</code></pre><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<pre><code> // 模板字符串：使用tab键上面的反引号``,插入变量时使用${变量名}
const oBox = document.querySelector(&apos;.box&apos;);
let id = 1,
name = &apos;小马哥&apos;;
//JS
// oBox.innerHTML = &quot;&lt;ul&gt;&lt;li&gt;&lt;p id=&quot; + id + &quot;&gt;&quot; + name + &quot;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&quot;;
//ES6
let htmlStr = `&lt;ul&gt;
    &lt;li&gt;
        &lt;p id=${id}&gt;${name}&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;`;

oBox.innerHTML = htmlStr;</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="不同组件参数传递"><a href="#不同组件参数传递" class="headerlink" title="不同组件参数传递"></a>不同组件参数传递</h3><pre><code> function calculateWinner(squaress) {
    //
 }

 handleClick = (num) =&gt; {
    //
 }

 //calculate={()=&gt;calcuWinner} 返回传函数对象(地址)
 &lt;Board calculate={()=&gt;calcuWinner} squares={history.squares} onClick={num=&gt;this.handleClick(num)} /&gt;

 //calculate={() =&gt; this.props.calculate(this.props.squares)} 返回一个函数对象(地址)
 &lt;Square calculate={() =&gt; this.props.calculate(this.props.squares)} squares={this.props.squares}onClick={() =&gt; this.props.onClick(i)}/&gt;

 //this.props.calculate()或this.props.onClick代表立即执行 this.props.calculate(this.props.squares)();
 &lt;button className=&quot;square&quot; onClick={this.props.onClick} /&gt;

function a(){
    const c =1;
    return fucntion (k){
        return k+c;
    }
}

const A = a();//返回function 地址
A(8)//立即执行后结果9</code></pre><h3 id="函数参数形式"><a href="#函数参数形式" class="headerlink" title="函数参数形式"></a>函数参数形式</h3><h4 id="带参数存在默认值"><a href="#带参数存在默认值" class="headerlink" title="带参数存在默认值"></a>带参数存在默认值</h4><pre><code>function add(a, b = 20) {
    return a + b;
}
console.log(add(30));</code></pre><h4 id="参数默认值可以是一个函数"><a href="#参数默认值可以是一个函数" class="headerlink" title="参数默认值可以是一个函数"></a>参数默认值可以是一个函数</h4><pre><code>function add(a, b = getVal(5)) {
    return a + b;
}</code></pre><h3 id="剩余参数：由三个点…和一个紧跟着的具名参数指定-…keys-类似数组"><a href="#剩余参数：由三个点…和一个紧跟着的具名参数指定-…keys-类似数组" class="headerlink" title="剩余参数：由三个点…和一个紧跟着的具名参数指定 …keys(类似数组)"></a>剩余参数：由三个点…和一个紧跟着的具名参数指定 …keys(类似数组)</h3><pre><code>function pick(obj, ...keys) {
// ...keys 解决了arguments 可以接受多个参数的问题
let result = Object.create(null);
for (let i = 0; i &lt; keys.length; i++) {
    result[keys[i]] = obj[keys[i]];
}
return result;</code></pre><h3 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h3><pre><code>剩余运算符：主要用于形参上,把多个独立的值合并到一个数组中;//没有定义,直接作为形参

扩展运算法(组件传参都使用)：针对数组,将数组分割，并将各个项作为分离的参数传给函数//先定义变量对象,后使用分割

// 处理数组中的最大值，使用apply
const arr = [10, 20, 50, 30, 90, 100, 40];//先定义变量对象
console.log(Math.max.apply(null,arr));//后使用分割

es6 扩展运算法更方便//将数组分割求最大值
console.log(Math.max(...arr));</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code>使用=&gt;来定义
function(){}等于与 (参数)=&gt;{函数体}：括号代表函数形参,箭头代表return,大括号代表函数体；

let add = function (a) {
    return a;
}
//无参数
let add = () =&gt; &quot;hello&quot;;
//一个参数
let add = a =&gt; a;
//两个参数
let add = (a, b) =&gt; {
    return a + b;
}</code></pre><h3 id="返回是对象"><a href="#返回是对象" class="headerlink" title="返回是对象"></a>返回是对象</h3><pre><code>let getObj = id =&gt; {
    return {
        id: id,
        name:&apos;小马哥&apos;
    }
}
//去掉return得加上小括号,如果是基本类型返回可以去掉括号
let getObj = id =&gt; ({id:id,name:&quot;小马哥&quot;});</code></pre><h3 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h3><p>ES5 中 this 指向：取决于调用该函数的上下文对象;ES6 没有 this 绑定</p>
<pre><code>let PageHandle = {
    id: 123,
    init: function () {
        document.addEventListener(&apos;click&apos;,function(event) {
            // console.log(this);
            // 此时this指向document而不是PageHandle.doSomeThings
            // 需要定义完使用bind函数该表this指向,见下面
            this.doSomeThings(event.type);
        })
        //ES5解决方法:使用bind绑定(不建议使用)
        //document.addEventListener(&apos;click&apos;,function(event) {
        //    this.doSomeThings(event.type);
        //}.bind(this),false)
    },
    doSomeThings:function(type){
        console.log(`事件类型:${type},当前id:${this.id}`);

    }
}
PageHandle.init();</code></pre><h4 id="箭头函数解决-this-问题"><a href="#箭头函数解决-this-问题" class="headerlink" title="箭头函数解决 this 问题"></a>箭头函数解决 this 问题</h4><pre><code>let PageHandle = {
    id: 123,
    //对象内部定义函数不要使用箭头函数,如果使用箭头函数,那函数内的作用域失效,this向上查找为定义Pagehandle得对象window
    init: function () {
        // 箭头函数没有this指向，箭头函数内部this值只能通过查找作用域链来确定,
        //一旦使用箭头函数，当前就不存在作用域链(当前作用域失效,this为向上找到第一个对象)
        document.addEventListener(&apos;click&apos;, (event) =&gt; {
            // this.doSomeThings is not a function
            console.log(this);
            this.doSomeThings(event.type);
        }, false)
    },
    doSomeThings: function (type) {
        console.log(`事件类型:${type},当前id:${this.id}`);
    }
}
PageHandle.init();</code></pre><h4 id="使用箭头函数的注意事项"><a href="#使用箭头函数的注意事项" class="headerlink" title="使用箭头函数的注意事项"></a>使用箭头函数的注意事项</h4><pre><code>//没有作用域链，this指向了window，arguments不是window属性
1:使用箭头函数 函数内部没有arguments.
2.箭头函数不能使用new关键字来实例化对象
let Person = ()=&gt;{};
// function函数 也是一个对象，但是箭头函数不是一个对象，它其实就是一个语法糖
let p = new Person();</code></pre><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。</p>
<pre><code>比如，要读取message.body.user.firstName，安全的写法是写成下面这样
const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName)
                    || &apos;default&apos;;
或者使用三元运算符?:，判断一个对象是否存在。
const fooValue = fooInput ? fooInput.value : undefined</code></pre><h4 id="链判断运算符有三种用法"><a href="#链判断运算符有三种用法" class="headerlink" title="链判断运算符有三种用法"></a>链判断运算符有三种用法</h4><pre><code>obj?.prop // 对象属性
obj?.[expr] // 同上
func?.(...args) // 函数或对象方法的调用

a?.b  // 等同于  a == null ? undefined : a.b

a?.[x] // 等同于 a == null ? undefined : a[x]

a?.b()  // 等同于 a == null ? undefined : a.b()

a?.()  // 等同于  a == null ? undefined : a()</code></pre><h3 id="Null-判断运算符"><a href="#Null-判断运算符" class="headerlink" title="Null 判断运算符"></a>Null 判断运算符</h3><h4 id="Null-判断运算符-1"><a href="#Null-判断运算符-1" class="headerlink" title="Null 判断运算符 ||"></a>Null 判断运算符 ||</h4><p>读取对象属性的时候，如果某个属性的值是 null 或 undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。但是属性的值如果为空字符串或 false 或 0，默认值也会生效</p>
<pre><code>const headerText = response.settings.headerText || &apos;Hello, world!&apos;;
const animationDuration = response.settings.animationDuration || 300;
const showSplashScreen = response.settings.showSplashScreen || true;
上面的三行代码都通过||运算符指定默认值，但是这样写是错的。</code></pre><h4 id="Null-判断运算符-2"><a href="#Null-判断运算符-2" class="headerlink" title="Null 判断运算符??"></a>Null 判断运算符??</h4><p>它的行为类似||，但是只有运算符左侧的值为 null 或 undefined 时，才会返回右侧的值。</p>
<pre><code>const headerText = response.settings.headerText ?? &apos;Hello, world!&apos;;
const animationDuration = response.settings.animationDuration ?? 300;
const showSplashScreen = response.settings.showSplashScreen ?? true;
默认值只有在属性值为null或undefined时，才会生效</code></pre><p>??有一个运算优先级问题，它与&amp;&amp;和||的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><pre><code>解构赋值是对赋值运算符的一种扩展,它针对数组和对象来进行操作
优点：代码书写上简洁易读
1.对象解构:类似将对象拆散
let node = {
    type:&apos;iden&apos;,
    name:&apos;foo&apos;,
    age:10
}
//ES5之前
let type = node.type;
let name = node.name;</code></pre><h3 id="对象完全解构-将对象属性与变量名一致"><a href="#对象完全解构-将对象属性与变量名一致" class="headerlink" title="对象完全解构:将对象属性与变量名一致"></a>对象完全解构:将对象属性与变量名一致</h3><pre><code>let {type,name,age} = node;
console.log(type,name);</code></pre><h3 id="不完全解构-只解构出对象里一部分属性"><a href="#不完全解构-只解构出对象里一部分属性" class="headerlink" title="不完全解构:只解构出对象里一部分属性"></a>不完全解构:只解构出对象里一部分属性</h3><pre><code>let {type,age} = node;</code></pre><h3 id="剩余运算符-将对象剩下的属性存入对象-res-中"><a href="#剩余运算符-将对象剩下的属性存入对象-res-中" class="headerlink" title="剩余运算符:将对象剩下的属性存入对象 res 中"></a>剩余运算符:将对象剩下的属性存入对象 res 中</h3><pre><code>let {name,...res} = node;
console.log(res);//是一个对象</code></pre><h3 id="默认值解构"><a href="#默认值解构" class="headerlink" title="默认值解构"></a>默认值解构</h3><pre><code>let {a,b = 30} = {a:20};

2.对数组解构
let arr = [1,2,3];
let [a,b] = arr;
console.log(a,b);
// 可嵌套:解构是对应嵌套数据结构
let [a,[b],c] = [1,[2],3];</code></pre><h2 id="对象的扩展功能"><a href="#对象的扩展功能" class="headerlink" title="对象的扩展功能"></a>对象的扩展功能</h2><p>es6 直接写入变量和函数，作为对象的属性和方法<br>Object.keys(),Object.values(),Object.entries(),Object.fromEntries()</p>
<h3 id="属性名跟属性值一样"><a href="#属性名跟属性值一样" class="headerlink" title="属性名跟属性值一样"></a>属性名跟属性值一样</h3><pre><code>const name =&apos;q&apos;;
const age = &apos;12&apos;;
const person = {
     name,//等价于name:name
     age,//age:age
     sayName(){//sayName:function(){}
         console.log(this.name);
     }
}</code></pre><h3 id="返回对象的属性名跟变量名一样"><a href="#返回对象的属性名跟变量名一样" class="headerlink" title="返回对象的属性名跟变量名一样"></a>返回对象的属性名跟变量名一样</h3><pre><code>function fn(x,y) {
   return {x,y};
 }</code></pre><h3 id="对象定义"><a href="#对象定义" class="headerlink" title="对象定义"></a>对象定义</h3><pre><code>onst obj = {};
obj.isShow = true;
const name = &apos;a&apos;;
obj[name+&apos;bc&apos;] = 123;
console.log(obj);//abc =123</code></pre><h3 id="比较对象的是否一样方法：Object-is"><a href="#比较对象的是否一样方法：Object-is" class="headerlink" title="比较对象的是否一样方法：Object.is"></a>比较对象的是否一样方法：Object.is</h3><pre><code>比较两个值是否严格相等,解决出错NaN===NaN// false，+0 === -0 //true
特殊例子：console.log(NaN === NaN);//false
console.log(Object.is(NaN, NaN));//true</code></pre><h3 id="对象的合并-给对象添加新属性"><a href="#对象的合并-给对象添加新属性" class="headerlink" title="对象的合并(给对象添加新属性)"></a>对象的合并(给对象添加新属性)</h3><pre><code>Object.assign(target,obj1,obj2....)
// 返回合并之后的新对象
let newObj = Object.assign({}, { a: 1 }, { b: 2 });
console.log(newObj);</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre><code>浅拷贝：Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。

同名属性的替换：对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。

数组的处理：Object.assign可以用来处理数组，但是会把数组视为对象
Object.assign([1, 2, 3], [4, 5])   // [4, 5, 3]
上面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1

取值函数的处理：Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
const source = {
get foo() { return 1 }
};
const target = {};

Object.assign(target, source)// { foo: 1 }
上面代码中，source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</code></pre><h3 id="Object-keys-Object-values-Object-entries-Object-fromEntries"><a href="#Object-keys-Object-values-Object-entries-Object-fromEntries" class="headerlink" title="Object.keys(),Object.values(),Object.entries(),Object.fromEntries()"></a>Object.keys(),Object.values(),Object.entries(),Object.fromEntries()</h3><pre><code>const obj = { foo: &apos;bar&apos;, baz: 42 };
Object.values(obj)
// [&quot;bar&quot;, 42]

const obj = { foo: &apos;bar&apos;, baz: 42 };
Object.values(obj)
// [&quot;bar&quot;, 42]

const obj = { foo: &apos;bar&apos;, baz: 42 };
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
Object.entries方法的另一个用处是，将对象转为真正的Map结构。
const obj = { foo: &apos;bar&apos;, baz: 42 };
const map = new Map(Object.entries(obj));
map // Map { foo: &quot;bar&quot;, baz: 42 }

Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。
Object.fromEntries([
    [&apos;foo&apos;, &apos;bar&apos;],
    [&apos;baz&apos;, 42]
])
// { foo: &quot;bar&quot;, baz: 42 }</code></pre><h2 id="数据类型-Symbol"><a href="#数据类型-Symbol" class="headerlink" title="数据类型 Symbol"></a>数据类型 Symbol</h2><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code>最大的用途：用来定义对象的私有变量
//原始数据类型Symbol ,由它创建出来的变量值是独一无二,也就是指向地址是不一样
const name = Symbol(&apos;name&apos;);
const name2 = Symbol(&apos;name&apos;);
console.log(name === name2);</code></pre><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="如果用-Symbol-定义的对象中的变量，取值时一定要用-变量名"><a href="#如果用-Symbol-定义的对象中的变量，取值时一定要用-变量名" class="headerlink" title="如果用 Symbol 定义的对象中的变量，取值时一定要用[变量名]"></a>如果用 Symbol 定义的对象中的变量，取值时一定要用[变量名]</h4><pre><code>let s1 = Symbol(&quot;s1&quot;);
let obj = {
    [s1]: &quot;小马哥&quot;,
};
obj[s1] = &apos;小马哥&apos;;
console.log(obj[s1]);</code></pre><h4 id="symbol-定义对象属性是无法被遍历到-类似私有化被锁"><a href="#symbol-定义对象属性是无法被遍历到-类似私有化被锁" class="headerlink" title="symbol 定义对象属性是无法被遍历到,类似私有化被锁"></a>symbol 定义对象属性是无法被遍历到,类似私有化被锁</h4><pre><code>for(let key in obj){
    console.log(key);
}
//这样定义的属性无法读取到
console.log(Object.keys(obj));</code></pre><h4 id="获取-Symbol-定义对象属性方法"><a href="#获取-Symbol-定义对象属性方法" class="headerlink" title="获取 Symbol 定义对象属性方法"></a>获取 Symbol 定义对象属性方法</h4><pre><code>1.获取Symbol声明的属性名（作为对象的key）
let s = Object.getOwnPropertySymbols(obj);
console.log(s[0]);

//反射对象获取
2.let m = Reflect.ownKeys(obj);
console.log(m);</code></pre><h4 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h4><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>
<pre><code>const shapeType = {
triangle: &apos;Triangle&apos;
};

function getArea(shape, options) {
let area = 0;
switch (shape) {
    case shapeType.triangle:
    area = .5 * options.width * options.height;
    break;
}
return area;
}

getArea(shapeType.triangle, { width: 100, height: 100 });
如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。

const shapeType = {
triangle: Symbol()
};</code></pre><h4 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for()/Symbol.keyFor()"></a>Symbol.for()/Symbol.keyFor()</h4><p>Symbol.for()它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<pre><code>let s1 = Symbol.for(&apos;foo&apos;);
let s2 = Symbol.for(&apos;foo&apos;);

s1 === s2 // true</code></pre><p>Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的 key。</p>
<pre><code>let s1 = Symbol.for(&quot;foo&quot;);
Symbol.keyFor(s1) // &quot;foo&quot;

let s2 = Symbol(&quot;foo&quot;);
Symbol.keyFor(s2) // undefined s2没有使用Symbol.for()为 Symbol 值登记的名字</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>forEach(),map(),filter(),find(),every,some,reduce</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><pre><code>// currentValue 数组中正在处理的当前元素,index 当前索引值,array 正在处理的数组
arr.forEach((currentValue,index,array)=&gt;{});</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>应用场景：要返回一个要利用原数组经过运算后的数组，或者是在一个对象数组中要拿到某一个属性，并且返回一个新数组的情况</p>
<pre><code>// currentValue = 当前执行元素,index = 当前索引值,array = 执行的数组
arr.map((currentValue,index,array)=&gt;{})</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>1)已知对象数组，要把对象数组中一些符合要求的对象重新组成一个数组<br>2）筛选出符合多个条件的对象数组中的一些元素，组成新数组或者是直接覆盖原数组</p>
<pre><code>//currentValue = 当前执行元素,index = 当前索引值,array = 执行的数组
arr.filter((currentValue,index,array)=&gt;{});</code></pre><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>find（）方法只会找到第一个符合的，找到之后就会直接返回当前数组得值或对象，就算下面还有符合要求的，也不会再找下去</p>
<pre><code>let arr1 = arr.find((value, index, array) =&gt;value &gt; 2)</code></pre><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>一假全假:every()相当于&amp;&amp;，遍历找到一个 false，不再往下找</p>
<pre><code>// currentValue = 当前执行元素,index = 当前索引值，array = 执行的数组,返回值是true或者false
arr.every((currentValue,index,array)=&gt;{})</code></pre><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>一真全真:some()相当于||，遍历返回一个 true，不再往下找</p>
<pre><code>// currentValue = 当前执行元素,index = 当前索引值,array = 执行的数组,返回值是true或者false
arr.some((currentValue,index,array)=&gt;{})</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>1)代替 map 做一些简单的运算<br>2）将一个对象数组中的某些属性的值抽出来，组成一个新的数组</p>
<pre><code>// 参数 = accumulator 第一次运行时的初始值,返回一个数值或者数组
arr.reduce((accumulator, currentValue,currentIndex,array)=&gt;{},参数);</code></pre><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h2><p>Set 结构不会添加重复的值,Set 实例添加了两次 NaN，但是只会加入一个。这表明，在 Set 内部，两个 NaN 是相等的。<br>另外，两个对象总是不相等的</p>
<h3 id="set：-去重-表示无重复值的有序列表"><a href="#set：-去重-表示无重复值的有序列表" class="headerlink" title="set：(去重)表示无重复值的有序列表"></a>set：(去重)表示无重复值的有序列表</h3><pre><code>// 去除数组的重复成员
[...new Set(array)]
//去除字符串里面的重复字符
[...new Set(&apos;ababbc&apos;)].join(&apos;&apos;) //&quot;abc&quot;</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><pre><code>let set = new Set();
//查看set的原型_proto_自带的方法
console.log(set);
// 添加元素
set.add(2);
// 删除元素
set.delete(2);
// 校验某个值是否在set中
console.log(set.has(&quot;4&quot;));
console.log(set.size);</code></pre><h3 id="set-转为数组"><a href="#set-转为数组" class="headerlink" title="set 转为数组"></a>set 转为数组</h3><pre><code>let set2 = new Set([1, 2, 3, 3, 3, 4]);
// 扩展运算符将set转换成数组
let arr = [...set2];
console.log(arr);

Array.from方法可以将 Set 结构转为数组。
const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);</code></pre><h3 id="注意：set-使用引用产生问题"><a href="#注意：set-使用引用产生问题" class="headerlink" title="注意：set 使用引用产生问题"></a>注意：set 使用引用产生问题</h3><pre><code>1.set中对象的引用无法被释放
let set3 = new Set(),obj = {};
set3.add(obj);
// 释放当前的资源
obj = null;
console.log(set3);//集合还有对象

//解决引用对象被释放
let set4 = new WeakSet(),
obj = {};
set4.add(obj);
// 释放当前的资源
obj = null;
console.log(set4);//集合里对象被释放

WeakSet 与 set 的不同点
1.不能传入非对象类型的参数
2.不可迭代
3.没有forEach()
4.没有size属性</code></pre><h2 id="集合-Map"><a href="#集合-Map" class="headerlink" title="集合 Map"></a>集合 Map</h2><p>Map 类型是键值对的有序列表，键和值是任意类型</p>
<pre><code>let map = new Map();
map.set(&apos;name&apos;,&apos;张三&apos;);
map.set(&apos;age&apos;,20);
console.log(map.get(&apos;name&apos;));
console.log(map);
map.has(&apos;name&apos;);//true
map.delete(&apos;name&apos;);
map.clear();
console.log(map);
//key 与 value类型不控制
map.set([&apos;a&apos;,[1,2,3]],&apos;hello&apos;);
console.log(map);
//直接初始化
let m = new Map([[&quot;a&quot;, 1],[&quot;c&quot;, 2],]);
console.log(m);</code></pre><h3 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a>遍历 Map 结构</h3><p>任何部署了 Iterator 接口的对象，都可以用 for…of 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<h4 id="遍历获取键值对-key-value"><a href="#遍历获取键值对-key-value" class="headerlink" title="遍历获取键值对 key/value"></a>遍历获取键值对 key/value</h4><pre><code>const map = new Map();
map.set(&apos;first&apos;, &apos;hello&apos;);
map.set(&apos;second&apos;, &apos;world&apos;);

for (let [key, value] of map) {
console.log(key + &quot; is &quot; + value);
}</code></pre><h4 id="遍历获取键名-key"><a href="#遍历获取键名-key" class="headerlink" title="遍历获取键名 key"></a>遍历获取键名 key</h4><pre><code>for (let [key] of map) {
// ...
}</code></pre><h4 id="获取键值-value"><a href="#获取键值-value" class="headerlink" title="获取键值 value"></a>获取键值 value</h4><pre><code>for (let [,value] of map) {
// ...
}</code></pre><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><h4 id="Map-转为数组"><a href="#Map-转为数组" class="headerlink" title="Map 转为数组"></a>Map 转为数组</h4><pre><code>const myMap = new Map()
myMap.set(true, 7)
myMap.set({foo: 3}, [&apos;abc&apos;]);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ &apos;abc&apos; ] ] ]</code></pre><h4 id="数组转为-Map"><a href="#数组转为-Map" class="headerlink" title="数组转为 Map"></a>数组转为 Map</h4><pre><code>new Map([ [true, 7],[{foo: 3}, [&apos;abc&apos;]]])
Map {true =&gt; 7,Object {foo: 3} =&gt; [&apos;abc&apos;]}</code></pre><h4 id="Map-转为对象"><a href="#Map-转为对象" class="headerlink" title="Map 转为对象"></a>Map 转为对象</h4><pre><code>function strMapToObj(strMap) {
let obj = Object.create(null);
for (let [k,v] of strMap) {
    obj[k] = v;
}
return obj;
}

const myMap = new Map()
myMap.set(&apos;yes&apos;, true)
myMap.set(&apos;no&apos;, false);
strMapToObj(myMap)
// { yes: true, no: false }</code></pre><h4 id="对象转为-Map"><a href="#对象转为-Map" class="headerlink" title="对象转为 Map"></a>对象转为 Map</h4><pre><code>let obj = {&quot;a&quot;:1, &quot;b&quot;:2};
let map = new Map(Object.entries(obj));//先转为数组</code></pre><h4 id="Map-转为-JSON"><a href="#Map-转为-JSON" class="headerlink" title="Map 转为 JSON"></a>Map 转为 JSON</h4><pre><code>function strMapToJson(strMap) {
return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);
strMapToJson(myMap)
// &apos;{&quot;yes&quot;:true,&quot;no&quot;:false}&apos;</code></pre><h4 id="JSON-转为-Map"><a href="#JSON-转为-Map" class="headerlink" title="JSON 转为 Map"></a>JSON 转为 Map</h4><pre><code>function jsonToStrMap(jsonStr) {
return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap(&apos;{&quot;yes&quot;: true, &quot;no&quot;: false}&apos;)
// Map {&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false}</code></pre><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h3><p>遍历数组后,返回新数组</p>
<p>const arr = [‘a’,’b’];<br>arr.map((value,index)=&gt; {})</p>
<h3 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h3><pre><code>1.arguments转为数组：将伪数组转换成真正的数组
function add() {
    // console.log(arguments);

    // es5转换:
    // let arr = [].slice.call(arguments);
    // console.log(arr);

    // es6写法：arguments转为数组
    let arr = Array.from(arguments);
    console.log(arr);
}
add(1, 2, 3);

2.from转换：list转为数组
let lis = document.querySelectorAll(&apos;li&apos;)
//lis为list
console.log(Array.from(lis));

3.扩展运算符:list转为数组
console.log([...lis]);

4.from() 还可以接受第二个参数，用来对每个元素进行处理
let liContents = Array.from(lis, ele =&gt; ele.textContent);
// console.log(liContents);</code></pre><h3 id="数组方法与-Array-of-方法"><a href="#数组方法与-Array-of-方法" class="headerlink" title="数组方法与 Array.of()方法"></a>数组方法与 Array.of()方法</h3><h4 id="map-方法-1"><a href="#map-方法-1" class="headerlink" title="map()方法"></a>map()方法</h4><pre><code>map((数组的值,数组下标)=&gt;{return 处理})//返回新数组
const arr = var arr = [1,2,3];
const tt = arr.map((item,index) =&gt; {
    return item*2;
});

tt = [2,4,6];</code></pre><h4 id="将任意的数据类型，转换成数组"><a href="#将任意的数据类型，转换成数组" class="headerlink" title="将任意的数据类型，转换成数组"></a>将任意的数据类型，转换成数组</h4><pre><code>console.log(Array.of(3, 11, 20, [1, 2, 3], {id: 1}));</code></pre><h4 id="遍历-keys-下标-values-值-entries"><a href="#遍历-keys-下标-values-值-entries" class="headerlink" title="遍历.keys()下标/.values()值/entries()"></a>遍历.keys()下标/.values()值/entries()</h4><pre><code>//返回一个遍历器(Iterator),可以使用for...of循环进行遍历
console.log([&apos;a&apos;,&apos;b&apos;].keys());

// keys() 对数组下标遍历
for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) {
    console.log(index);//0,1
}

// values() 对值遍历
for (let ele of [&apos;a&apos;, &apos;b&apos;].values()) {
    console.log(ele);//a,b
}

// entries() 对数组下标与值对遍历
for(let [index,ele] of [&apos;a&apos;,&apos;b&apos;].entries()){
    console.log(index,ele);
}
let letter = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];
let it = letter.entries();
console.log(it.next().value);</code></pre><h4 id="includes-返回一个布尔值，表示某个数组是否包含给定的值"><a href="#includes-返回一个布尔值，表示某个数组是否包含给定的值" class="headerlink" title="includes() 返回一个布尔值，表示某个数组是否包含给定的值"></a>includes() 返回一个布尔值，表示某个数组是否包含给定的值</h4><pre><code>console.log([1,2,3].includes(2));
console.log([1,2,3].includes(&apos;4&apos;));

ES5之前:indexof()是否包含给定的值
console.log([1,2,3].indexOf(&apos;2&apos;));//存在返回大于1，否则返回-1</code></pre><h4 id="findIndex-找出第一个符合条件的数组成员的索引-下标"><a href="#findIndex-找出第一个符合条件的数组成员的索引-下标" class="headerlink" title="findIndex()找出第一个符合条件的数组成员的索引(下标)"></a>findIndex()找出第一个符合条件的数组成员的索引(下标)</h4><pre><code>let numIndex = [1, 2, -10, -20, 9, 2].findIndex(n =&gt; n &lt; 0)
console.log(numIndex);//2</code></pre><h4 id="find-1"><a href="#find-1" class="headerlink" title="find()"></a>find()</h4><pre><code>// find()找出第一个符合条件的数组的值
let num = [1, 2, -10, -20, 9, 2].find(n =&gt; n &lt; 0);//回调方法
console.log(num);//-10</code></pre><h4 id="copywithin-数组内部将制定位置的元素复制到其它的位置，返回当前数组"><a href="#copywithin-数组内部将制定位置的元素复制到其它的位置，返回当前数组" class="headerlink" title="copywithin() 数组内部将制定位置的元素复制到其它的位置，返回当前数组"></a>copywithin() 数组内部将制定位置的元素复制到其它的位置，返回当前数组</h4><pre><code>// 从3位置往后的所有数值，替换从0位置往后的三个数值
console.log([1, 2, 3, 8, 9, 10].copyWithin(0, 3));//[8,9,10,8,9,10]</code></pre><h3 id="Iterator-遍历器"><a href="#Iterator-遍历器" class="headerlink" title="Iterator 遍历器"></a>Iterator 遍历器</h3><pre><code>两个核心：
1.迭代器是一个接口，能快捷的访问数据，通过Symbol.iterator来创建迭代器 通过迭代器的next()获取迭代之后的结果
2.迭代器是用于遍历数据结构的指针(数据库的游标)

使用迭代器:由数组对象获取迭代器
const items = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];
1.由数组创建新的迭代器:控制台看数组对象proto原型里有Symbol.iterator函数对象
const ite = items[Symbol.iterator]();//items[Symbol.iterator]返回函数,加括号立即执行
//ite.next()返回{value: &quot;one&quot;, done: false} done如果为false表示遍历继续 如果为true表示遍历完成
console.log(ite.next());</code></pre><h2 id="解决异步问题的-3-种方式"><a href="#解决异步问题的-3-种方式" class="headerlink" title="解决异步问题的 3 种方式"></a>解决异步问题的 3 种方式</h2><pre><code>Generator  Promise  async  1.解决回调地域  2.使得异步操作显得更加方便</code></pre><h3 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h3><h4 id="A-作用功能"><a href="#A-作用功能" class="headerlink" title="A.作用功能:"></a>A.作用功能:</h4><pre><code>generator函数,可以通过yield关键字，将函数挂起(卡住)，为了改变执行流提供了可能，同时为了做异步编程(http请求)提供了方案</code></pre><h4 id="B-它普通函数的两点区别"><a href="#B-它普通函数的两点区别" class="headerlink" title="B.它普通函数的两点区别"></a>B.它普通函数的两点区别</h4><pre><code>1.function后面 函数名之前有个*
2.只能在函数内部使用yield表达式，让函数挂起,挂起时返回当前卡住的对象

function* func() {
    console.log(&apos;one&apos;);
    yield 2;
    console.log(&apos;two&apos;);
    yield 3;
    console.log(&apos;end&apos;);
}

let fn = func();//没进入函数体,func()返回一个遍历器对象 可以调用next()继续往下执行遇到yeild卡住返回卡住对象
// console.log(o)
console.log(fn.next());//执行到yield 2卡住;返回卡住yield 2{value: &quot;2&quot;, done: false}
console.log(fn.next());//从卡住yield 2执行到yield 3卡住;返回卡住yield 3{value: &quot;3&quot;, done: false}
console.log(fn.next());//从卡住yield 3继续往下执行{value: &quot;undefined&quot;, done: false}

总结：generator函数是分段执行的,yield语句是暂停执行,而next()恢复执行</code></pre><h4 id="C-yield-传参"><a href="#C-yield-传参" class="headerlink" title="C.yield 传参"></a>C.yield 传参</h4><pre><code>function* add() {
    1.console.log(&quot;start&quot;);
    // x 可真的不是yield &apos;2&apos;的返回值，它是next()方法调用 恢复当前yield()执行传入的实参
    2.let x = yield &quot;2&quot;;
    3.console.log(&quot;one:&quot; + x);
    4.let y = yield &quot;3&quot;;
    5.console.log(&quot;two:&quot; + y);
    6.return x + y;
}
const fn = add();//返回add()方法对象的一个遍历fn
console.log(fn.next()); //执行到1,卡住在2,返回卡住时对象{value:&apos;2&apos;,done:false}
console.log(fn.next(20)); //传入参数,执行到卡住的2,执行3，返回卡住4的对象{value:&apos;3&apos;,done:false}
console.log(fn.next(30)); //{value:50,done:true}</code></pre><h4 id="使用场景-1：一般对象不具备为-Interator-接口-不具备-Interator-接口的对象提供了遍历操作"><a href="#使用场景-1：一般对象不具备为-Interator-接口-不具备-Interator-接口的对象提供了遍历操作" class="headerlink" title=".使用场景 1：一般对象不具备为 Interator 接口,不具备 Interator 接口的对象提供了遍历操作"></a>.使用场景 1：一般对象不具备为 Interator 接口,不具备 Interator 接口的对象提供了遍历操作</h4><pre><code>function* objectEntries(obj) {
    // 获取对象的所有的key数组
    const propKeys = Object.keys(obj);
    for(const propkey of propKeys){
        yield [propkey,obj[propkey]];//卡住返回当前对象
        // 换成内部return拿不到结果
    }
}

const obj = {
    name:&apos;小马哥&apos;,
    age:18
}

//给对象定义一个iterator函数属性：objectEntries
obj[Symbol.iterator] = objectEntries;
console.log(obj);

//遍历返回每个key,value
for(let [key,value] of objectEntries(obj)){
    console.log(`${key}:${value}`);
}</code></pre><h4 id="E-主要针对异步编程-http-请求"><a href="#E-主要针对异步编程-http-请求" class="headerlink" title="E.主要针对异步编程(http 请求)"></a>E.主要针对异步编程(http 请求)</h4><p>应用 1：</p>
<pre><code>问题:Generator 部署ajax操作，让异步代码同步化
// 回调地狱：嵌套异步请求每一个请求都是异步,为了让嵌套变得同步()
$.ajax({
    url: &apos;https://xxx&apos;,
    method: &apos;get&apos;,
    success(res) {
        console.log(res);
        // 嵌套请求
        $.ajax({ })
    }
})

解决方案://使用Generator解决嵌套异步变为同步(异步递归变为同步递归)
1.先定义生成器函数
function* main() {
    console.log(&apos;main&apos;);
    let res = yield request(&apos;https://xxxxx&apos;);
    console.log(res);

    // 执行后面的操作
    console.log(&apos;数据请求完成，可以继续操作&apos;);
}
2.执行生成器至嵌套函数挂起
const ite = main();
//先让生成器挂起即将请求
ite.next();

3.开始使得挂起嵌套函数执行:使得调用每个函数结束才会点另外个函数,变为有序同步(异步递归变为同步递归)
function request(url) {
    $.ajax({
        url,
        method: &apos;get&apos;,
        success(res) {
            //执行挂起请求
            ite.next(res);
        }
    })
}</code></pre><p>应用 2：在产生异步前挂起</p>
<pre><code>// 加载loading...页面
// 数据加载完成...（异步操作）
// loading关闭掉
function loadUI() {
    console.log(&apos;加载loading...页面&apos;);
}

function hideUI() {
    console.log(&apos;隐藏loading...页面&apos;);
}

function* load() {
    loadUI();
    yield showData();
    hideUI();
}

let itLoad = load();
//在执行到异步showData时挂起
itLoad.next();

function showData() {
    // 模拟异步操作
    setTimeout(() =&gt; {
        console.log(&apos;数据加载完成&apos;);
        //等定时器到了(异步函数处理完),继续执行挂起函数
        itLoad.next();
    }, 1000);
}</code></pre><h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><p>Promise 对象(类似封装了 AJAX)相当于一个容器，对象保存着异步操作的事件请求返回的结果,然后通过对象方法处理相应结果<br>Promise 有 axios 封装的库</p>
<h4 id="Promise-对象特点："><a href="#Promise-对象特点：" class="headerlink" title="Promise 对象特点："></a>Promise 对象特点：</h4><pre><code>1.对象的状态不受外界影响,处理异步操作三个状态：
    Pending(请求进行中:不常用) Resolved(请求成功调用的函数:常用) Rejected(请求失败调用的函数:常用)
2.一旦状态改变，就不会再变，任何时候都可以得到这个结果

例子:
function timeOut(ms) {
    return new Promise((resolved,rejected)=&gt;{
        //定时模拟异步请求
        setTimeout(() =&gt; {
            //异步请求成功后调用resolved函数返回Promise结果对象
            resolved(&apos;hello promise success!!&apos;)
        }, ms);
    })
}

//
timeOut(2000).then((val)=&gt;{console.log(val);</code></pre><h4 id="Promise-对象-then-方法的使用"><a href="#Promise-对象-then-方法的使用" class="headerlink" title="Promise 对象 then 方法的使用"></a>Promise 对象 then 方法的使用</h4><p>拓展知识:封装原生 JS:<a href="https://www.jianshu.com/p/918c63045bc3/" target="_blank" rel="noopener">XMLHttpRequest—必知必会</a></p>
<pre><code>const getJSON = function (url) {
        return new Promise((resolve, reject) =&gt; {
            const xhr = new XMLHttpRequest();
            xhr.open(&apos;GET&apos;, url);
            xhr.onreadystatechange = handler;
            xhr.responseType = &apos;json&apos;;
            xhr.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;);
            // 发送
            xhr.send();

            function handler() {

                if (this.readyState === 4) {
                    if (this.status === 200) {
                        //返回promise对象
                        resolve(this.response.HeWeather6);
                    } else {
                        //返回promise对象
                        reject(new Error(this.statusText));
                    }
                }

            }
        })
    }

let a = getJSON(&apos;https://xxxxx&apos;).then((data) =&gt; {
        console.log(data);
        //return后的被自动封装为promise对象,可以继续使用then方法
        return data[0]
    }).then((obj)=&gt;{console.log(obj);
注:
    通url请求在resolve函数/reject函数返回promise对象,使用then(函数1，函数2)方法:第二个参数是可选的
    then(函数1，函数2)方法：then(resolve返回promise对象处理的函数,reject返回promise对象处理的函数)
1.getJSON(url).then((data)=&gt;{处理data},(err)=&gt;{处理err});
2.getJSON(url).then((data)=&gt;{处理data});//一个函数参数,then只处理默认为resolve返回的对象
3.getJSON(url).then(null,(err)=&gt;{处理err});//then只处理reject返回的对象
4.getJSON(url).then((data)=&gt;{处理data},(err)=&gt;{处理err}).catch((e)=&gt;{处理异常e}).done().finally().</code></pre><h4 id="Promise-对象-reslove-reject-方法的使用"><a href="#Promise-对象-reslove-reject-方法的使用" class="headerlink" title="Promise 对象 reslove/reject 方法的使用"></a>Promise 对象 reslove/reject 方法的使用</h4><pre><code>//resolve()能将现有的任何对象转换成promise对象
let p = new Promise(resolve=&gt;resolve(&apos;foo&apos;));//等价于let p = Promise.resolve(&apos;foo&apos;);
p.then((data)=&gt;{ console.log(data); })
///reject()能将现有的任何对象转换成promise对象
let p = new Promise(reject=&gt;reject(&apos;foo&apos;))
p.then(null,(refuse)=&gt;{ console.log(refuse); })</code></pre><h4 id="Promise-对象-all-参数为-promise-数组-方法的使用"><a href="#Promise-对象-all-参数为-promise-数组-方法的使用" class="headerlink" title="Promise 对象 all(参数为 promise 数组)方法的使用"></a>Promise 对象 all(参数为 promise 数组)方法的使用</h4><pre><code>应用：一些游戏类的素材比较多，等待图片、flash、静态资源文件 都加载完成 才进行页面的初始化
let promise1 = new Promise((resolve, reject) =&gt; {});
let promise2 = new Promise((resolve, reject) =&gt; {});
let promise3 = new Promise((resolve, reject) =&gt; {});

let p4 = Promise.all([promise1, promise2, promise3])
p4.then(()=&gt;{
    // 三个都成功  才成功
}).catch(err=&gt;{
    // 如果有一个失败 则失败
})</code></pre><h4 id="Promise-对象-race-方法的使用"><a href="#Promise-对象-race-方法的使用" class="headerlink" title="Promise 对象 race()方法的使用"></a>Promise 对象 race()方法的使用</h4><p>race(请求函数(返回 promise 对象),超时的处理函数(返回 promise 对象)):某个异步请求设置超时时间，并且在超时后执行相应的操作</p>
<pre><code>// 1 请求图片资源
function requestImg(imgSrc) {
    return new Promise((resolve, reject) =&gt; {
        const img = new Image();
        img.onload = function () {
            resolve(img);
        }

        //图片可以相对路径
        img.src = imgSrc;
    });
}

//2.超时处理函数
function timeout() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            reject(new Error(&apos;图片请求超时&apos;));
        },3000);
    })
}

Promise.race([requestImg(&apos;https://dddd&apos;),timeout()]).then(data=&gt;{
    console.log(data);
    document.body.appendChild(data);
}).catch(err=&gt;{console.log(111)}).finally(console.log(222));</code></pre><h4 id="Promise-对象-catch-与-finally-方法的使用"><a href="#Promise-对象-catch-与-finally-方法的使用" class="headerlink" title="Promise 对象 catch()与 finally()方法的使用"></a>Promise 对象 catch()与 finally()方法的使用</h4><pre><code>new Promise(resolve=&gt;{new Error(&apos;444&apos;);}).then(data =&gt; { console.log(000); }).catch(console.log(111)).finally(console.log(222));
注:类似关闭io流那样
//少用
server.listen(3000).then(()=&gt;{处理}).catch(console.log(err)).finally(server.stop());</code></pre><h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><p>作用：使得异步操作更加方便,async 它会返回一个 Promise 对象,然后调用 then()方法,catch()方法,finally()<br>async 是 Generator 的一个语法糖(比 Generator 更容易操作)<br>注：await 只能在 async 函数内部使用</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>async function f() {
    //await 返回一个promise对象,如果不是就会自动封装
    let s = await &apos;hello world&apos;;
    let data = await s.split(&apos;&apos;);
    return data;
}

// 如果async函数中有多个await 那么then函数会等待所有的await指令,运行完的结果,才去执行
f().then(v =&gt; {console.log(v)}).catch(e =&gt; console.log(e));</code></pre><h4 id="避免出异常导致后面无法操作"><a href="#避免出异常导致后面无法操作" class="headerlink" title="避免出异常导致后面无法操作"></a>避免出异常导致后面无法操作</h4><pre><code>async function f2() {
    try {
        await Promise.reject(&quot;出错了&quot;);
    } catch (error) {

    }
    return await Promise.resolve(&quot;hello&quot;);
}

f2().then((v) =&gt; console.log(v)).catch((e) =&gt; console.log(e));</code></pre><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><pre><code>想获取和风天气现在now的数据

const getJSON = function (url) {
    return new Promise((resolve, reject) =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.open(&quot;GET&quot;, url);
        xhr.onreadystatechange = handler;
        xhr.responseType = &quot;json&quot;;
        xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
        // 发送
        xhr.send();

        function handler() {
        if (this.readyState === 4) {
            if (this.status === 200) {
            resolve(this.response);
            } else {
            reject(new Error(this.statusText));
            }
        }
        }
    });
 };

async function getNowWeather(url) {
    // 发送ajax 获取实况天气
    let res = await getJSON(url);
    console.log(res);
    // 获取HeWeather6的数据   获取未来3~7天的天气状况
    let arr = await res.HeWeather6;
    return arr[0].now;
}

getNowWeather(&quot;https://xxxx&quot; ).then((now) =&gt; {
    console.log(now);
});</code></pre><h2 id="Class-类及继承"><a href="#Class-类及继承" class="headerlink" title="Class 类及继承"></a>Class 类及继承</h2><h3 id="class-类定义"><a href="#class-类定义" class="headerlink" title="class 类定义"></a>class 类定义</h3><h4 id="ES5-之前定义类"><a href="#ES5-之前定义类" class="headerlink" title="ES5 之前定义类"></a>ES5 之前定义类</h4><pre><code>构造函数与函数区别函数名的大小写区别：大写为构造函数，小写为函数

function Person(name,age) {
    this.name = name;
    this.age = age;
}
//原型上添加方法
Person.prototype.sayName = function() {
    return this.name;
}
let p1 = new Person(&apos;小马哥&apos;,28);
console.log(p1);</code></pre><h4 id="ES6-定义类"><a href="#ES6-定义类" class="headerlink" title="ES6 定义类"></a>ES6 定义类</h4><pre><code>class Person {
    // 实例化的时候会立即被调用
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    //直接定义方法
}

//添加方法:通过Object.assign()方法一次性向类中添加多个方法
Object.assign(Person.prototype, {
    sayName() {
        return this.name
    },
    sayAge() {
        return this.age
    }
})

let p1 = new Person(&apos;小马哥&apos;, 28);
console.log(p1);</code></pre><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><pre><code>// 使用关键字 extends
class Animal{
    constructor(name,age) {
        this.name = name;
        this.age = age;
    }
    sayName(){
        return this.name;
    }
    sayAge(){
        return this.age;
    }
}

class Dog extends Animal{
    constructor(name,age,color) {
        super(name,age);//等价于 Animal.call(this,name,age);
        this.color = color;
    }
    // 子类自己的方法
    sayColor(){
        return `${this.name}是${this.age}岁了,它的颜色是${this.color}`
    }
    // 重写父类的方法
    sayName(){
        return this.name + super.sayAge() + this.color;
    }

}

let d1 = new Dog(&apos;小黄&apos;,28,&apos;red&apos;);
console.log(d1.sayColor());
console.log(d1.sayName());</code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><pre><code>export规定对外接口：defult 只能出现一次默认导出
import时加大括号解构:
    {导出类没带defult对象,且名字一样;可以用 A as B 改变名字}
    defualt的对象：名字可以任意改变

// ES6 module
import Person,{name,age,sayName as say} from &apos;./modules/index.js&apos;;
(少用:导出所有)//import * as f from &apos;./modules/index.js&apos;

const p = new Person();
// console.log(f.default);
// console.log(name,age,sayName());

输入模块的指定方法
加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></pre>]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>Immutable原理(React)</title>
    <url>/2019/12/13/FroEnd-Immutale%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="Immutable原理"><a href="#Immutable原理" class="headerlink" title="Immutable原理"></a>Immutable原理</h2><h3 id="immutablejs-是如何优化我们的代码的？"><a href="#immutablejs-是如何优化我们的代码的？" class="headerlink" title="immutablejs 是如何优化我们的代码的？"></a>immutablejs 是如何优化我们的代码的？</h3><p>前一段时间群里有小伙伴问 lucifer 我一个问题：”immutablejs 是什么？有什么用？“。我当时的回答是：immutablejs 就是 tree + sharing，解决了数据可变性带来的问题，并顺便优化了性能。今天给大家来详细解释一下这句话。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><pre><code>a = 1;
b = 2;
c = 3;
d = {
name: &quot;lucifer&quot;,
age: 17,
location: &quot;西湖&quot;,
};
e = [&quot;脑洞前端&quot;, &quot;力扣加加&quot;];</code></pre><p><img src="/img/Immutable-%E5%9B%BE1.jpg" alt="Immutable-图1" title="Immutable-图1"><br>提示：可以看出，变量名（ a，b，c，d，e ）只是内存地址的别名而已<br>由于 d 和 e 的值是引用类型，数据长度不确定，因此实际上数据区域会指向堆上的一块区域。而 a，b，c 由于长度是编译时确定的，因此可以方便地在栈上存储。<br>提示：d 和 e 的数据长度不确定， 但指针的长度是确定的，因此可以在栈上存储指针，指针指向堆上内存即可。</p>
<p>实际开发常会进行各种赋值操作，比如：</p>
<pre><code>const ca = a;
const cb = b;
const cc = c;
const cd = d;
const ce = e;</code></pre><p>经过上面的操作，此时的内存结构图：<br><img src="/img/Immutable-%E5%9B%BE2.jpg" alt="Immutable-图2" title="Immutable-图2"><br>可以看出，ca，cb，cc，cd，ce 的内存地址都变了，但是值都没变。原因在于变量名只是内存的别名而已，而赋值操作传递的是 value。<br>由于目前 JS 对象操作都是 mutable 的， 因此就有可能会发生这样的 “bug”：</p>
<pre><code>cd.name = &quot;azl397985856&quot;;
console.log(cd.name); // azl397985856
console.log(d.name); // azl397985856</code></pre><p>上面的 cd.name 原地修改了 cd 的 name 值，这会影响所有指向 ta 的引用。<br>比如有一个对象被三个指针引用，如果对象被修改了，那么三个指针都会有影响。</p>
<p><img src="/img/Immutable-%E5%9B%BE3.jpg" alt="Immutable-图3" title="Immutable-图3"><br>你可以把指针看成线程，对象看成进程资源，资源会被线程共享。 多指针就是多线程，当多个线程同时对一个对象进行读写操作就可能会有问题。<br>于是很多人的做法是 copy（shallow or deep）。这样多个指针的对象都是不同的，可以看成多进程。<br>接下来我们进行一次 copy 操作。</p>
<pre><code>const sa = a;
const sb = b;
const sc = c;
const sd = { ...d };
const se = [...e];

// 有的人还觉得不过瘾
const sxbk = JSON.parse(JSON.stringify(e));
旁观者： 为啥你代码那么多 copy 啊？
当事人： 我也不知道为啥要 copy 一下，不过这样做使我安心。</code></pre><p>此时引用类型的 value 全部发生了变化，此时内存图是这样的：<br><img src="/img/Immutable-%E5%9B%BE4.jpg" alt="Immutable-图4" title="Immutable-图4"><br>上面的 ”bug“ 成功解决。<br>提示： 如果你使用的是 shallow copy， 其内层的对象 value 是不会变化的。如果此时你对内层对象进行诸如 a.b.c 的操作，也会有”bug“。<br>完整内存图：<br><img src="/img/Immutable-%E5%9B%BE5.jpg" alt="Immutable-图5" title="Immutable-图5"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果是 shallow copy 还好， 因为你只 copy 一层，但是随着 key 的增加，性能下降还是比较明显的。<br>据测量：<br>    shallow copy 包含 1w 个 属性的对象大概要 10 ms。<br>    deep copy 一个三层的 1w 个属性的对象大概要 50 ms。<br>    数据仅供参考，大家也可以用自己的项目测量一下。而 immutablejs 可以帮助我们减少这种时间（和内存）开销，这个我们稍后会讲。<br>由于普通项目很难达到这个量级，因此基本结论是：如果你的项目对象不会很大， 完全没必要考虑诸如 immutablejs 进行优化，直接手动 copy 实现 immutable 即可。<br>如果我的项目真的很大呢？那么你可以考虑使用 immutable 库来帮你。 immutablejs 是无数 immutable 库中的一个。我们来看下 immutablejs 是如何解决这个性能难题的。</p>
<h2 id="immutablejs-是什么"><a href="#immutablejs-是什么" class="headerlink" title="immutablejs 是什么"></a>immutablejs 是什么</h2><p>使用 immutablejs 提供的 API 操作数据，每一次操作都会返回一个新的引用，效果类似 deep copy，但是性能更好。<br>开头我说了，immutablejs 就是 tree + sharing，解决了数据可变带来的问题，并顺便提供了性能。 其中这里的 tree 就是类似 trie 的一棵树。如果对 trie 不熟悉的，可以看下我之前写的一篇前缀树专题。<br>immutablejs 就是通过树实现的结构共享。举个例子：<br>    const words = [“lucif”, “luck”];<br>我根据 words 构建了一个前缀树，节点不存储数据， 数据存储在路径上。其中头节点表示的是对象的引用地址。<br><img src="/img/Immutable-%E5%9B%BE6.jpg" alt="Immutable-图6" title="Immutable-图6"></p>
<p>这样我们就将两个单词 lucif 和 luck存到了树上：<br><img src="/img/Immutable-%E5%9B%BE7.jpg" alt="Immutable-图7" title="Immutable-图6"></p>
<p>现在我想要将 lucif 改成 lucie，普通的做法是完全 copy 一份，之后修改即可。<br>    newWords = […words];<br>    newWords[1] = “lucie”;<br><img src="/img/Immutable-%E5%9B%BE8.jpg" alt="Immutable-图8" title="Immutable-图8"><br>(注意这里整棵树都是新的，你看根节点的内存地址已经变了)<br>而所谓的状态共享是：<br><img src="/img/Immutable-%E5%9B%BE9.jpg" alt="Immutable-图9" title="Immutable-图9"><br>(注意这里整棵树除了新增的一个节点， 其他都是旧的，你看根节点的内存地址没有变)<br>可以看出，我们只是增加了一个节点，并改变了一个指针而已，其他都没有变化，这就是所谓的结构共享。</p>
<h3 id="还是有问题"><a href="#还是有问题" class="headerlink" title="还是有问题"></a>还是有问题</h3><p>仔细观察会发现：使用我们的方法，会造成 words 和 newWords 引用相等（都是 1fe2ab），即 words === newWords。<br>因此我们需要沿着路径回溯到根节点，并修改沿路的所有节点（绿色部分）。在这个例子，我们仅仅少修改两个节点。但是随着树的节点增加，公共前缀也会随着增加，那时性能提升会很明显。<br><img src="/img/Immutable-%E5%9B%BE10.jpg" alt="Immutable-图10" title="Immutable-图10"><br>整个过程类似下面的动图所示：<br><img src="/img/Immutable%E5%8E%9F%E7%90%86.gif" alt="Immutable原理" title="Immutable原理"><br>这个过程非常类似线段树的更新区间信息的过程</p>
<h3 id="取舍之间"><a href="#取舍之间" class="headerlink" title="取舍之间"></a>取舍之间</h3><p>前面提到了 沿着路径回溯到根节点，并修改沿路的所有节点。由于树的总节点数是固定的，因此当树很高的时候，某一个节点的子节点数目会很少，节点的复用率会很低。想象一个极端的情况，树中所有的节点只有一个子节点，此时退化到链表，每次修改的时间复杂度为 O(P)，其中 P 为其祖先节点的个数。如果此时修改的是叶子节点，那么 P 就等于 N，其中 N 为 树的节点总数。<br>树很矮的情况，树的子节点数目会增加，因此每次回溯需要修改的指针增加。如图是有四个子节点的情况，相比于上面的两个子节点，需要多创建两个指针。<br><img src="/img/Immutable-%E5%9B%BE11.jpg" alt="Immutable-图11" title="Immutable-图11"><br>想象一种极端的情况，树只有一层。还是将 lucif 改成 lucie。我们此时只能重新建立一个全新的 lucie 节点，无法利用已有节点，此时和 deep copy 相比没有一点优化。<br><img src="/img/Immutable-%E5%9B%BE12.jpg" alt="Immutable-图12" title="Immutable-图12"><br>因此合理选择树的叉数是一个难点，绝对不是简单的二叉树就行了。这个选择往往需要做很多实验才能得出一个相对合理的值。</p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React 和 Vue 最大的区别之一就是 React 更加 “immutable”。React 更倾向于数据不可变，而 Vue 则相反。如果你恰好两个框架都使用过，应该明白我的意思。使用 immutable 的一个好处是未来的操作不会影响之前创建的对象。因此你可以很轻松地将应用的数据进行持久化，以便发送给后端做调试分析或者实现时光旅行（感谢可预测的单向数据流）。<br>结合 Redux 等状态管理框架，immutablejs 可以发挥更大的作用。这个时候，你的整个 state tree 应该是 immutablejs 对象，不需要使用普通的 JavaScript 对象，并且操作也需要使用 immutablejs 提供的 API 来进行。 并且由于有了 immutablejs，我们可以很方便的使用全等 === 判断。写 SCU 也方便多了。(SCU 是 shouldComponentUpdate 的缩写。)<br><img src="/img/Immutable-%E5%9B%BE13.jpg" alt="Immutable-图13" title="Immutable-图13"><br>通过我的几年使用经验来看，使用类似 immutablejs 的库，会使得性能有不稳定的提升。并且由于多了一个库，调试成本或多或少有所增加，并且有一定的理解和上手成本。<font color=red size=4>因此我的建议是技术咱先学着，如果项目确实需要使用，团队成员技术也可以 Cover的话，再接入也不迟，不可过早优化。</font></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于数据可变性，当多个指针指向同一个引用，其中一个指针修改了数据可能引发”不可思议“的效果。随着项目规模的增大，这种情况会更加普遍。并且由于未来的操作可能会修改之前创建的对象，因此无法获取中间某一时刻的状态，这样就缺少了中间的链路，很难进行调试 。数据不可变则是未来的操作不会影响之前创建的对象，这就减少了”不可思议“的现象，并且由于我们可以知道任何中间状态，因此调试也会变得轻松。</p>
<p>手动实现”数据不可变“可以应付大多数情况。在极端情况下，才会有性能问题。immutablejs 就是 tree + sharing，解决了数据可变带来的问题，并顺便优化了性能。它不但解决了手动 copy 的性能问题，而且可以在 $O(1)$ 的时间比较一个对象是否发生了变化。因此搭配 React 的 SCU 优化 React 应用会很香。</p>
<p>最后推荐我个人感觉不错的另外两个 immutable 库 seamless-immutable 和 Immer。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Immutable</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery</title>
    <url>/2019/07/01/FroEnd-JQuery/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>JS基础入门</title>
    <url>/2019/05/25/FroEnd-JS%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="JavaScript-概念"><a href="#JavaScript-概念" class="headerlink" title="JavaScript 概念"></a>JavaScript 概念</h2><p>JavaScript 语言由浏览器直接解析,不需要编译的脚本语言.用于读取 Html 网页对象，来操作 Html 网页。<br>JavaScript 入门篇中，我们学习了如何插入 JS、输出内容及简单的 DOM 操作，JavaScript 进阶篇让您进一步的了解 JS 的变量、数组、函数、语法、对象、事件、DOM 操作，制作简单的网页动态效果。</p>
<blockquote>
<p>注意:<br>1.JS 是区分大小写的，如：classname 和 ClassName 是不一样的。同时注意方法、属性、变量等的大小写吆。<br>2.JS 中的字符、符号等一定要在英文状态下输入吆。</p>
</blockquote>
<h2 id="JaveScript-入门基础"><a href="#JaveScript-入门基础" class="headerlink" title="JaveScript 入门基础"></a>JaveScript 入门基础</h2><h3 id="引用外部-js-文件"><a href="#引用外部-js-文件" class="headerlink" title="引用外部 js 文件"></a>引用外部 js 文件</h3><p>注意: javascript 作为一种脚本语言可以放在 html 页面中任何位置，但是浏览器解释 html 时是按先后顺序的，所以前面的 script 就先被执行。比如进行页面显示初始化的 js 必须放在 head 里面，因为初始化都要求提前进行（如给页面 body 设置 css 等）；而如果是通过事件调用执行的 function 那么对位置没什么要求的。但是我们一般放在网页的 head 或者 body 部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&quot;&#x2F;&quot; 表示根目录开始</span><br><span class="line">&quot;.&#x2F;&quot; 表示同级目录开始</span><br><span class="line">&quot;..&#x2F;&quot; 表示上一级目录开始；</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>定义变量使用关键字 var,语法如下：</p>
<pre><code>var 变量名</code></pre><p>变量名可以任意取名，但要遵循命名规则:</p>
<pre><code>1.变量必须使用字母、下划线(_)或者美元符($)开始。
2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。
3.不能使用JavaScript关键词与JavaScript保留字。</code></pre><h3 id="向-HTML-输出内容"><a href="#向-HTML-输出内容" class="headerlink" title="向 HTML 输出内容"></a>向 HTML 输出内容</h3><p>document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。</p>
<pre><code>1.输出内容用&quot;&quot;括起，直接输出&quot;&quot;号内的内容：document.write(&quot;I love JavaScript！&quot;);
2.通过变量，输出内容：var mystr=&quot;hello&quot;;document.write(mystr);
3.输出多项内容，内容之间用+号连接。var mystr=&quot;hello&quot;;document.write(mystr+&quot;123&quot;);
4.输出HTML标签，并起作用，标签使用&quot;&quot;括起来。var mystr=&quot;hello&quot;;document.write(mystr+&quot;&lt;br&gt;&quot;);</code></pre><h3 id="常用调试函数"><a href="#常用调试函数" class="headerlink" title="常用调试函数"></a>常用调试函数</h3><pre><code>1.alert(字符串或变量);
2.confirm 对话框：var boolean = confirm(str);返回true/false：
3.prompt 对话框::var context = prompt(str1, str2);返回值：点击确定按钮，文本框中的内容将作为函数返回值点击取消按钮，将返回null;str1要显示在消息对话框中的文本，不可修改;str2文本框中的内容，可以修改</code></pre><h3 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h3><p>注意： 1.新建的浏览器窗口/新建 Tab 窗口,运行结果考虑浏览器兼容问题<br>2.window 窗口里放对象相当于此窗口的全局变量</p>
<pre><code>window.open([URL], [窗口名称], [参数字符串])
例子:window.open(&apos;http://www.imooc.com&apos;,&apos;_blank&apos;,&apos;width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes&apos;);</code></pre><h3 id="关闭浏览器窗口"><a href="#关闭浏览器窗口" class="headerlink" title="关闭浏览器窗口"></a>关闭浏览器窗口</h3><pre><code>window.close();   //关闭当前窗口
&lt;窗口对象&gt;.close();   //关闭指定的窗口
//将新打的窗口对象，存储在变量mywin中mywin.close();
例子:mywin=window.open(&apos;http://www.imooc.com&apos;);</code></pre><h2 id="认识-DOM"><a href="#认识-DOM" class="headerlink" title="认识 DOM"></a>认识 DOM</h2><h3 id="DOM-节点层次图"><a href="#DOM-节点层次图" class="headerlink" title="DOM 节点层次图"></a>DOM 节点层次图</h3><p><img src="/img/DOM%E8%8A%82%E7%82%B9%E5%B1%82%E6%AC%A1%E5%9B%BE.png" alt="DOM节点层次图" title="DOM节点层次图"></p>
<p>HTML 文档可以说由节点构成的集合，三种常见的 DOM 节点:</p>
<pre><code>1. 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。
2. 文本节点:向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript、DOM、CSS等文本。
3. 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=&quot;http://www.imooc.com&quot;。</code></pre><h3 id="DOM-操作函数"><a href="#DOM-操作函数" class="headerlink" title="DOM 操作函数"></a>DOM 操作函数</h3><h4 id="通过-ID-获取元素"><a href="#通过-ID-获取元素" class="headerlink" title="通过 ID 获取元素"></a>通过 ID 获取元素</h4><p>学过 HTML/CSS 样式，都知道，网页由标签将信息组织起来，而标签的 id 属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过 id 先找到标签，然后进行操作。<br>注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。<br>var domObject = document.getElementById(“id”)</p>
<h4 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h4><p>注:innerHTML 区分大小写,改变元素内容</p>
<pre><code>Object.innerHTML
例子：Object idObject = document.getElementById(&quot;id&quot;)：
idObject.innerHTML = &quot;新内容&quot;;</code></pre><h4 id="改变-HTML-样式"><a href="#改变-HTML-样式" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h4><p><img src="/img/HTML%E6%A0%B7%E5%BC%8F.png" alt="HTML样式" title="HTML样式"></p>
<pre><code>Object.style.property=new style;
例子：mychar.style.color=&quot;red&quot;;
显示和隐藏：display属性:显示或隐藏
Object.style.display = block(none);s</code></pre><h4 id="控制类名（className-属性）"><a href="#控制类名（className-属性）" class="headerlink" title="控制类名（className 属性）"></a>控制类名（className 属性）</h4><p>className 属性设置或返回元素的 class 属性 1.获取元素的 class 属性 2.改某元素的 CSS 外观</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>JaveScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JaveScript进阶语法</title>
    <url>/2019/06/02/FroEnd-JS%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="6-种数据类型"><a href="#6-种数据类型" class="headerlink" title="6 种数据类型"></a>6 种数据类型</h3><p>Object 类型(对象)：Function,Array,Date,RegExp…<br>原始类型(5 种)：number,String,boolean,null,undefine</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>如果存在隐式转换,转换时可能存在临时变量</p>
<h4 id="与"><a href="#与" class="headerlink" title="+ 与 -"></a>+ 与 -</h4><p>+：字符串+数字–&gt;返回字符串 -：字符串-数字–&gt;返回数字</p>
<h4 id="与-绝对等号"><a href="#与-绝对等号" class="headerlink" title="== 与 ===(绝对等号)"></a>== 与 ===(绝对等号)</h4><p>使用 == 返回 true:两边类型自动发生隐式转换,转换完成再比较</p>
<p>“123” == 123 ：数字转字符串<br>0 == false：0 转为 false<br>null == undefined<br>new Object() == new Object():<br>[1,2] == [1,2]</p>
<p>使用 ===:两边类型不发生隐式转换，直接比较两边类型以及内容<br>特殊：NaN 与 NaN 自身比较都不相等<br>判断对象是否相等：JS 是使用引用判断,两个空对象比较也不是相同的对象</p>
<h3 id="5-种检测类型"><a href="#5-种检测类型" class="headerlink" title="5 种检测类型"></a>5 种检测类型</h3><pre><code>1.typeof :适合基本类型判断 注：typeof null === &quot;object&quot;
2.instanceof : 适合判断对象 [1,2] instanceof Array//不同iframe与window判断失效
3.Object.prototype.toString :遇到null与undefined失效(IE678返回object)
4.constructor :
5.duck type :取对象的特征：如数组类型取length或者push这些函数方法</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象中包含一系列属性,这些属性是无序的。每个属性都有一个字符串 key 和对应的 value。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code>1.空对象添加属性:var obj = new Object();(var obj={};)obj.x =1;obj.y=2;
2.函数式对象声明:function obj(){x=1,y=2};默认带有prototype指向原型链（类似继承的父类）的对象属性</code></pre><h4 id="new-原型链-创建对象"><a href="#new-原型链-创建对象" class="headerlink" title="(new/原型链)创建对象"></a>(new/原型链)创建对象</h4><p>function foo(){}定义一个函数对象 foo,其内部默认包含一个 prototype(原型链)属性,foo.prototype 为一个对象(原型链指向的对象)</p>
<p><img src="/img/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链" title="原型链"></p>
<pre><code>1.当赋值时，会直接给当前对象添加属性；//A.原型链上没有对应属性set或get方法存在,否则当前属性不会添加到当前对象；B.原型链指向对应属性不可操作，需要用定义对象属性标签的方法来给这个对象添加属性(见下面A/B两图)
2.delete可以删除当前对象的属性,而不会删原型链上的属性
//obj.z是指向原型链得,如果obj定义返回this.z,那this向上查找指向原型链对象
3.读取属性值时,如果当前对象没有该属性就向上(原型链)查找；
4.遍历方法in：包括当前对象以及原型链 或Object.keys(对象)遍历对象所有可枚举属性
5.obj.hasOwnProperty(&apos;w&apos;):只判断当前对象中是否存在&apos;w&apos;属性</code></pre><p>A.原型链上没有对应属性 set 或 get 方法存在,也需要给当前对象添加一样属性<br><img src="/img/set%E6%88%96get%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%85%B3%E7%B3%BB.png" alt="set或get与原型链关系" title="set或get与原型链关系"></p>
<p>B.原型链指向对应属性不可操作,也需要给当前对象添加一样属性<br><img src="/img/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%8F%AF%E6%93%8D%E4%BD%9C.png" alt="原型链属性不可操作" title="原型链属性不可操作"></p>
<h4 id="Object-create-创建对象"><a href="#Object-create-创建对象" class="headerlink" title="Object.create 创建对象"></a>Object.create 创建对象</h4><p><img src="/img/create%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.png" alt="create方式创建对象" title="create方式创建对象"></p>
<pre><code>注:obj的原型链是指向使用create时的对象{x:1}(Create就是为obj定义指向的原型链对象):obj可以使用Object上的toString方法
为null对象时，obj指向null对象且没有向上原型链使用不了toString方法,因此可以使用此法区分？？？？？？？？？？？？？？？？？？</code></pre><h4 id="控制对象属性的标签"><a href="#控制对象属性的标签" class="headerlink" title="控制对象属性的标签"></a>控制对象属性的标签</h4><p><img src="/img/%E5%B1%9E%E6%80%A7%E6%A0%87%E7%AD%BE.png" alt="属性标签" title="属性标签"></p>
<p>属性访问权限的控制的属性标签：writable(控制是否可写),enumerable(设置遍历是否被读到),configuralbe(控制是否被删除),value,get/set<br>获取某个对象里的属性所有标签对象：</p>
<pre><code>var descriptor =Object.getOwnPropertyDescriptor(Object,&apos;prototype&apos;);
descriptor.configurable;//false 不允许删除</code></pre><p>设置对象某个属性标签<br><img src="/img/%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%A0%87%E7%AD%BE.png" alt="定义对象属性标签" title="定义对象属性标签"></p>
<p>属性标签组合作用：<br><img src="/img/%E5%B1%9E%E6%80%A7%E6%A0%87%E7%AD%BE%E7%BB%84%E5%90%88%E4%BD%9C%E7%94%A8.png" alt="属性标签组合作用" title="属性标签组合作用"></p>
<h4 id="对象标签"><a href="#对象标签" class="headerlink" title="对象标签"></a>对象标签</h4><p>1.原型链标签；获取类的原型链类:var pro = obj.<em>proto</em>;<br>2.class 标签：</p>
<pre><code>var toString = Object.prototype.toString;
function getType(o){return toString.call(o).slice(8,-1);};//slice截取方法</code></pre><p>3.extensible 标签</p>
<pre><code>var obj = {x : 1, y : 2};
Object.isExtensible(obj); //true是否可以继承
Object.preventExtensions(obj);//阻止继承
Object.isExtensible(obj); // false
obj.z = 1;
obj.z; // undefined, add new property failed
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: true}

Object.seal(obj);//阻止扩展且不可修改:在preventExtensions基础上防止删除
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: false}
Object.isSealed(obj); // true

Object.freeze(obj);//不可写,不可改,不可删
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: false, enumerable: true, configurable: false}
Object.isFrozen(obj); // true</code></pre><p>4.序列化</p>
<pre><code>var obj = {x : 1, y : true, z : [1, 2, 3], nullVal : null};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null}&quot;

1.//对象转Json:undefined转化后不出现,NaN转化后变为null,注意时间格式
obj = {val : undefined, a : NaN, b : Infinity, c : new Date()};
JSON.stringify(obj); // &quot;{&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:&quot;2015-01-20T14:15:43.910Z&quot;}&quot;

2.//json转对象
obj = JSON.parse(&apos;{&quot;x&quot; : 1}&apos;);
obj.x; // 1

3.自定义对象转json格式
var obj = {x : 1,y : 2,
    o : {o1 : 1,o2 : 2,
            toJSON : function () {
                return this.o1 + this.o2;
            }
        }
};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3}&quot;</code></pre><h2 id="表达式与运算符"><a href="#表达式与运算符" class="headerlink" title="表达式与运算符"></a>表达式与运算符</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><pre><code>表达式是一种JS短语,可以使JS解释器用来产生一个值。</code></pre><p>1.原始表达式：</p>
<pre><code>常量，直接数值量，关键字，变量</code></pre><p>2.初始化表达式：</p>
<pre><code>数组初始化：new Array(1,,,2) === [1,undefined,undefined,2];
对象初始化：new Obeject()</code></pre><p>3.函数表达式:</p>
<p>常用：function name(){};//函数声明,不限制调用位置<br>常用：var fun = function name(){};//函数表达式,必须在使用之前<br>特殊：(function name(){};)();</p>
<p>4.属性访问表达式：</p>
<p>var obj={x:1,y:2};<br> 访问属性：obj[‘x’] === obj.x</p>
<p>5.函数调用表达式:</p>
<p>使用函数名调用：func();</p>
<p>6.对象创建表达式：</p>
<p>对象构造器创建:new Func(1,2);<br>new Object();</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>1.一元运算符:+num 2.二元运算符:a+b 3.三元运算符：c?a:b</p>
<p>特殊运算符： 1.逗号运算符：逗号隔开表达式,从左到右依次计算表达式的值，取最右边的结果为运算结果</p>
<pre><code>var V=(1,2,3);//V =3;</code></pre><p>2.delete 运算符:删除对象里的属性</p>
<pre><code>var obj = {x:1};
delete obj.x;//返回true的含义：如果对象里有x属性就删除;或者对象本身不存在x；
在IE9后存在对象定义属性值defineProperty标签
//定义为fasle就不能用delete
Object.defineProperty(obj,&apos;x&apos;,{configurable:false,value:1});</code></pre><p>3.in 运算符</p>
<pre><code>window添加属性：(全局变量)
winddow.x =1 ;
//判断为true/false是否有这样的key
var m = &apos;x&apos; in window;</code></pre><p>4.new 运算符</p>
<pre><code>function Foo(){}//定义对象
Foo.prototype.x=1;//添加x在对象原型链上
var obj=new Foo();
var value = obj.x;//1
obj.hasOwnProperty(&apos;x&apos;);//false,判断对象本身属性
obj._proto_.hasOwnProperty(&apos;x&apos;)//true,判断对象原型链上的属性</code></pre><p>注：对象属性分本身定义属性与原型链上属性(属于原始类(最顶端)的属性类)</p>
<p>5.this(window 浏览器/对象本身)</p>
<pre><code>var obj= {
    func:function(){
        return this;
    }
}
var va = obj.func;//返回obj对象本身(this)</code></pre><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>1.块级没有作用域</p>
<pre><code>for(var i=0,,){}
var b = i;//能拿到i的值

function foo(){
    var a =1;
}
foo();
console.log(typeof a);//undifined,取不到值</code></pre><p>2.var</p>
<pre><code>var a=b=1;//b被隐式创建全局变量
function foo(){
    var a=b=1;
}

foo();
console.log(typeof a);//&apos;undefined&apos;
console.log(typeof b);//&apos;number&apos;</code></pre><p>3.for…in</p>
<pre><code>var p
var obj={x:1,y:2}
for(p in obj){}
1.顺序不确定
2.如果遍历对象的属性有enumable为false时不会遍历到
3.for in 受原型链影响,向上访问对象的原型链</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h3><p>1.定义数组:动态的，无需指定大小</p>
<pre><code>var arr = new Array[10];//只有一个参数为数组长度
var arr = new Array[1,2];//arr = [1,2]</code></pre><p>2.操作数组方法<br>arr.push(‘2’);//数组最后追加,数组长度+1<br>arr.pop(); //数组最后一位被删,且数组长度-1<br>arr.unshift(0);//数组前面追加,数组长度+1<br>arr.shift(); //数组前面追加,数组长度-1</p>
<p>3.遍历数组</p>
<pre><code>for(var i = 0;..)
设置原型链：Array.prototype.x
for(p in arr)//同样遍历原型链,通过arr.hasOwnProperty(i)判断</code></pre><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>创建出来的数组都会继承数组原型链(Array.prototype)上的方法:</p>
<p>1.数组转字符串(原数组不改变):var arr = [1, 2, 3];<br>arr.join(); // “1,2,3”；默认以逗号(,)将数组拼接为字符串<br>arr.join(“_“); // “1_2_3” 2.反转(原数组改变)：arr.reverse(); // [3, 2, 1] 3.排序(原数组改变):arr = [13, 24, 51, 3];<br>arr.sort(); // [13, 24, 3, 51]<br>自定义排序方法:arr.sort(function(a, b) {<br>return a - b;<br>}); // [3, 13, 24, 51] 4.合并(原数组不改变):var arr = [1, 2, 3];<br>arr. concat(4, 5); // [1, 2, 3, 4, 5] 5.返回部分数组(原数组不改变):var arr = [1, 2, 3, 4, 5];<br>arr.slice(1, 3); //(1, 3)左闭右开截取数组 [2, 3]<br>arr.slice(-4, -3); // [2] 6.返回部分数组(原数组改变):var arr = [1, 2, 3, 4, 5];<br>arr.splice(2); // returns [3, 4, 5] arr; // [1, 2];<br>arr.splice(2, 2); // returns [3, 4] arr; // [1, 2, 5];<br>arr.splice(1, 1, ‘a’, ‘b’); // returns [2] arr; // [1, “a”, “b”, 3, 4, 5]<br>7.for each 遍历数组：<br>var arr = [1, 2, 3, 4, 5];<br>arr.forEach(function(x, index, a){<br>//x 为必需元素,index 为可选数组下标,a 为可选当前元素所属的数组对象<br>console.log(x + ‘|’ + index + ‘|’ + (a === arr));<br>}); 8.隐射(原数组不改变)：var arr = [1, 2, 3];<br>arr.map(function(x) {<br>//x 为遍历数组的元素<br>return x + 10;<br>}); // [11, 12, 13] 9.过滤(原数组不改变)：var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br>arr.filter(function(x, index) {<br>//x 为元素标签,index 为元素下标<br>return index % 3 === 0 || x &gt;= 8;<br>}); // returns [1, 4, 7, 8, 9, 10] 10.数组判断:var arr = [1, 2, 3, 4, 5];<br>//数组每一个元素都满足返回 true(类似与条件)<br>arr.every(function(x) {<br>return x &lt; 10;<br>}); // true<br>//存在一个满足条件就返回 true(类似或条件)<br>arr.some(function(x) {<br>return x === 3;<br>}); // true 11.累加器(原数组不改变)：var arr = [1, 2, 3];<br>//x=1,y=2,返回值作为下次 x 的值 3，y=3,依次累加<br>var sum = arr.reduce(function(x, y) {<br>return x + y<br>}); // 6 12.检索:arr.indexOf(a,b)//返回符合满足条件的元素下标<br>a 为检索的元素,b 为检索下标开始位置 13.判断数组<br>[] instanceof Array; // true<br>({}).toString.apply([]) === ‘[object Array]’; // true<br>[].constructor === Array; // true</p>
<h2 id="函数及其作用域"><a href="#函数及其作用域" class="headerlink" title="函数及其作用域"></a>函数及其作用域</h2><p>函数既是对象也是函数,称为函数对象<br>函数性质:可以必定一次后,被执行和多次调用;<br>对象性质:Js 中得函数为函数对象;</p>
<h3 id="函数声明："><a href="#函数声明：" class="headerlink" title="函数声明："></a>函数声明：</h3><pre><code>函数声明被前置：与调用位置无关(var 声明后作用一样)
//关键字 函数名(形参){函数体逻辑}
function add(a,b){}
调用方式:
    1.定义函数后直接调用:methodName();
    2.对象内部得函数,通过对象调用:obj.methodName();
    3.构造器调用:new methodName();
    4.call/apply/bind:
        method.call(obj,...);
        method.apply(boj,[argus]);
        method.bind(obj);</code></pre><h3 id="函数声明与表达式区别"><a href="#函数声明与表达式区别" class="headerlink" title="函数声明与表达式区别"></a>函数声明与表达式区别</h3><pre><code>1.//少用命名函数表达式(与调用位置有关)且会存在兼容性问题
//含有函数名
var add = function foo(a,b){};
调用方式为:add(a,b);
alert(add === foo)//(IE9+都不能通过函数名调用,函数对象域外访问不到)
2.//函数表达式(无函数名定义后赋值给变量):与调用位置有关,理解为一个表达式子:
var add = function (a,b){};
注:1与2调用方式为:函数变量名加括号(本质是函数得一个代替名字,括号为了传入参数,这样就跟一般函数调用一样)
    add看为函数变量名,有参调用:add(a,b);无参调用:add();//有些视频解释理解为上括号代表立即执行
3.//立即执行,(funName)(a,b)后面括号代表形参(传参或者不传)
    (funName):括号包裹函数声明类似一个临时函数名;
    (a,b)代表传入参数,(funName)(a,b)这样就跟一般函数调用一样)
(function add(a,b){return a+b;})(1,2);//返回3
4.//作为对象返回
return function(){};</code></pre><h3 id="函数构造器"><a href="#函数构造器" class="headerlink" title="函数构造器"></a>函数构造器</h3><pre><code>函数构造器:New Function()或Fucntion(),可以访问全局不能访问与自己同域的局部变量
//(存在作用域问题,少用)形参与函数体都是在括号内
1.new Function (&apos;a&apos;,&apos;b&apos;,&apos;return a+b;&apos;);
//可以立即执行：使用函数构造器构造后,使用括号立即执行;
    new Function ()：代表生产一个函数对象临时变量名；
    new Function ()()后面括号是形参；new Function ()()这样就跟一般函数调用一样
2.new Function (&apos;a&apos;,&apos;b&apos;,&apos;return a+b;&apos;)();等价于add(1,2);
注:跟上面立即执行差别在：上面括号内是函数声明,这个是函数对象；</code></pre><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="全局的-this-为-window-浏览器"><a href="#全局的-this-为-window-浏览器" class="headerlink" title="全局的 this 为 window(浏览器)"></a>全局的 this 为 window(浏览器)</h4><pre><code>this.a=33;//(window.a === this.a)</code></pre><h4 id="一般函数返回-this-对象为-window-对象-浏览器"><a href="#一般函数返回-this-对象为-window-对象-浏览器" class="headerlink" title="一般函数返回 this 对象为 window 对象(浏览器)"></a>一般函数返回 this 对象为 window 对象(浏览器)</h4><pre><code>//为将函数绑定给对象，则单独调用函数,函数中this指向为window
function f(){return this;}//(f() === window)</code></pre><h4 id="方法-包括-get-set-里指向对象的-this"><a href="#方法-包括-get-set-里指向对象的-this" class="headerlink" title="方法(包括 get/set)里指向对象的 this"></a>方法(包括 get/set)里指向对象的 this</h4><pre><code>//在对象内部定义的函数,函数体内this指向当前调用对象
var o={prop:37,
    f:function(){
        return this.prop;//指向当前调用对象o的prop属性
    }};

var o={prop:37};
function fun(){
//该函数自定义没绑定对象;如果单独调用fun()函数,this返回的是window对象
    return this.prop;}
//将fun()函数绑定给o对象
o.f=fun;//此时调用o.f()则this返回o对象</code></pre><h4 id="对象原型链上的-this"><a href="#对象原型链上的-this" class="headerlink" title="对象原型链上的 this"></a>对象原型链上的 this</h4><pre><code>//那个对象调用原型链，原型链this就指向那个对象
var o={f:function(){return this.a+this.b}}
var p= Object.create(o);//p原型链指向o对象
p.a = 1;p.b = 4;
p.f();//原型链上this指向当前o对象;</code></pre><h4 id="构造器-this"><a href="#构造器-this" class="headerlink" title="构造器 this"></a>构造器 this</h4><pre><code>//注：见【(new/原型链)创建对象】关于对象内部属性如何指向原型链
//(优先查找本对象属性,如果不存在才会指向原型链)
function MyClass(){
    this.a = 37;
}
//当声明函数构造器没有返回值或返回基本类型;查找对象属性时该对象没有得属性会(this)指向Myclass.protype对象查找
var o = new MyClass();//o对象没有得属性,this指向原型链对象MyClass.protoType里查找
console.log(o.a);

function C2(){
     this.a = 37;
     return {a:38};
}
//当声明函数构造器返回对象,this指向返回对象;
o = new C2();
console.log(o.a); //38</code></pre><h4 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h4><pre><code>function add(c,d){
    return this.a+this.b+c+d;
}
var obj={a:1,b:3};

//call(对象,参数(匹配调用函数的个数)...));apply(对象,[参数(可选)...]):
//函数主动引用对象属性：this指向当前传入的对象;
//理解为obj对象里临时添加add方法后,add.call调用唤醒(add.apply申请调用)临时对象里的add方法
add.call(obj,5,7);//1+3+5+7=16
add.apply(obj,[10,20]);//1+3+10+20=34
好处:打印一些无法指定的对象
function bar(){
    //通过Object.prototype打印this所指对象
    console.log(Object.prototype.toString.call(this));
}
bar.call(1)//&quot;[object Number]&quot;

//bind可以将某方法与传入对象绑定,返回构成新的对象
//将函数内所有this锁定为bind传入的对象上,无法改变
var g=add.bind(obj);
var o = {a:9;b:9;add:add();g:g()}
console.log(o.add(),o.g());//9+9,1+3

call/apply方法传入null/undefined对象
add.apply(null);//this全局对象window
add.apply(undefined);//this全局对象window

bind与call/apply区别：
bind绑定对象后,返回构成新的对象,重复使用新对象;
而call/apply只能临时使用</code></pre><h3 id="函数属性-amp-amp-arguments"><a href="#函数属性-amp-amp-arguments" class="headerlink" title="函数属性 &amp;&amp; arguments"></a>函数属性 &amp;&amp; arguments</h3><pre><code>1.内置调用函数属性的函数
function a(){c,d,z};
函数名：a.name;//a
函数参数个数:a.length;//3
内置的arguments数组对象:(只有调用时传了值的才是arguments的长度)
arguments[0]//c,arguments[1]//d;
如果z不传值arguments[2]为undfined

2.bind后this指向例子：
this.x =9;//设置全局对象
var module ={
    x:81,
    getX:function(){return this.x;}
}
module.getX();//81
将函数对象module.getX 赋值给我变量getX(保存了对象引用)
//变量getXX直接指向了module.getX函数对象,而变量getXX此时this指向了全局对象window,而不是module对象
var getXX=module.getX;
getXX();//9

//getXX函数对象变量绑定给module对象,getXX里得this指向module对象
var boundGet= getXX.bind(module);
boundGex();//81

3.bind 函数颗粒化功能
function add(a,b,c){
    reutrn a+b+c;
}
//为了线将某一固定绑定到默认参数上如a=100；这样后面调用只要传入bc就可以
var func = add.bind(null,100);//this指向全局window,a=100;
func(1,2);//103

4.bind后再new
function foo(){
    this.b=100;
    return this.a;
}

var func = foo.bind({a:1});
func();//101
new func();//1
//new忽略已经bind得对象,this不指向bind对象,而是指向foo.prototype
//this.b为指向原型链的对象添加的属性,new时如果不是返回对象而是属性的化,只能返回this对象;因此这里返回this(指向原型链的对象{b:100})
new func();//返回对象{b:100}</code></pre><h3 id="闭包现象"><a href="#闭包现象" class="headerlink" title="闭包现象"></a>闭包现象</h3><pre><code>function outer(){
    var localVal =30;
    return function(){
        return localVal;
    }
}
//局部变量localVal依然还能被访问
var func =outer();
func()//30
应用：AJAX请求,回调函数可以使用外层变量;对象的get方法开发访问对象内部属性
缺点:循环引用可能导致内存泄漏/空间不足/性能消耗</code></pre><h2 id="对象-OOP"><a href="#对象-OOP" class="headerlink" title="对象(OOP)"></a>对象(OOP)</h2>]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>JaveScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JsonSchema</title>
    <url>/2019/01/03/FroEnd-JsonSchema/</url>
    <content><![CDATA[<h2 id="JsonSchema"><a href="#JsonSchema" class="headerlink" title="JsonSchema"></a>JsonSchema</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单说，Json Schema 其实就是一个标准的 Json 串，它以一个 Json 串来描述我们需要的数据规范，并且支持注释以及验证 Json 文档，即我们可以用 Json Schema 来验证所给的 Json 串是否满足我们需要的数据格式规范。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>同样能用来表示数据的还有一种格式 XML，为什么 Json Schema 偏偏要用 Json 来进行表示数据呢？比如，假设我们需要描述一个班级的两个人：</p>
<p>对于 XML：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;name&gt;实验1班&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;no&gt;1801&lt;&#x2F;no&gt;</span><br><span class="line">    &lt;students&gt;</span><br><span class="line">        &lt;student&gt;</span><br><span class="line">            &lt;name&gt;张三&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;sex&gt;女&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;&#x2F;student&gt;</span><br><span class="line">        &lt;student&gt;</span><br><span class="line">            &lt;name&gt;李四&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;sex&gt;男&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;&#x2F;students&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>

<p>使用 Json：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;class&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;实验1班&quot;,</span><br><span class="line">        &quot;no&quot;: &quot;1801&quot;,</span><br><span class="line">        &quot;students&quot;: &#123;</span><br><span class="line">        &quot;student&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">            &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">            &quot;sex&quot;: &quot;女&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">            &quot;name&quot;: &quot;李四&quot;,</span><br><span class="line">            &quot;sex&quot;: &quot;男&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为层级比较少，层级再多之后，Json 的优势立马就显现出来了。Json Schema 在我们平时的工作中最常用的有两个，一个就是上面说的用于验证 Json 串的合法性；另一个就是用于定义我们的 API，定义好 API 后，我们可以直接用工具生成我们的 API，这样利于我们对 API 的维护。</p>
<h3 id="JsonSchema格式"><a href="#JsonSchema格式" class="headerlink" title="JsonSchema格式"></a>JsonSchema格式</h3><p>比如，我们定义的 Json Schema 为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;$schema&quot;: &quot;http:&#x2F;&#x2F;json-schema.org&#x2F;draft-04&#x2F;schema#&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;Product&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;A product from Acme&#39;s catalog&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &#123;</span><br><span class="line">            &quot;description&quot;: &quot;The unique identifier for a product&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">            &quot;description&quot;: &quot;Name of the product&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;string&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;price&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">            &quot;minimum&quot;: 0,</span><br><span class="line">            &quot;exclusiveMinimum&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;required&quot;: [&quot;id&quot;, &quot;name&quot;, &quot;price&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述 Json Schema 中最上面的<br>$shcema: 是一个关键字，它表示我们所定义的 Schema 和<a href="http://json-schema.org/draft-04/schema#" target="_blank" rel="noopener">Json Schema 的 v4 规范</a>是一致的<br>title: 指的是标题<br>description: 用于描述我们所定义的 Schema，上述表明我们定义的是一个来自 Acme 目录的商品。<br>type: 表示我们定义的是一个 object 对象。<br>properties: 中就是 Schema 的属性了，这里面的是核心。我们可以看到该 Schema 一共有三个属性，分别是 id(integer), name(string), prince(number)。<br>required:表明properties三个属性都是必须的。</p>
<h2 id="JsonSchema转换为JavaBean"><a href="#JsonSchema转换为JavaBean" class="headerlink" title="JsonSchema转换为JavaBean"></a>JsonSchema转换为JavaBean</h2><p>其实，使用我们上面的 Json Schema 便能进行API的定义了，只不过是定义 API 的话可能还需要更多的支持。比如，对于 Java，我们需要能实现 extend 等关键字的支持，还需要能进行枚举 enum 类型等的定义。这里只简单使用上述的内容显然不够了，我们还需要扩充一些关键字的使用。</p>
<p>目前，大家使用最多的将 Json Schema 转换为 Java Bean 的一个库是 <a href="https://github.com/joelittlejohn/jsonschema2pojo" target="_blank" rel="noopener">jsonschema2pojo</a>，后面我将依托这个库支持的内容对 Json Schema 的格式进行深入解析，此库支持的也是比较通用的。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>MPA与SPA及SEO,SSR问题解决</title>
    <url>/2020/08/14/FroEnd-MPA%E4%B8%8ESPA%E5%8F%8ASEO,SSR%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="MPA-Multi-page-Application-与SPA-Single-page-Application"><a href="#MPA-Multi-page-Application-与SPA-Single-page-Application" class="headerlink" title="MPA(Multi-page Application)与SPA(Single-page Application)"></a>MPA(Multi-page Application)与SPA(Single-page Application)</h2><p>MPA (Multi-page Application):传统JS,JQ,JSP<br>多页面应用:<br>    优点：首屏加载快，只需要当前的一个页面内容;SEO(Search Engine Optimization)效果好,便于搜索引擎爬虫爬数据<br>    缺点：每一次url变化,要重新加载要切换到服务器重新返回不同的页面，所以导致每次页面切换不流畅;页面间传递数据,依赖URL、cookie或者localStorge, 实现麻烦     </p>
<p>SPA (Single-page Application):<br>单页面应用:VUE,React,Angular<br>    spa开发由于是只有一个页面，所以其内部是组件化的,各模块之间的跳转其实就是组件之间的切换<br>    优点：由于首次加载时已经把所有的组件都加载运行过，所以之后的组件切换就非常流畅,前后端分离,减轻服务器压力,增强用户体验,<br>　  缺点：SEO(Search Engine Optimization)效果差,由于是组件间化开发，每个功能模块都是必不可少的，所以在项目的第一次运行中，需要下载加载各组件，所以第一次加载就相对比较耗时，这就是spa开发中首屏加载过慢的主要原因<br>    SEO优化:Vue实现预渲染的方式是通过prerender-spa-plugin插件实现:npm install –save prerender-spa-plugin</p>
<h3 id="SSR-Server-Side-Render-服务器端渲染"><a href="#SSR-Server-Side-Render-服务器端渲染" class="headerlink" title="SSR(Server Side Render)服务器端渲染"></a>SSR(Server Side Render)服务器端渲染</h3><h4 id="何会出现SSR"><a href="#何会出现SSR" class="headerlink" title="何会出现SSR?"></a>何会出现SSR?</h4><h5 id="解决SEO问题："><a href="#解决SEO问题：" class="headerlink" title="解决SEO问题："></a>解决SEO问题：</h5><p>　　纯前端的项目，由于需要页面加载完成后再去拉取数据进行渲染，大部分搜索引擎没法读取页面内容。特别是SPA项目，更是无法读取到每个路由页面的页面Tite。</p>
<h5 id="首屏渲染速度："><a href="#首屏渲染速度：" class="headerlink" title="首屏渲染速度："></a>首屏渲染速度：</h5><p>　　纯前端项目，先要加载Js，再通过Js去加载数据，这两部分网络传输都需要时间，所以难以避免出现页面白屏时间，体验不友好。</p>
<h3 id="SSR带来哪些挑战？"><a href="#SSR带来哪些挑战？" class="headerlink" title="SSR带来哪些挑战？"></a>SSR带来哪些挑战？</h3><p>多维护一层server：<br>    要用SSR，你就得准备一个node server（express，koa…），这就不可避免地加大了性能、运维等挑战。<br>代码兼容：<br>    浏览器里的好多代码在server side render过程中是会报错的，所以你得花很多精力去处理其中的兼容性。<br>技术限制：<br>　　虽然现在Vue、React 等流行框架都出台了相应的SSR解决方案，但如果你不用这些框架怎么呢，自己撸一套？还有就算用这些解决方案，难免也有些限制让人束手束脚，踩坑不可避免。<br>终上所述，SSR很有用不错，但也不可避免地加大了很多开发和维护的成本</p>
<h2 id="不用SSR如何解决SEO问题？"><a href="#不用SSR如何解决SEO问题？" class="headerlink" title="不用SSR如何解决SEO问题？"></a>不用SSR如何解决SEO问题？</h2><p>注:用Prerender：(这里不是指webpack的那个prerender插件!)<br><a href="https://github.com/prerender/prerender" target="_blank" rel="noopener">一个开源prerender项目的链接</a></p>
<h3 id="具体的思路就是："><a href="#具体的思路就是：" class="headerlink" title="具体的思路就是："></a>具体的思路就是：</h3><p>　　1.部署一个独立的prerender的server（上面贴出来的，现成的只需要配置、部署一下），这个独立的server就是专门为各种爬虫做预渲染，可以被多个项目共用。<br>　　2.在你的前端项目的nginx上加一段配置，通过useragent检测，如果是爬虫，就将地址代理到这个server，这个server会将页面渲染好了返回给爬虫。如果前端项目是通过express等渲染，也有prerender相应的中间件代理到这个server。只需要部署一个prerender server，然后所有的前端项目都可以用它！<br>注：这个prerender开源项目以前使用 phantomjs，后面用 chrome 的无头浏览器改写，当然牛逼的人自己撸一个也不是很麻烦。</p>
<h2 id="解决首屏渲染问题"><a href="#解决首屏渲染问题" class="headerlink" title="解决首屏渲染问题"></a>解决首屏渲染问题</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>单独搭一个前端渲染 server，但是这个server其实不必要SSR那么复杂<br>    用koa写一个node server<br>    server 创建一个路由做两件事：把页面返回给浏览器、把页面对应的初始化JSON数据放在页面上一起返回。<br>    页面直接用JSON数据渲染。<br>但是这种方法还是要多维护一层server，不是很推荐，所有推荐后面的这种方法</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>通过js的方式初始化数据<br>后端写一个接口，专门用来初始化页面数据(<code>api/init-page.js?page=xx&amp;a=xx&amp;b=xx</code>), 但是接口返回的内容是js的方式：<code>window.initData={}</code>。<br>前端进入页面的时候动态加载初始化数据js：<code>var page = &#39;a&#39;; document.write(&#39;&lt;script src=&quot;api/init-page.js?page=&#39; + page +&#39;&gt;&lt;/script&gt;&#39;)</code>。<br>这样，页面加载完成的时候，初始化数据也加载完成，可server段渲染差不多。和调接口的区别：html文档头部加载出来之后即开始调用数据，数据出来之后才会渲染页面，类似服务端渲染<code>页面加载中</code>的过程。</p>
<p>###　首屏渲染时间对比：<br>服务端渲染：请求发送时间 + 服务器渲染时间 + 页面返回时间。<br>通过js的方式初始化数据：请求发送时间 +页面返回时间 + js加载时间。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>SEO</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Router</title>
    <url>/2020/08/16/FroEnd-React-Router/</url>
    <content><![CDATA[<h2 id="Rounter"><a href="#Rounter" class="headerlink" title="Rounter"></a>Rounter</h2><h3 id="Router库"><a href="#Router库" class="headerlink" title="Router库"></a>Router库</h3><pre><code>react-Router
react-Router-dom
react-Router-active</code></pre><h3 id="react-Router-5种-路由"><a href="#react-Router-5种-路由" class="headerlink" title="react-Router(5种)路由"></a>react-Router(5种)路由</h3><pre><code>&lt;BrowerRouter&gt;:最新浏览器常用模式
&lt;HashRouter&gt;:路径前加入#号成为一个哈希值,Hash好处是支持一些旧版本,而且不会因为刷新找不到对应路径
&lt;MemoryRouter&gt;:不存储history,所有路径保存在内存里,不能前进和后退,因为地址栏没有发生变化
&lt;NativeRouter&gt;:多用于移动端开发,经常配合ReactNative使用
&lt;StaticRouter&gt;:设置静态路由,需要和后台服务器配合设置,比如设置服务器端染时使用
web常用web项目组件:包含&lt;BrowerRouter&gt; 与 &lt;HashRouter&gt;</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a><BrowerRouter></h4><pre><code>基于HTML5 History API 实现(pushState,replaceState等)</code></pre><p>　　需要Web服务器额外配置:在服务器端设置返回首页配置，防止用户直接输入不同url回车,这样后端请求返回对应路径的html,如果没有设置首页就会返回404;</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a><HashRouter></h4><pre><code>使用url的#/xxxx的hash部分作为路由信息
主要兼容老版本浏览器</code></pre><h2 id="路由匹配规则"><a href="#路由匹配规则" class="headerlink" title="路由匹配规则"></a>路由匹配规则</h2><p>   路由匹配规则:遍历每一个router,匹配成功都会宣称出来组件</p>
<h3 id="约束匹配规则"><a href="#约束匹配规则" class="headerlink" title="约束匹配规则"></a>约束匹配规则</h3><pre><code>&lt;switch&gt;组件:匹配到一个就不再匹配,类似switch语法，把根路径&quot;/&quot;放在最后,类似默认跳转路径
Router的exact属性:表示与path的值完全匹配才渲染该组件</code></pre><h3 id="Router属性"><a href="#Router属性" class="headerlink" title="Router属性"></a>Router属性</h3><pre><code>path属性:
    定义字符串固定路径：localhost:8080/user
    定义变量路径：localhost:8080/user/:user(:为变量标识符,user为变量)
    可以通过const {match} = props; const uservalue = match.params.user(变量名)获取
match属性:在下一级属性对象里props.match，获取上一级路径信息为match.path,match.params.XXX获取上一级路径里的变量值</code></pre><h2 id="Router里组件渲染方式区别"><a href="#Router里组件渲染方式区别" class="headerlink" title="Router里组件渲染方式区别"></a>Router里组件渲染方式区别</h2><p>component渲染方式区别：</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a><Rounter component></h3><pre><code>&lt;Rounter  path=&apos;/act&apos; component={Home}/&gt;
&lt;Rounter path=&apos;/act&apos; component ={()=&gt;&lt;Home/&gt;}/&gt;:
　　　此方式每一次render调用都会生成新的内联函数赋值给component,虽然每一次生成联函数值一样，但是新函数，在内存地址都是新的(类似多次调用函数返回一个函数地址,每一次都是不一样),导致Home组件都要先卸载再重新挂载(造成不必要内存开销),造成组件内部状态丢失不能共享.</code></pre><h3 id="推荐"><a href="#推荐" class="headerlink" title="(推荐)"></a><Rounter render>(推荐)</h3><pre><code>&lt;Rounter  path=&apos;/act&apos; render={(props) =&gt; &lt;Home (...props)/&gt;}/&gt;:
     防止组件状态丢失,可以共享状态,还可以传递其他属性,</code></pre><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><Rounter children></h3><pre><code> &lt;Rounter path=&apos;/act&apos; children={(props) =&gt; &lt;div&gt; props.mathc?&apos;active&apos;:&apos;inactive&apos;}/&gt;&lt;/div&gt;:
与render区别在于,props里含有match属性,而且不管这个路径Router有没有匹配成功都会渲染children组件,区别再于match只有匹配到当前Router才有属性</code></pre>]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>React简单入门</title>
    <url>/2019/09/08/FroEnd-React%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.安装脚手架：npm i -g create-react-app<br>2.新建demo：create-react-app react-demo<br>三个核心包：</p>
<pre><code>react--项目处理逻辑有关, 
react-dom--虚拟dom渲染为真实dom,
react-scripts--包括项目启动,文件监听,文件编译等      </code></pre><p>注：使用yarn命令比npm好：npm下载包可能丢包</p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p><img src="/img/react%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%85%A5%E5%8F%A3.png" alt="react项目启动入口" title="react项目启动入口"></p>
<p>1.index.js为项目入口文件<br>2.import react 必须在react-dom前</p>
<h2 id="JSX对象"><a href="#JSX对象" class="headerlink" title="JSX对象"></a>JSX对象</h2><pre><code>ReactDom.render(&lt;h2&gt;hello&lt;/h2&gt;);
&lt;h2&gt;hello&lt;/h2&gt;为jsx对象=javescript+xml,虚拟dom,语法糖
以前都是在html里(xml一种)插入这样标签&lt;javescript&gt;操作&lt;javescript&gt;才能写js代码
现在是在javescript里不用标签加入html标签,相当js文件里定义了新的一种对象jsx能与js写一起

注：
1.jsx对象里插入js代码需要使用{js操作后返回jsx对象}；类似html中插入别的格式代码需要用标签声明//jsx中不确定地方都需要{}表达，jsx类似一个html是确定格式
2.const ele = (&lt;h2&gt;hello&lt;/h2&gt;);这样表达jsx对象需要用(jsx)包起来,括号不是强制但是能说明是一个模块属于同一个东西</code></pre><h2 id="ReactDom-render-参数jsx对象-节点-介绍"><a href="#ReactDom-render-参数jsx对象-节点-介绍" class="headerlink" title="ReactDom.render(参数jsx对象,节点)介绍"></a>ReactDom.render(参数jsx对象,节点)介绍</h2><h2 id="jsx写法"><a href="#jsx写法" class="headerlink" title="jsx写法"></a>jsx写法</h2><pre><code>const ele = (&lt;h2&gt;hello,{formatName(user)}&lt;/h2&gt;);
ReactDom.render(ele, document.querySelector(&apos;#root&apos;));</code></pre><h2 id="jsx对象中插值"><a href="#jsx对象中插值" class="headerlink" title="jsx对象中插值"></a>jsx对象中插值</h2><pre><code>function getGreeting(user) {
  if (user) {
    return ele;
  }

  return (&lt;h2&gt;hello,react&lt;/h2&gt;);
}

//函数返回的jsx对象不能直接使用在jsx位置,函数是为了在jsx内部使用，只能引进在jsx内部插入{函数/其他}
ReactDom.render(&lt;div&gt;{getGreeting(user)}&lt;/div&gt;, document.querySelector(&apos;#root&apos;));</code></pre><h2 id="react数值驱动视图"><a href="#react数值驱动视图" class="headerlink" title="react数值驱动视图"></a>react数值驱动视图</h2><pre><code>只需要更新自己需要更新的地方</code></pre><h2 id="循环绑定jsx对象"><a href="#循环绑定jsx对象" class="headerlink" title="循环绑定jsx对象"></a>循环绑定jsx对象</h2><pre><code>//数组循环绑定必须以数组map方法
arr.map((item, index) =&gt; {
  //循环绑定的jsx对象必须存在不同key来区分不同标签
  return (&lt;li key={index}&gt;{item}&lt;/li&gt;);
}</code></pre><h2 id="创建组件两种方式"><a href="#创建组件两种方式" class="headerlink" title="创建组件两种方式"></a>创建组件两种方式</h2><p>react 核心思想就是组件化开发(声明标签),其实就是写js,其实就是写函数<br>组件声明：函数/类首写字母一定要大写</p>
<h2 id="函数声明组件"><a href="#函数声明组件" class="headerlink" title="函数声明组件"></a>函数声明组件</h2><p>函数组件只包含一个 render 方法，并且不包含 state，使用函数组件就会更简单。不需要定义一个继承于 React.Component 的类，可以定义一个函数，这个函数接收 props 作为参数，然后返回需要渲染的元素。函数组件写起来并不像 class 组件那么繁琐，很多组件都可以使用函数组件来写。</p>
<pre><code>函数组件(少用):props对象存放使用时组件里的属性,可以利用propes.xxxx获取对应属性值
function Welcomd(props) {
    //如果组件里没有属性,propos为null
    return (&lt;h2&gt;hello,{props.name}}&lt;/h2&gt;);
}
ReactDom.render(&lt;Welcomd name=&apos;welcom&apos; /&gt;, document.querySelector(&apos;#root&apos;));</code></pre><h2 id="类声明-常用"><a href="#类声明-常用" class="headerlink" title="类声明(常用)"></a>类声明(常用)</h2><pre><code>类声明组件:
1.字母大写(ES6类方式实现); react使用组件时会认为小开头的都是标签
2.继承基类:React.component实现,constructor不是必须的
3.必须使用render函数,返回jsx对象,进行渲染
4.组件接受jsx属性props对象
5.类声明可以让父子组件通讯,函数声明麻烦,而且函数声明组件没有状态维护
6.多值传递{...this.props.user}
7.数据流单向,在App组件中子组件Admin可以获取当前组件信息多个属性{...this.props.xxx}/或单个属性{this.props.xxx},
作为信息传递到Admin中用{this.props.xxx}获取
8.样式通过className使用导入已经定义好的css文件;图片也可以通过导入使用变量名方式使用

export default class App extends Component {
     constructor(props) {
       super(props);
       this.user={
           name:&apos;1&apos;,
           age:&apos;2&apos;
       }
     }

    render() {
        return (
            //可以将user 解构出来所有属性传递给admin组件
            &lt;Admin {...this.props.user}/&gt;
        )
    }
}</code></pre><h2 id="复用组件"><a href="#复用组件" class="headerlink" title="复用组件"></a>复用组件</h2><pre><code>1.将多个组件进行整合,例如调用两次以上的相同组件
2.结构非常复杂时需要组件拆分为小组件
3.会存在父子关系的数据传递</code></pre><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><p>存在this指向问题:ES6箭头函数可以解决；</p>
<h3 id="父—-gt-子单向数据流驱动"><a href="#父—-gt-子单向数据流驱动" class="headerlink" title="父—&gt;子单向数据流驱动:"></a>父—&gt;子单向数据流驱动:</h3><pre><code>当前使用组件可以通过调用子组件给子组件设置属性方式传值(单值传递/多值传递);</code></pre><h3 id="子—-gt-父传递-不建议使用"><a href="#子—-gt-父传递-不建议使用" class="headerlink" title="子—&gt;父传递(不建议使用):"></a>子—&gt;父传递(不建议使用):</h3><pre><code>在父组件中设置一个函数(更改父子组件状态),然后将这个函数以传值方式传递给子组件,子组件可以通过props获取着父组件函数,从而在子组件内部控制父组件状态</code></pre><h2 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h2><p>注：不允许自身修改props,必须提升到父级组件中修改驱动才符合单向数据流;但可以维护自身state状态</p>
<pre><code>export default class tst extends Component {
    constructor(props) {
        super(props);
        //定制当前组件的状态,只要这些状态值变化,当前的render函数重新渲染
        this.state={
            name:&apos;1&apos;,
            age:1
        }
    }

    add(){
        //setState()是异步操作;
        this.setstate({
            name:this.state.age+1;
        });
        //由于异步没拿到更新后的数据2,取数据速度比更新块
        console.log(this.state.age);//1

        //同步化:前一个函数是修改state状态,第二函数为状态修改后回调函数最新状态prevProps在后一个箭头函数使用
        this.setState((prevState,prevProps)=&gt;({
            name:prevState.age+1;}),()=&gt;({console.log(prevProps.age)
        }))
    }
    render() {return (jsx对象 )};
}</code></pre><h3 id="在构造器中定制状态"><a href="#在构造器中定制状态" class="headerlink" title="在构造器中定制状态"></a>在构造器中定制状态</h3><pre><code>定制当前组件的状态,只要这些状态值变化,当前的render函数重新渲染</code></pre><h3 id="修改组件state"><a href="#修改组件state" class="headerlink" title="修改组件state"></a>修改组件state</h3><pre><code>处理在构造函数里初始化修改state的值,其他地方修改state唯一方法就是使用setState()方法
setState()是异步操作,传对象无法处理最新状态，以函数方法使用可以避免这个问题
例子1(少用):在组件里定义函数如上面add函数,函数内部使用this.setState(参数为对象)方法修改
例子2:this.setState(参数为箭头函数返回：对象要用(对象)返回)：
this.setState((prevState,prevProps)=&gt;({}),()=&gt;({}))</code></pre><h3 id="解决组件事件调用函数this指向问题"><a href="#解决组件事件调用函数this指向问题" class="headerlink" title="解决组件事件调用函数this指向问题"></a>解决组件事件调用函数this指向问题</h3><pre><code>1.在定义构造器时，将函数绑定给着对象：this.add = this.add.bind(this);
2.修改add为箭头函数 add()=&gt;{}后 onclick={this.add()}
3.onclick ={(e)=&gt;{this.add(e)}}//可以传参
2.(不推荐)在onclick ={this.add.bind(this)}</code></pre><h2 id="组件的状态生命周期"><a href="#组件的状态生命周期" class="headerlink" title="组件的状态生命周期"></a>组件的状态生命周期</h2><p>react生命周期包括三个阶段：初始化阶段,运行中阶段,销毁阶段,不懂生命周期触发不同的钩子函数</p>
<p><img src="/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期" title="生命周期"><br><img src="/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F3.png" alt="生命周期3" title="生命周期3"><br><img src="/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png" alt="生命周期2" title="生命周期2"><br><img src="/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%90%E8%BD%AC%E7%BB%93%E6%9E%9C.png" alt="生命周期运转结果" title="生命周期运转结果"></p>
<pre><code>export default class LifeCircle extends Component {

static defaultProps = {
    //0.加载默认属性
    firt: console.log(&apos;0.加载默认属性&apos;),
    name: &apos;小马哥&apos;,
    age: 18
}

constructor(props) {
    super(props);
    console.log(&apos;1.初始化 加载默认的状态&apos;);
    this.state = {
    count: 0
    }
}

componentWillMount() {
    console.log(&apos;2.父组件(WillMount)将要被挂载&apos;);
}

componentDidMount() {
    //当前方法中发起AJXS请求，获取数据,数据驱动视图
    console.log(&apos;4.父组件(DidMount)挂载完成&apos;);
}

render() {
    console.log(&apos;组件(render)了&apos;);
    return (
    &lt;div&gt;
        &lt;h2&gt;当前的值：{this.state.count}&lt;/h2&gt;
        &lt;Button onClick={this.handleClick} &gt; 按钮&lt;/Button&gt;
        &lt;SubCount count={this.state.count}&gt;&lt;/SubCount&gt;
    &lt;/div&gt;
    )
}

handleClick = () =&gt; {
    this.setState((prevstate, preveprops) =&gt; ({
    age: console.log(&apos;触发点击监听事件开始:更新状态&apos;),
    count: prevstate.count + 1
    }), () =&gt; {
    console.log(&apos;点击监听事件完成时状态：&apos; + (this.state.count));
    })
}

shouldComponentUpdate(nextProps, nextState) {
    //重要:性能优化点
    console.log(&apos;5.状态变化后根据奇偶性判断,组件是否要更新render&apos;);
    if (nextState.count % 2 === 0) {
    return true;
    } else {
    return false;
    }
}

componentWillUpdate() {
    console.log(&apos;7.组件将要更新render&apos;)
}

componentDidUpdate() {
    console.log(&apos;8.组件已经更新render完成&apos;)
}

componentWillUnmount() {
    //卸载定时器
    console.log(&apos;10.卸载&apos;);
}
}


class SubCount extends Component {
    componentWillReceiveProps(newProps) {
        console.log(&apos;由于父组件状态变化通知子组件将要接受属性&apos;, newProps);
    }

    render() {
        return (
        &lt;div&gt;{this.props.count}&lt;/div&gt;
        )
    }
}</code></pre><h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>受控组件:受状态控制的组件</p>
<pre><code>1.定义控制组件变化得状态对象
2.将对应控件上发生变化得地方绑定对应状态值,用函数去监听该控件的变化,函数内部处理使得状态变化达到让组件渲染</code></pre><p>如：为了输入时,值发生变化使得相应控件发生变化渲染,需要把状态绑定到该会发生变化得地方;</p>
<pre><code>export default class controlinpu extends Component {
    constructor(props) {
        super(props);
        //设置控制状态对象
        this.state = {
        age: 0
        }
    }

    //监听控件变化,将实时将变化得值赋给控件状态,这样可以实时更新渲染
    handlChange = (e) =&gt; {
        let age = e.target.value;
        this.setState({ age });
    }

    render() {
        return (
        &lt;div&gt;
            //组件状态绑定在对应控件上
            &lt;input tpye=&quot;text&quot; value={this.state.age} onChange={this.handlChange}&gt;&lt;/input&gt;
        &lt;/div&gt;
        )
    }
}</code></pre><h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>非受控组件:不受状态控制的组件：不需要绑定状态在控件上</p>
<pre><code>export default class controlinpu extends Component {
    constructor(props) {
        super(props);
        //设置控制状态对象
        this.state = {
        age: 0
        }
    }

    //监听控件变化,将实时将变化得值赋给控件状态,这样可以实时更新渲染
    handlChange = (e) =&gt; {
        let age = e.target.value;
        this.setState({ age });
    }

    render() {
        return (
            &lt;div&gt;
                //组件状态不绑定在对应控件上
                &lt;input tpye=&quot;text&quot; onChange={this.handlChange}&gt;&lt;/input&gt;
                &lt;h2&gt;{this.state.val}&lt;/h2&gt;
            &lt;/div&gt;
        )
    }
}</code></pre>]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React实战理解</title>
    <url>/2019/09/11/FroEnd-React%E5%AE%9E%E6%88%98%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="组件类型分类"><a href="#组件类型分类" class="headerlink" title="组件类型分类"></a>组件类型分类</h2><p><img src="/img/%E5%B1%95%E7%A4%BA%E5%9E%8B%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AE%B9%E5%99%A8%E5%9E%8B%E7%BB%84%E4%BB%B6.png" alt="展示型组件和容器型组件" title="展示型组件和容器型组件"></p>
<h2 id="store-机制"><a href="#store-机制" class="headerlink" title="store 机制"></a>store 机制</h2><p><img src="/img/Store%E6%9C%BA%E5%88%B6.png" alt="Store机制" title="Store机制"></p>
<h2 id="reducer-基本机制"><a href="#reducer-基本机制" class="headerlink" title="reducer 基本机制"></a>reducer 基本机制</h2><p><img src="/img/Reducer%E6%9C%BA%E5%88%B6.png" alt="Reducer机制" title="Reducer机制"></p>
<h2 id="redux-基本思想"><a href="#redux-基本思想" class="headerlink" title="redux 基本思想"></a>redux 基本思想</h2><p><img src="/img/Redux%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3.png" alt="Redux基本思想" title="Redux基本思想"></p>
<h2 id="react-redux使用"><a href="#react-redux使用" class="headerlink" title="react-redux使用"></a>react-redux使用</h2><p><img src="/img/react-redux.png" alt="react-redux" title="react-redux"></p>
<h2 id="项目文件目录结构3种模式"><a href="#项目文件目录结构3种模式" class="headerlink" title="项目文件目录结构3种模式"></a>项目文件目录结构3种模式</h2><h3 id="按文件功能类型划分"><a href="#按文件功能类型划分" class="headerlink" title="按文件功能类型划分"></a>按文件功能类型划分</h3><p>　　文件类型是一个component（展示组件），container（容器组件），在redux状态管理当中有，action，reducer等，这些不同角色的文件都放在一个单独的文件夹目录里，这种样式的结构也是React官方所推荐的结构;使用这种结构组织项目，每当增加一个新功能的时候，需要再containers，components文件夹下增加这个功能需要的组件，还需要再actions，reducers文件夹下分别添加Redux管理这个功能使用到的action，reducer，此时如果actionType放在另外一个文件夹，还需要在这个文件夹下增加新的actionType，所以开发一个新的功能，需要再这些文件夹下频繁的切换已修改不同的文件。如果项目比较小，问题不大，如果对于一个规模比较大的项目使用这种项目结构非常的麻烦。<br>    注:这类展示因为状态都在同一个文件,不存在按页面功能划分导致状态分离在不同文件管理问题</p>
<p><img src="/img/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84-%E7%B1%BB%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" alt="项目结构-类型模式" title="项目结构-类型模式"><br><img src="/img/%E6%8C%89%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86.png" alt="按类型划分" title="按类型划分"></p>
<h3 id="按页面功能划分"><a href="#按页面功能划分" class="headerlink" title="按页面功能划分"></a>按页面功能划分</h3><p>　　既一个页面功能对应一个文件夹，这个页面功能所用到的container，component，action，reducer等文件都放在这个文件夹下。如下为按照页面功能划分的项目结构示列.这种结构好处很明显，一个页面功能使用到的组件，状态和行为都在同一个文件夹下，方便开发和维护，同时易于扩展，github上很多的脚手架也选择了这种目录结构，不足之处是依然同按角色划分面临同样的问题，改变一个功能需要频繁的在reducer，action，actionType等不同文件夹间切换。<font color='red'>另外redux将整个的应用状态放在一个store中来管理，不同功能模块之间可以共享store中的公共部分状态(项目越复杂，这种场景会越多)，共享的状态应该放到哪一个页面文件夹下也是一个问题，这些问题归根结底是因为redux中状态管理逻辑并不是根据页面功能划分的，页面功能划分会导致公共状态分离在不同文件,功能模块耦合情况下,状态变化会存在相互影响</font><br><img src="/img/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84-%E6%8C%89%E5%8A%9F%E8%83%BD%E5%88%92%E5%88%86.png" alt="项目结构-按功能划分" title="项目结构-按功能划分"><br><img src="/img/%E6%8C%89%E5%8A%9F%E8%83%BD%E5%88%92%E5%88%86.png" alt="按功能划分" title="项目结构-按功能划分"></p>
<h3 id="按照store状态管理-Duck模式"><a href="#按照store状态管理-Duck模式" class="headerlink" title="按照store状态管理(Duck模式)"></a>按照store状态管理(Duck模式)</h3><p>　　ducks指的是一种新的redux项目目录结构，它提倡将相关的reducer，action，actionType和action creaters写在一个文件里面，$\color{red}${本质上是以应用状态作为划分模块的依据，而不是以页面的功能作为划分模块的依据，}$这样，管理相同状态的依赖都在同一个文件中，无论哪个容器组件需要这部分状态，只需要引入管理这个状态的模块文件即可<br><img src="/img/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84-Duck%E6%A8%A1%E5%BC%8F.png" alt="项目结构-Duck模式" title="项目结构-Duck模式"><br><img src="/img/Duck%E6%A8%A1%E5%BC%8F.png" alt="Duck模式" title="Duck模式"></p>
<h4 id="action的工厂模式"><a href="#action的工厂模式" class="headerlink" title="action的工厂模式"></a>action的工厂模式</h4><p>　　在前两种结构中，当container需要使用actions时，可以通过import * as actions from ‘path/to/actions.js’的方式一次性的把一个action的文件中中所有的action creates都引入进来。但在使用Ducks结构时，action creater和reducer定义在同一个文件中，import*的导入方式会把reducer也导入进来(如果action types也被export ，那么还会导入action type)。为了解决这个问题。我们可以把action creators和action types定义到一个命名空间中<br><img src="/img/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89action.png" alt="工厂模式定义action" title="工厂模式定义action"></p>
<h2 id="state设计"><a href="#state设计" class="headerlink" title="state设计"></a>state设计</h2><h3 id="两种错误设计方式"><a href="#两种错误设计方式" class="headerlink" title="两种错误设计方式"></a>两种错误设计方式</h3><p>以API为设计State的依据<br>以页面UI为设计State的依据</p>
<h3 id="state设计原则"><a href="#state设计原则" class="headerlink" title="state设计原则"></a>state设计原则</h3><p>store类似前端的数据库,每一个reducer对应数据库的表,reducer对象对应数据,设计state就如设计数据库一样<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F.png" alt="数据库三范式" title="数据库三范式"><br><img src="/img/State%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.png" alt="State设计原则" title="State设计原则"></p>
<p>注：state设计尽量扁平化,避免嵌套过深<br>UI State：具有松散兴特点</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数定义：将函数作为参数或者返回值是函数的函数。<br>高阶函数分两种：<br>    常见的 sort,reduce 等函数<br>    返回值是函数的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a) &#123;</span><br><span class="line">    return function(b) &#123;</span><br><span class="line">        return a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add3 &#x3D; add(3) &#x2F;&#x2F;add3表示一个指向函数的变量 可以当成函数调用名来用</span><br><span class="line">add3(4) &#x3D;&#x3D;&#x3D; 3 + 4 &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<p>柯里化函数等价为add函数在es6写法<br>    let add = a =&gt; b =&gt; a + b<br>柯里化函数的功能<br>    可以惰性求值<br>    可以提前传递部分参数</p>
<h2 id="Selector函数"><a href="#Selector函数" class="headerlink" title="Selector函数"></a>Selector函数</h2><p>Selector函数定义：<br>     读取Redux中的state的封装函数(以函数形式读取redux中state),在ontainer,Componets组件使用Selector函数读取state使用,达到解耦作用,这样如果某天修改了state的变量名,直接在函数中修改即可(多个地方使用一个函数)<br><img src="/img/Selector%E5%87%BD%E6%95%B0.png" alt="Selector函数" title="Selector函数"></p>
<h2 id="Middleware-中间件"><a href="#Middleware-中间件" class="headerlink" title="Middleware(中间件)"></a>Middleware(中间件)</h2><h3 id="MiddleWare原理"><a href="#MiddleWare原理" class="headerlink" title="MiddleWare原理"></a>MiddleWare原理</h3><p><img src="/img/MiddleWare%E5%8E%9F%E7%90%86.png" alt="MiddleWare原理" title="MiddleWare原理"></p>
<h3 id="Middleware源码"><a href="#Middleware源码" class="headerlink" title="Middleware源码"></a>Middleware源码</h3><p><img src="/img/Middleware%E6%BA%90%E7%A0%81.png" alt="Middleware源码.png" title="Middleware源码"></p>
<h2 id="Store-Enhancer-少用"><a href="#Store-Enhancer-少用" class="headerlink" title="Store_Enhancer(少用)"></a>Store_Enhancer(少用)</h2><h3 id="Store-Enhancer作用"><a href="#Store-Enhancer作用" class="headerlink" title="Store_Enhancer作用"></a>Store_Enhancer作用</h3><pre><code>可以增加store的dispatch,getState等功能,类似在一个函数处理前先添加函数进行处理</code></pre><p><img src="/img/Store_Enhancer%E4%BD%9C%E7%94%A8.png" alt="Store_Enhancer作用" title="Store_Enhancer作用"></p>
<h3 id="Store-Enhancer结构"><a href="#Store-Enhancer结构" class="headerlink" title="Store_Enhancer结构"></a>Store_Enhancer结构</h3><p><img src="/img/Store_Enhancer%E7%BB%93%E6%9E%84.png" alt="Store_Enhancer结构" title="Store_Enhancer结构"></p>
<h2 id="Store-Enhancer-少用-与-Middleware区别"><a href="#Store-Enhancer-少用-与-Middleware区别" class="headerlink" title="Store_Enhancer(少用) 与 Middleware区别"></a>Store_Enhancer(少用) 与 Middleware区别</h2><p><img src="/img/Store_Enhancer%E4%B8%8EMiddleware%E5%8C%BA%E5%88%AB.png" alt="Store_Enhancer与Middleware区别" title="Store_Enhancer与Middleware区别"><br>Store_Enhancer作用:<br>        底层的抽象(更接近底层操作,存在更改底层逻辑风险),可以增加store的dispatch,getState等功能,类似在一个函数处理前先添加函数进行处理<br>Middleware:<br>        高层的抽象,进行约束行为,不容易改变底层逻辑</p>
<h2 id="React常用库"><a href="#React常用库" class="headerlink" title="React常用库"></a>React常用库</h2><h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><p><a href="https://github.com/immutable-js/immutable-js" target="_blank" rel="noopener">Immutable collections for JavaScript</a><br>定义：Immutable Data 就是一旦创建,就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象<br>Immutable 实现的原理是 Persistent Data Structure(持久化数据结构),也就是使用旧数据创建新数据时,要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗,Immutable 使用了 Structural Sharing···· (结构共享),即如果对象树中一个节点发生变化,只修改这个节点和受它影响的父节点,其它节点则进行共享。<br><img src="/img/Immutable%E5%8E%9F%E7%90%86.gif" alt="Immutable原理" title="Immutable原理"></p>
<h4 id="为什么要在React-js中使用Immutable"><a href="#为什么要在React-js中使用Immutable" class="headerlink" title="为什么要在React.js中使用Immutable"></a>为什么要在React.js中使用Immutable</h4><p>它是一个完全独立的库,无论基于什么框架都可以用它。意义在于它弥补了 Javascript 没有不可变数据结构的问题，由于是不可变的,可以放心的对对象进行任意操作。在 React 开发中,频繁操作state对象或是 store ,配合 immutableJS 快、安全、方便，熟悉 React.js 的都应该知道, React.js 是一个 UI = f(states) 的框架,为了解决更新的问题, React.js 使用了 virtual dom , virtual dom 通过 diff 修改 dom ,来实现高效的 dom 更新。但是有一个问题。当 state 更新时,如果数据没变,你也会去做 virtual dom 的 diff ,这就产生了浪费。这种情况其实很常见。当然你可能会说,你可以使用 PureRenderMixin 来解决呀, PureRenderMixin 是个好东西,我们可以用它来解决一部分的上述问题。但 PureRenderMixin 只是简单的浅比较,不使用于多层比较。那怎么办？自己去做复杂比较的话,性能又会非常差。方案就是使用 immutable.js 可以解决这个问题。因为每一次 state 更新只要有数据改变,那么 PureRenderMixin 可以立刻判断出数据改变,可以大大提升性能</p>
<h4 id="与React搭配使用，关键点是shouldComponentUpdate"><a href="#与React搭配使用，关键点是shouldComponentUpdate" class="headerlink" title="与React搭配使用，关键点是shouldComponentUpdate"></a>与React搭配使用，关键点是shouldComponentUpdate</h4><p>熟悉 React 的都知道，React 做性能优化时有一个避免重复渲染的大招，就是使用 shouldComponentUpdate()，但它默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，尽管React的虚拟算法复杂度已经有了很多优化，但是在大规模组件更新时，依然会是个不必要的损耗。会带来很多无必要的渲染并成为性能瓶颈。我们常用的Purecomponent的秘密其实是在shouldComponentUpdate中做了前后state和props的浅比较，如果不小心组件props的引用问题，这里会导致出现很多Bug。虽然第一层数据没变，但引用变了，就会造成虚拟 DOM 计算的浪费。第一层数据改变，但引用没变，会造成不渲染，所以需要很小心的操作数据。Object.assign可以实现不可变数据,唯一的就是性能问题</p>
<h4 id="Immutable-优点"><a href="#Immutable-优点" class="headerlink" title="Immutable 优点"></a>Immutable 优点</h4><pre><code>Immutable 降低了 Mutable 带来的复杂度:可变（ Mutable ）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯
节省内存:Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收
Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟,因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。
并发安全:传统的并发非常难做，因为要处理各种数据不一致问题，因此『聪明人』发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不需要了。
拥抱函数式编程:Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。</code></pre><h4 id="Immutable-缺点"><a href="#Immutable-缺点" class="headerlink" title="Immutable 缺点"></a>Immutable 缺点</h4><pre><code>需要学习新的 API
增加了资源文件大小
容易与原生对象混淆</code></pre><h2 id="Reselect库"><a href="#Reselect库" class="headerlink" title="Reselect库"></a>Reselect库</h2><pre><code>npm install reselect;
作用：减少State计算,可以在state值没有改变情况下,不渲染页面(有的页面只要改变就需要渲染,其实state值并不变);
如果计算state并不是非常复杂,或不是redux性能有问题,或为了优化，尽量不用</code></pre><h3 id="未引入reselect"><a href="#未引入reselect" class="headerlink" title="未引入reselect"></a>未引入reselect</h3><pre><code>State未更新值,但需要渲染</code></pre><p><img src="/img/reselect%E4%BD%9C%E7%94%A81.png" alt="reselect作用1" title="reselect作用1"></p>
<h3 id="引入reselect"><a href="#引入reselect" class="headerlink" title="引入reselect"></a>引入reselect</h3><pre><code>State未更新值,但不需要渲染</code></pre><p><img src="/img/reselect%E4%BD%9C%E7%94%A82.png" alt="reselect作用2" title="reselect作用2"></p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Immutable</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React总结</title>
    <url>/2019/08/29/FroEnd-React%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="setSate总结"><a href="#setSate总结" class="headerlink" title="setSate总结"></a>setSate总结</h2><h3 id="setState的4种方式："><a href="#setState的4种方式：" class="headerlink" title="setState的4种方式："></a>setState的4种方式：</h3><pre><code>class Index extends Component {
    state={
        count:1
    }
     //添加下面方法测试
    render() {
        console.log(&apos;render&apos;);
        return (
            &lt;div&gt;
                &lt;h1&gt;currentState:{this.state.count}&lt;/h1&gt;
                &lt;button onClick={this.test1}&gt;测试1&lt;/button&gt;
                &lt;button onClick={this.test2}&gt;测试2&lt;/button&gt;
                &lt;button onClick={this.test3} style={{color:'red'}}&gt;测试3&lt;/button&gt;
                &lt;button onClick={this.test4}&gt;测试4&lt;/button&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><h4 id="通过回调函数的形式"><a href="#通过回调函数的形式" class="headerlink" title="通过回调函数的形式"></a>通过回调函数的形式</h4><pre><code>test1 = () =&gt; {
    this.setState((state,props)=&gt;({
        count:state.count+1
    }));
    console.log(&apos;test1 setState()之后&apos;,this.state.count);
}</code></pre><h4 id="通过对象的方式"><a href="#通过对象的方式" class="headerlink" title="通过对象的方式"></a>通过对象的方式</h4><pre><code>(注意：此方法多次设置会合并且只调用一次！)
test2 = () =&gt; {
    this.setState({
        count:this.state.count+1
    });
    console.log(&apos;test2 setState()之后&apos;,this.state.count);
}</code></pre><h4 id="回调函数更新"><a href="#回调函数更新" class="headerlink" title="回调函数更新"></a>回调函数更新</h4><pre><code>test3 = () =&gt; {
    // 在第二个callback拿到更新后的state
    this.setState({
        count:this.state.count+1
    },()=&gt;{// 在状态更新且页面更新(render)后执行
        console.log(&apos;test4 setState()之后&apos;,this.state.count);
    });
}</code></pre><h4 id="直接修改state的值-错误做法"><a href="#直接修改state的值-错误做法" class="headerlink" title="直接修改state的值(错误做法)"></a>直接修改state的值(错误做法)</h4><pre><code>不能直接修改state的值，此方法强烈不建议！！！因为不会触发重新render
test4 = () =&gt; {
    this.state.count += 1;
}</code></pre><h3 id="setState-更新状态是异步还是同步："><a href="#setState-更新状态是异步还是同步：" class="headerlink" title="setState()更新状态是异步还是同步："></a>setState()更新状态是异步还是同步：</h3><p>需要判断执行setState的位置</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>在react控制的回调函数中：生命周期钩子/react事件监听回调</p>
<pre><code>class Index extends Component {
    state={
        count:1
    }

    //react事件监听回调中，setState()是异步状态
    update1 = () =&gt; {
        console.log(&apos;update1 setState()之前&apos;,this.state.count);
        this.setState((state,props)=&gt;({
            count:state.count+1
        }));
        console.log(&apos;update1 setState()之后&apos;,this.state.count);
    }

    //react生命周期钩子中，setState()是异步更新状态
    componentDidMount() {
        console.log(&apos;componentDidMount setState()之前&apos;,this.state.count);
        this.setState((state,props)=&gt;({
            count:state.count+1
        }));
        console.log(&apos;componentDidMount setState()之后&apos;,this.state.count);
    }

    render() {
        console.log(&apos;render&apos;);
        return (
            &lt;div&gt;
                &lt;h1&gt;currentState:{this.state.count}&lt;/h1&gt;
                &lt;button onClick={this.update1}&gt;测试1&lt;/button&gt;
            &lt;/div&gt;
        )
    }
}   </code></pre><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>非react控制的异步回调函数中：定时器回调/原生事件监听回调/Promise  </p>
<pre><code>class Index extends Component {
    state={
        count:1
    }

    render() {
        console.log(&apos;render&apos;);
        return (
            &lt;div&gt;
                &lt;h1 ref=&apos;count&apos;&gt;currentState:{this.state.count}&lt;/h1&gt;
                &lt;button onClick={this.update1}&gt;测试1&lt;/button&gt;
                &lt;button onClick={this.update2}&gt;测试2&lt;/button&gt;
                &lt;button onClick={this.update3}&gt;测试3&lt;/button&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><h6 id="定时器回调"><a href="#定时器回调" class="headerlink" title="定时器回调"></a>定时器回调</h6><pre><code>update1 = () =&gt; {
    setTimeout(()=&gt;{
        console.log(&apos;setTimeout setState()之前&apos;,this.state.count);//1
        this.setState((state,props)=&gt;({
            count:state.count+1
        }));
        console.log(&apos;setTimeout setState()之后&apos;,this.state.count);//2
    });
}</code></pre><h6 id="原生事件回调"><a href="#原生事件回调" class="headerlink" title="原生事件回调"></a>原生事件回调</h6><pre><code>update2 = () =&gt; {
    const h1 = this.refs.count;
    h1.onclick = () =&gt; {
        console.log(&apos;onClick setState()之前&apos;,this.state.count);//1
        this.setState((state,props)=&gt;({
            count:state.count+1
        }));
        console.log(&apos;onClick setState()之后&apos;,this.state.count);//2
    }
}</code></pre><h6 id="Promise回调"><a href="#Promise回调" class="headerlink" title="Promise回调"></a>Promise回调</h6><pre><code>update3 = () =&gt; {
    Promise.resolve().then(value=&gt;{
        console.log(&apos;Promise setState()之前&apos;,this.state.count);//1
        this.setState((state,props)=&gt;({
            count:state.count+1
        }));
        console.log(&apos;Promise setState()之后&apos;,this.state.count);//2
    });
}</code></pre><h3 id="异步的setState-多次调用的问题："><a href="#异步的setState-多次调用的问题：" class="headerlink" title="异步的setState()多次调用的问题："></a>异步的setState()多次调用的问题：</h3><h4 id="多次调用，处理方法："><a href="#多次调用，处理方法：" class="headerlink" title="多次调用，处理方法："></a>多次调用，处理方法：</h4><p>setState({})：合并更新一次状态，只调用一次render()更新界面，多次调用会合并为一个，后面的值会覆盖前面的值。<br>setState(fn)：更新多次状态，只调用一次render()更新界面，多次调用不会合并为一个，后面的值会覆盖前面的值。</p>
<h4 id="如何得到setState异步更新后的状态数据："><a href="#如何得到setState异步更新后的状态数据：" class="headerlink" title="如何得到setState异步更新后的状态数据："></a>如何得到setState异步更新后的状态数据：</h4><p>在setState()的callback回调函数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Index extends Component &#123;</span><br><span class="line">    state&#x3D;&#123;</span><br><span class="line">        count:1</span><br><span class="line">    &#125;</span><br><span class="line">    update1 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;update1 setState()之前&#39;,this.state.count);</span><br><span class="line">        this.setState((state,props)&#x3D;&gt;(&#123;</span><br><span class="line">            count:state.count+1</span><br><span class="line">        &#125;));</span><br><span class="line">        console.log(&#39;update1 setState()之后&#39;,this.state.count);</span><br><span class="line">        console.log(&#39;update1 setState()之前2&#39;,this.state.count);</span><br><span class="line">        this.setState((state,props)&#x3D;&gt;(&#123;</span><br><span class="line">            count:state.count+1</span><br><span class="line">        &#125;));</span><br><span class="line">        console.log(&#39;update1 setState()之后2&#39;,this.state.count);</span><br><span class="line">    &#125;</span><br><span class="line">    update2 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;update2 setState()之前&#39;,this.state.count);</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            count:this.state.count+1</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(&#39;update2 setState()之后&#39;,this.state.count);</span><br><span class="line">        console.log(&#39;update2 setState()之前2&#39;,this.state.count);</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            count:this.state.count+1</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(&#39;update2 setState()之后2&#39;,this.state.count);</span><br><span class="line">    &#125;</span><br><span class="line">    update3 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;update3 setState()之前&#39;,this.state.count);</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            count:this.state.count+1</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(&#39;update3 setState()之后&#39;,this.state.count);</span><br><span class="line">        console.log(&#39;update3 setState()之前2&#39;,this.state.count);</span><br><span class="line">        this.setState((state,props)&#x3D;&gt;(&#123;</span><br><span class="line">            count:state.count+1</span><br><span class="line">        &#125;));&#x2F;&#x2F; 这里需要注意setState传参为函数模式时，state会确保拿到的是最新的值</span><br><span class="line">        console.log(&#39;update3 setState()之后2&#39;,this.state.count);</span><br><span class="line">    &#125;</span><br><span class="line">    update4 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;update4 setState()之前&#39;,this.state.count);</span><br><span class="line">        this.setState((state,props)&#x3D;&gt;(&#123;</span><br><span class="line">            count:state.count+1</span><br><span class="line">        &#125;));</span><br><span class="line">        console.log(&#39;update4 setState()之后&#39;,this.state.count);</span><br><span class="line">        console.log(&#39;update4 setState()之前2&#39;,this.state.count);</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            count:this.state.count+1</span><br><span class="line">        &#125;);&#x2F;&#x2F; 这里需要注意的是如果setState传参为对象且在最后，那么会与之前的setState合并</span><br><span class="line">        console.log(&#39;update4 setState()之后2&#39;,this.state.count);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(&#39;render&#39;);</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;currentState:&#123;this.state.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.update1&#125;&gt;测试1&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.update2&#125;&gt;测试2&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.update3&#125;&gt;测试3&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.update4&#125;&gt;测试4&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="react中常见的setState面试题（setState执行顺序）"><a href="#react中常见的setState面试题（setState执行顺序）" class="headerlink" title="react中常见的setState面试题（setState执行顺序）"></a>react中常见的setState面试题（setState执行顺序）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; setState执行顺序</span><br><span class="line">class Index extends Component &#123;</span><br><span class="line">    state&#x3D;&#123;</span><br><span class="line">        count:0</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.setState(&#123;count:this.state.count+1&#125;);</span><br><span class="line">        this.setState(&#123;count:this.state.count+1&#125;);</span><br><span class="line">        console.log(this.state.count);&#x2F;&#x2F; 2 &#x3D;&gt; 0</span><br><span class="line">        this.setState(state&#x3D;&gt;(&#123;count:state.count+1&#125;));</span><br><span class="line">        this.setState(state&#x3D;&gt;(&#123;count:state.count+1&#125;));</span><br><span class="line">        console.log(this.state.count);&#x2F;&#x2F; 3 &#x3D;&gt; 0</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            this.setState(&#123;count:this.state.count+1&#125;);</span><br><span class="line">            console.log(&#39;setTimeout&#39;,this.state.count);&#x2F;&#x2F; 10 &#x3D;&gt; 6</span><br><span class="line">            this.setState(&#123;count:this.state.count+1&#125;);</span><br><span class="line">            console.log(&#39;setTimeout&#39;,this.state.count);&#x2F;&#x2F; 12 &#x3D;&gt; 7</span><br><span class="line">        &#125;);</span><br><span class="line">        Promise.resolve().then(value&#x3D;&gt;&#123;</span><br><span class="line">            this.setState(&#123;count:this.state.count+1&#125;);</span><br><span class="line">            console.log(&#39;Promise&#39;,this.state.count);&#x2F;&#x2F; 6 &#x3D;&gt; 4</span><br><span class="line">            this.setState(&#123;count:this.state.count+1&#125;);</span><br><span class="line">            console.log(&#39;Promise&#39;,this.state.count);&#x2F;&#x2F; 8 &#x3D;&gt; 5</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(&#39;render&#39;,this.state.count);&#x2F;&#x2F; 1 &#x3D;&gt; 0  &#x2F;&#x2F; 4 &#x3D;&gt; 3 &#x2F;&#x2F; 5 &#x3D;&gt; 4 &#x2F;&#x2F; 7 &#x3D;&gt; 5 &#x2F;&#x2F; 9 &#x3D;&gt; 6 &#x2F;&#x2F; 11 &#x3D;&gt; 7</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;currentState:&#123;this.state.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.update1&#125;&gt;测试1&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.update2&#125;&gt;测试2&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.update3&#125;&gt;测试3&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.update4&#125;&gt;测试4&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="react中setState-更新状态的2种写法"><a href="#react中setState-更新状态的2种写法" class="headerlink" title="react中setState()更新状态的2种写法"></a>react中setState()更新状态的2种写法</h4><pre><code>1）setState(updater，[callback])
updater：为返回stateChange对象的函数：(state,props)=&gt;stateChange，接收的state和props都保证为最新的

2）setState(stateChange，[callback])
stateChange为对象，callback是可选的回调函数，在状态更新且界面更新后才执行</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><pre><code>对象是函数方式的简写方式
如果新状态不依赖于原状态，则使用对象方式；
如果新状态依赖于原状态，则使用函数方式；
如果需要在setState()后获取最新的状态数据，在第二个callback函数中获取</code></pre><h2 id="组件里使用context总结"><a href="#组件里使用context总结" class="headerlink" title="组件里使用context总结"></a>组件里使用context总结</h2><p>context 通过组件数提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。<br>在一个典型的 React 应用中，数据是通过 props 属性由上向下（由父及子）的进行传递的，但这对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI主题），这是应用程序中许多组件都所需要的。 Context 提供了一种在组件之间共享此类值的方式，而不必通过组件树的每个层级显式地传递 props </p>
<h3 id="context的使用PropTypes例子"><a href="#context的使用PropTypes例子" class="headerlink" title="context的使用PropTypes例子"></a>context的使用PropTypes例子</h3><pre><code>// 顶级组件，在配置context的值
import React from &apos;react&apos;;
import PropTypes from &apos;prop-types&apos;;
class MessageList extends React.Component {
getChildContext() {
    // 设置context中color的具体值
    return {color: &quot;purple&quot;};
}

render() {
    const children = this.props.messages.map((message) =&gt;
    &lt;Message text={message.text} /&gt;
    );
    return &lt;div&gt;{children}&lt;/div&gt;;
}
}

MessageList.childContextTypes = {
    // 指定context中存在color，对应的值为字符串类型
    color: PropTypes.string
};

// 中间的组件
import React from &apos;react&apos;;
class Message extends React.Component {
render() {
    return (
    &lt;div&gt;
        {this.props.text} &lt;Button&gt;Delete&lt;/Button&gt;
    &lt;/div&gt;
    );
}
}

//使用context中值的组件
import React from &apos;react&apos;;
import PropTypes from &apos;prop-types&apos;;
class Button extends React.Component {
render() {
    return (
    // context中的值具体的使用
    &lt;button style={{background: this.context.color}}&gt;
        {this.props.children}
    &lt;/button&gt;
    );
}
}

Button.contextTypes = {
    color: PropTypes.string
};</code></pre><h3 id="context的使用Provider-Consumer例子"><a href="#context的使用Provider-Consumer例子" class="headerlink" title="context的使用Provider/Consumer例子"></a>context的使用Provider/Consumer例子</h3><p><a href="https://blog.csdn.net/wu_xianqiang/article/details/89842338" target="_blank" rel="noopener">例子</a></p>
<h2 id="Node-js工作线程共享对象"><a href="#Node-js工作线程共享对象" class="headerlink" title="Node.js工作线程共享对象"></a>Node.js工作线程共享对象</h2><p><a href="https://nodejs.org/api/worker_threads.html" target="_blank" rel="noopener">Worker Thread文档</a><br><a href="https://www.it1352.com/1653728.html" target="_blank" rel="noopener">工作线程共享对象/存储(Nodejs worker threads shared object/store)</a><br><a href="https://blog.csdn.net/q511545671/article/details/78351741" target="_blank" rel="noopener">nodejs中函数共享作用域导致的内存泄漏</a><br><a href="https://segmentfault.com/a/1190000017985766" target="_blank" rel="noopener">Node.js的线程和进程详解</a></p>
<h2 id="nodejs-全局变量和全局对象"><a href="#nodejs-全局变量和全局对象" class="headerlink" title="nodejs 全局变量和全局对象"></a>nodejs 全局变量和全局对象</h2><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>所有模块都可以调用<br>    1）global：表示Node所在的全局环境，类似于浏览器中的window对象。<br>    2）process：指向Node内置的process模块，允许开发者与当前进程互动。<br>    例如你在DOS或终端窗口直接输入node，就会进入NODE的命令行方式（REPL环境）。退出要退出的话，可以输入 process.exit();<br>    3）console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。<br>    通常是写console.log()，无须多言</p>
<h3 id="全局函数："><a href="#全局函数：" class="headerlink" title="全局函数："></a>全局函数：</h3><p>1）定时器函数：共有4个，分别是setTimeout(), clearTimeout(), setInterval(), clearInterval()。<br>2）require：用于加载模块。</p>
<h3 id="全局变量："><a href="#全局变量：" class="headerlink" title="全局变量："></a>全局变量：</h3><p>1）_filename：指向当前运行的脚本文件名。<br>2）_dirname：指向当前运行的脚本所在的目录。</p>
<h3 id="准全局变量"><a href="#准全局变量" class="headerlink" title="准全局变量"></a>准全局变量</h3><p>模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。</p>
<p>module变量指代当前模块。module.exports变量表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。<br>module.id 模块的识别符，通常是模块的文件名。<br>module.filename 模块的文件名。<br>module.loaded 返回一个布尔值，表示模块是否已经完成加载。<br>module.parent 返回使用该模块的模块。<br>module.children 返回一个数组，表示该模块要用到的其他模块。</p>
<p>这里需要特别指出的是，exports变量实际上是一个指向module.exports对象的链接，等同在每个模块头部，有一行这样的命令。<br>var exports = module.exports;</p>
<p>这造成的结果是，在对外输出模块接口时，可以向exports对象添加方法，但是不能直接将exports变量指向一个函数：</p>
<p>exports.自定义模块 = function (x){ console.log(x);};<br>上面这样的写法是无效的，因为它切断了exports与module.exports之间的链接。但是，下面这样写是可以的。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React项目架构总结思考</title>
    <url>/2020/08/16/FroEnd-React%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="架构三思"><a href="#架构三思" class="headerlink" title="架构三思"></a>架构三思</h2><h3 id="核心思考"><a href="#核心思考" class="headerlink" title="核心思考"></a>核心思考</h3><p>抽象:将业务抽象出来,以代码对象抽象出来;(考虑抽出对象应用设计模式)<br>解耦:将抽象出来的对象解耦合,形成DB表格;(考虑应用设计模式)<br>组织:从业务层(service)将各个解耦合对象重新组织起来形成业务逻辑;(考虑应用设计模式)</p>
<h3 id="前端框架抽象思路"><a href="#前端框架抽象思路" class="headerlink" title="前端框架抽象思路"></a>前端框架抽象思路</h3><p>抽象：(不同模块抽象,每部分分出公共与独立部分)<br>    页面UI抽象:模块化组件<br>    通用模块抽象:领域实体,网络请求,异常处理等<br>    阅读需求文档，分析出功能路径,通过功能路径实现业务</p>
<h3 id="选择技术及其架构要素"><a href="#选择技术及其架构要素" class="headerlink" title="选择技术及其架构要素"></a>选择技术及其架构要素</h3><ul>
<li>该技术方案能否满足业务需求</li>
<li>该技术栈成熟度(市场上使用人数,周边生态,仓库维护)</li>
<li>该技术栈在团队的熟悉程度(使用团队成本)</li>
</ul>
<h3 id="搭建项目基本规范"><a href="#搭建项目基本规范" class="headerlink" title="搭建项目基本规范"></a>搭建项目基本规范</h3><ul>
<li><a href="/2019/09/11/FroEnd5-React实战理解"><font color='red'>目录结构划分</font></a>:A.按照文件功能类型划分,B.按照功能模块划分,C.按状态管理模式划分(Ducks) 推荐</li>
<li>构建体系:按状态管理模式划分(Ducks)<ul>
<li>抽象定义状态模块:(设计模块分层使用)<ol>
<li>领域状态:商品,店铺,订单,评论(抽象不同业务场景的状态)</li>
<li>各页面UI状态(抽象出全局使用UI的公用部分状态)</li>
<li>通用状态:登陆态,全局异常信息(抽象出全局使用的公共状态)<br><img src="/img/redux%E7%8A%B6%E6%80%81%E5%88%92%E5%88%86.png" alt="redux状态划分" title="redux状态划分"></li>
</ol>
</li>
</ul>
</li>
<li>Mock数据:</li>
</ul>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react-project</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux中间件与异步操作</title>
    <url>/2019/09/13/FroEnd-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Redux中间件与异步操作"><a href="#Redux中间件与异步操作" class="headerlink" title="Redux中间件与异步操作"></a>Redux中间件与异步操作</h2><p>Redux 的基本做法：用户发出 Action，Reducer 函数算出新的 State，View 重新渲染。但是，一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。</p>
<p>怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）。<br><img src="/img/redux-middleware.png,%22redux-middleware%22" alt="redux-middleware.png"></p>
<h2 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h2><p>为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p>
<p>（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。<br>（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。<br>（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p>
<p>想来想去，只有发送 Action 的这个步骤，即store.dispatch()方法，可以添加功能。举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对store.dispatch进行如下改造。</p>
<pre><code>let next = store.dispatch;
store.dispatch = function dispatchAndLog(action) {
console.log(&apos;dispatching&apos;, action);
next(action);
console.log(&apos;next state&apos;, store.getState());
}</code></pre><p>上面代码中，对store.dispatch进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。<br>中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p>
<h2 id="中间件的用法"><a href="#中间件的用法" class="headerlink" title="中间件的用法"></a>中间件的用法</h2><p>因为常用的中间件都有现成的，只要引用别人写好的模块即可。比如，上一节的日志中间件，就有现成的redux-logger模块。这里只介绍怎么使用中间件。</p>
<pre><code>npm install --save -D redux-logger

import { applyMiddleware, createStore } from &apos;redux&apos;;
import createLogger from &apos;redux-logger&apos;;
const logger = createLogger();

const store = createStore(
reducer,
applyMiddleware(logger)
);</code></pre><p>上面代码中，redux-logger提供一个生成器createLogger，可以生成日志中间件logger。然后，将它放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强。</p>
<p>这里有两点需要注意：<br>createStore方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware就是第三个参数了</p>
<pre><code>const store = createStore(
reducer,
initial_state,
applyMiddleware(logger)
);</code></pre><p>中间件的次序有讲究</p>
<pre><code>const store = createStore(
reducer,
applyMiddleware(thunk, promise, logger)
);</code></pre><p>上面代码中，applyMiddleware方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，logger就一定要放在最后，否则输出结果会不正确。</p>
<h2 id="applyMiddlewares"><a href="#applyMiddlewares" class="headerlink" title="applyMiddlewares()"></a>applyMiddlewares()</h2><p>看到这里，你可能会问，applyMiddlewares这个方法到底是干什么的?<br>它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。</p>
<pre><code>export default function applyMiddleware(...middlewares) {
    return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; {
        var store = createStore(reducer, preloadedState, enhancer);
        var dispatch = store.dispatch;
        var chain = [];

        var middlewareAPI = {
            getState: store.getState,
            dispatch: (action) =&gt; dispatch(action)
        };

        chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));
        dispatch = compose(...chain)(store.dispatch);

        return {...store, dispatch}
    }
}</code></pre><p>上面代码中，所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法。</p>
<h2 id="异步操作的基本思路"><a href="#异步操作的基本思路" class="headerlink" title="异步操作的基本思路"></a>异步操作的基本思路</h2><p>理解了中间件以后，就可以处理异步操作了。<br>同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</p>
<p>操作发起时的 Action<br>操作成功时的 Action<br>操作失败时的 Action<br>以向服务器取出数据为例，三种 Action 可以有两种不同的写法。</p>
<p>// 写法一：名称相同，参数不同<br>    { type: ‘FETCH_POSTS’ }<br>    { type: ‘FETCH_POSTS’, status: ‘error’, error: ‘Oops’ }<br>    { type: ‘FETCH_POSTS’, status: ‘success’, response: { … } }</p>
<p>// 写法二：名称不同<br>    { type: ‘FETCH_POSTS_REQUEST’ }<br>    { type: ‘FETCH_POSTS_FAILURE’, error: ‘Oops’ }<br>    { type: ‘FETCH_POSTS_SUCCESS’, response: { … } }</p>
<p>除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子。</p>
<pre><code>let state = {
// ... 
isFetching: true,
didInvalidate: true,
lastUpdated: &apos;xxxxxxx&apos;
};</code></pre><p>上面代码中，State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间。</p>
<p>现在，整个异步操作的思路就很清楚了。<br>操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染<br>操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux入门</title>
    <url>/2020/09/12/FroEnd-Redux%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="redux-使用场景"><a href="#redux-使用场景" class="headerlink" title="redux 使用场景"></a>redux 使用场景</h2><h3 id="不需要使用-redux-场景-UI-层非常简单，没有很多互动"><a href="#不需要使用-redux-场景-UI-层非常简单，没有很多互动" class="headerlink" title="不需要使用 redux 场景:UI 层非常简单，没有很多互动"></a>不需要使用 redux 场景:UI 层非常简单，没有很多互动</h3><p>1.用户的使用方式非常简单 2.用户之间没有协作 3.不需要与服务器大量交互，也没有使用 WebSocket 4.视图层（View）只从单一来源获取数据</p>
<h3 id="Redux-的适用场景：多交互-多数据源"><a href="#Redux-的适用场景：多交互-多数据源" class="headerlink" title="Redux 的适用场景：多交互,多数据源"></a>Redux 的适用场景：多交互,多数据源</h3><p>1.某个组件的状态，需要共享 2.某个状态需要在任何地方都可以拿到 3.一个组件需要改变全局状态 4.一个组件需要改变另一个组件的状态</p>
<h2 id="Redux-设计思想"><a href="#Redux-设计思想" class="headerlink" title="Redux 设计思想"></a>Redux 设计思想</h2><p>Redux 的设计思想很简单，就两句核心的话</p>
<pre><code>1.Web应用是一个状态机，一个视图(View)对应一个状态(State)，视图与状态是一一对应的。
2.所有的状态(State)，保存在一个对象(Store)里面.//这个对象类似一个容器</code></pre><h2 id="Redux-基本概念和-API"><a href="#Redux-基本概念和-API" class="headerlink" title="Redux 基本概念和 API"></a>Redux 基本概念和 API</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p>
<pre><code>import { createStore } from &apos;redux&apos;;
const store = createStore(fn);//createStore函数接受另一个函数作为参数，返回新生成的 Store 对象</code></pre><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>Store 对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。<br>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。<br>当前时刻的 State，可以通过 store.getState()拿到。</p>
<pre><code>import { createStore } from &apos;redux&apos;;
const store = createStore(fn);
const state = store.getState();</code></pre><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><h4 id="Action-原理"><a href="#Action-原理" class="headerlink" title="Action 原理"></a>Action 原理</h4><p>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。<br>Action 是一个对象。其中的 type 属性是必须的，表示 Action 的名称。其他属性可以自由设置，<a href="https://github.com/acdlite/flux-standard-action" target="_blank" rel="noopener">社区有一个规范可以参考</a></p>
<pre><code>const action = {
    type: &apos;ADD_TODO&apos;,
    payload: &apos;Learn Redux&apos;
};</code></pre><p>上面代码中，Action 的名称是 ADD_TODO，它携带的信息是字符串 Learn Redux。Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>
<h4 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a>Action Creator</h4><p>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。如下：addTodo 函数就是一个 Action Creator。</p>
<pre><code>const ADD_TODO = &apos;添加 TODO&apos;;
function addTodo(text) {
    return {
        type: ADD_TODO,
        text
    }
}
const action = addTodo(&apos;Learn Redux&apos;);</code></pre><h3 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a>store.dispatch()</h3><p>store.dispatch()是 View 发出 Action 的唯一方法。</p>
<pre><code>import { createStore } from &apos;redux&apos;;
const store = createStore(fn);

store.dispatch({
type: &apos;ADD_TODO&apos;,
payload: &apos;Learn Redux&apos;
});</code></pre><p>上面代码中，store.dispatch 接受一个 Action 对象作为参数，将它发送出去。<br>结合 Action Creator，这段代码可以改写如下。<br>store.dispatch(addTodo(‘Learn Redux’));</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><h4 id="Reducer-原理"><a href="#Reducer-原理" class="headerlink" title="Reducer 原理"></a>Reducer 原理</h4><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。<br>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<p>//定义 reducer new state 方法===setSate()<br>const reducer = function (state, action) {<br>// …<br>return new_state;<br>};</p>
<p>整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。</p>
<pre><code>const defaultState = 0;
//定义reducer计算state方法===setSate()
const reducer = (state = defaultState, action) =&gt; {
    switch (action.type) {
        case &apos;ADD&apos;:
            return state + action.payload;
        default:
            return state;
    }
};

const state = reducer(1, {
    type: &apos;ADD&apos;,
    payload: 2
});</code></pre><p>上面代码中，reducer 函数收到名为 ADD 的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。</p>
<h4 id="Reducer-应用"><a href="#Reducer-应用" class="headerlink" title="Reducer 应用"></a>Reducer 应用</h4><p>实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch 方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入 createStore 方法。</p>
<pre><code>import { createStore } from &apos;redux&apos;;
const store = createStore(reducer);</code></pre><p>上面代码中，createStore 接受 Reducer 作为参数，生成一个新的 Store。以后每当 store.dispatch 发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p>
<h4 id="Reducer-由来"><a href="#Reducer-由来" class="headerlink" title="Reducer 由来"></a>Reducer 由来</h4><p>为什么这个函数叫做 Reducer 呢？因为它可以作为数组的<a href="https://www.cnblogs.com/smallpen/p/10249288.html" target="_blank" rel="noopener">reduce 方法的参数</a>。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。</p>
<pre><code>const actions = [
    { type: &apos;ADD&apos;, payload: 0 },
    { type: &apos;ADD&apos;, payload: 1 },
    { type: &apos;ADD&apos;, payload: 2 }
];
//reducer为上面定义的方法
const total = actions.reduce(reducer, 0); // 3</code></pre><p>上面代码中，数组 actions 表示依次有三个 Action，分别是加 0、加 1 和加 2。数组的 reduce 方法接受 Reducer 函数作为参数，就可以直接得到最终的状态 3。</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。<br>纯函数是函数式编程的概念，必须遵守以下一些约束。</p>
<pre><code>1.不得改写参数
2.不能调用系统 I/O 的API
3.不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果
4.由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。


//返回 State 是一个新对象
function reducer(state, action) {
    return Object.assign({}, state, { thingToChange });
    // 或者
    return { ...state, ...newState };
}

//返回 State 是一个数组
function reducer(state, action) {
    return [...state, newItem];
}</code></pre><p>最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。</p>
<h3 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a>store.subscribe()</h3><p>Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。<br>显然，只要把 View 的更新函数（对于 React 项目，就是组件的 render 方法或 setState 方法）放入 listen，就会实现 View 的自动渲染。</p>
<pre><code>import { createStore } from &apos;redux&apos;;
const store = createStore(reducer);

store.subscribe(listener);


store.subscribe方法返回一个函数，调用这个函数就可以解除监听。
let unsubscribe = store.subscribe(() =&gt;
    console.log(store.getState())
);
unsubscribe();//解除监听</code></pre><h2 id="Store-的原理实现"><a href="#Store-的原理实现" class="headerlink" title="Store 的原理实现"></a>Store 的原理实现</h2><p>Store 提供了三个方法:<br>store.getState(),store.dispatch(),store.subscribe()</p>
<pre><code>import { createStore } from &apos;redux&apos;;
let { subscribe, dispatch, getState } = createStore(reducer);

//createStore 方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。
let store = createStore(todoApp, window.STATE_FROM_SERVER)
window.STATE_FROM_SERVER 就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。</code></pre><p>下面是 createStore 方法的一个简单实现，可以了解一下 Store 是怎么生成的。</p>
<pre><code>const createStore = (reducer) =&gt; {
let state;
let listeners = [];

const getState = () =&gt; state;

const dispatch = (action) =&gt; {
    state = reducer(state, action);
    listeners.forEach(listener =&gt; listener());
};

const subscribe = (listener) =&gt; {
    listeners.push(listener);
    return () =&gt; {
    listeners = listeners.filter(l =&gt; l !== listener);
    }
};

dispatch({});

return { getState, dispatch, subscribe };
};</code></pre><h2 id="Reducer-的拆分"><a href="#Reducer-的拆分" class="headerlink" title="Reducer 的拆分"></a>Reducer 的拆分</h2><p>Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。</p>
<p>请看下面的例子。</p>
<pre><code>const chatReducer = (state = defaultState, action = {}) =&gt; {
    const { type, payload } = action;
    switch (type) {
        case ADD_CHAT:
            return Object.assign({}, state, {
                chatLog: state.chatLog.concat(payload)
            });
        case CHANGE_STATUS:
            return Object.assign({}, state, {
                statusMessage: payload
            });
        case CHANGE_USERNAME:
            return Object.assign({}, state, {
                userName: payload
        });
        default: return state;
    }
};</code></pre><p>上面代码中，三种 Action 分别改变 State 的三个属性。<br>ADD_CHAT：chatLog 属性;CHANGE_STATUS：statusMessage 属性;CHANGE_USERNAME：userName 属性<br>这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。</p>
<pre><code>const chatReducer = (state = defaultState, action = {}) =&gt; {
    return {
        chatLog: chatLog(state.chatLog, action),
        statusMessage: statusMessage(state.statusMessage, action),
        userName: userName(state.userName, action)
    }
};</code></pre><p>上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性。<br>这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。</p>
<p>Redux 提供了一个 combineReducers 方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。</p>
<pre><code>import { combineReducers } from &apos;redux&apos;;
const chatReducer = combineReducers({
    chatLog,
    statusMessage,
    userName
})
export default todoApp;</code></pre><p>上面的代码通过 combineReducers 方法将三个子 Reducer 合并成一个大的函数。<br>这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。</p>
<pre><code>const reducer = combineReducers({
    a: doSomethingWithA,
    b: processB,
    c: c
})

// 等同于
function reducer(state = {}, action) {
    return {
        a: doSomethingWithA(state.a, action),
        b: processB(state.b, action),
        c: c(state.c, action)
    }
}</code></pre><p>总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。</p>
<p>下面是 combineReducer 的简单实现。</p>
<pre><code>const combineReducers = reducers =&gt; {
    return (state = {}, action) =&gt; {
        return Object.keys(reducers).reduce(
            (nextState, key) =&gt; {
                    nextState[key] = reducers[key](state[key], action);
                    return nextState;
                },{});
    };
};</code></pre><p>你可以把所有子 Reducer 放在一个文件 reducers 里面，然后统一引入。</p>
<pre><code>import { combineReducers } from &apos;redux&apos;
import \* as reducers from &apos;./reducers&apos;

const reducer = combineReducers(reducers)</code></pre><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/img/React-Redux-flow.png,%22React-Redux-flow%22" alt="React-Redux-flow"><br>首先，用户发出 Action: store.dispatch(action);</p>
<p>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State<br>let nextState = todoApp(previousState, action);<br>State 一旦有变化，Store 就会调用监听函数。</p>
<p>// 设置监听函数<br>store.subscribe(listener);<br>listener 可以通过 store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。</p>
<pre><code>function listerner() {
    let newState = store.getState();
    component.setState(newState);
}</code></pre><h2 id="实例：计数器"><a href="#实例：计数器" class="headerlink" title="实例：计数器"></a>实例：计数器</h2><p>下面我们来看一个最简单的实例。</p>
<pre><code>const Counter = ({ value }) =&gt; (
&lt;h1&gt;{value}&lt;/h1&gt;
);

const render = () =&gt; {
ReactDOM.render(
    &lt;Counter value={store.getState()}/&gt;,
    document.getElementById(&apos;root&apos;)
);
};

store.subscribe(render);
render();</code></pre><p>上面是一个简单的计数器，唯一的作用就是把参数 value 的值，显示在网页上。Store 的监听函数设置为 render，每次 State 的变化都会导致网页重新渲染。</p>
<p>下面加入一点变化，为 Counter 添加递增和递减的 Action。</p>
<pre><code>const Counter = ({ value, onIncrement, onDecrement }) =&gt; (
&lt;div&gt;
    &lt;h1&gt;{value}&lt;/h1&gt;
    &lt;button onClick={onIncrement}&gt;+&lt;/button&gt;
    &lt;button onClick={onDecrement}&gt;-&lt;/button&gt;
&lt;/div&gt;
);

const reducer = (state = 0, action) =&gt; {
switch (action.type) {
    case &apos;INCREMENT&apos;: return state + 1;
    case &apos;DECREMENT&apos;: return state - 1;
    default: return state;
}
};

const store = createStore(reducer);

const render = () =&gt; {
ReactDOM.render(
    &lt;Counter
    value={store.getState()}
    onIncrement={() =&gt; store.dispatch({type: &apos;INCREMENT&apos;})}
    onDecrement={() =&gt; store.dispatch({type: &apos;DECREMENT&apos;})}
    /&gt;,
    document.getElementById(&apos;root&apos;)
);
};

render();
store.subscribe(render);</code></pre>]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Css of Sass &amp; Less</title>
    <url>/2021/01/17/FroEnd-Sass%20&amp;%20Less/</url>
    <content><![CDATA[<h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><h3 id="为什么要使用CSS预处理器？"><a href="#为什么要使用CSS预处理器？" class="headerlink" title="为什么要使用CSS预处理器？"></a>为什么要使用CSS预处理器？</h3><p>作为前端开发人员，大家都知道，Js中可以自定义变量，而CSS仅仅是一个标记语言，不是编程语言，因此不可以自定义变量，不可以引用等等。</p>
<ul>
<li>CSS有具体以下几个缺点：</li>
</ul>
<ol>
<li>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。<br>这就导致了我们在工作中无端增加了许多工作量。而使用CSS预处理器，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了我们的开发效率。但是，CSS预处理器也不是万金油，CSS的好处在于简便、随时随地被使用和调试。预编译CSS步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。更大的问题在于，预编译很容易造成后代选择器的滥用。<br>所以我们在实际项目中衡量预编译方案时，还是得想想，比起带来的额外维护开销，CSS预处理器有没有解决更大的麻烦。</li>
</ol>
<h3 id="Sass语法"><a href="#Sass语法" class="headerlink" title="Sass语法"></a>Sass语法</h3><h4 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h4><p>sass中可以把一套css样式嵌套到另一套样式当中，是sass出色的原因之一。父元素嵌套着子元素，层层关系，避免重复输写父元素，使得复杂的css也能在书写和阅读上更加清晰易管理。属性也可以进行嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;属性嵌套 </span><br><span class="line">nav &#123;      </span><br><span class="line">    border: &#123; </span><br><span class="line">        &#x2F;&#x2F;注意 border后面的</span><br><span class="line">        style: solid; </span><br><span class="line">        width: 1px;      </span><br><span class="line">        color: #ccc;      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  &#x2F;&#x2F;样式嵌套</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#main p &#123;   </span><br><span class="line">    color: #00ff00;</span><br><span class="line">    width: 97%;</span><br><span class="line">    .redbox &#123;</span><br><span class="line">        background-color: #ff0000;     </span><br><span class="line">        color: #000000;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nav&#123; border: 1px solid #ccc;&#125; </span><br><span class="line">#main p &#123;color: #00ff00;width: 97%; &#125; </span><br><span class="line">#main p .redbox &#123; background-color: #ff0000; color: #000000; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="引用父元素-amp"><a href="#引用父元素-amp" class="headerlink" title="引用父元素(&amp;)"></a>引用父元素(&amp;)</h4><p>在写sass过程中，有时需要使用父元素，可是由于嵌套的格式，父元素嵌套着子元素，这时，可以用&amp;来代替需要引用的父元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#123; 　　　　</span><br><span class="line">    &amp;:hover &#123; color: #ffb3ff; &#125; </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;相当于  a:hover&#123;color: #ffb3ff&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量($)"></a>定义变量($)</h4><p>在sass中可以定义变量，变量以美元符号开头，不在嵌套中定义的变量是全局变量，可以在任何地方使用，在嵌套中定义的变量只能在嵌套中使用。将局部变量转换为全局变量可以在Value后面添加[!global]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$blue : #1875e7;　 　　</span><br><span class="line">div &#123;        </span><br><span class="line">    $height: 10px!global;       </span><br><span class="line">    $width: 5px; 　　　</span><br><span class="line">    color : $blue;      </span><br><span class="line">    width: $width; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取定义得变量"><a href="#取定义得变量" class="headerlink" title="取定义得变量(#{?})"></a>取定义得变量(#{?})</h4><p>如果变量需要镶嵌在字符串中，要放在插值语句 #{ }里面，插值语句 #{ }可以sass中的任何地方使用。比如插值属性名，和插值属性值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$side : left; 　　</span><br><span class="line">.rounded &#123; 　　　　</span><br><span class="line">border-#&#123;$side&#125;-radius: 5px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性值可以是css里面的属性名，字sass中比较灵活，在定义的属性值中可以是css中的属性值，一遍我们使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$color-red: #f00; </span><br><span class="line">$border-color: green; </span><br><span class="line">$side: left;&#x2F;&#x2F;值是css属性名。  </span><br><span class="line">border-#&#123;$side&#125;-radius: 5px;  &#x2F;&#x2F;相当于border-left-radius: 5px;</span><br></pre></td></tr></table></figure>

<h4 id="代码中使用算式"><a href="#代码中使用算式" class="headerlink" title="代码中使用算式"></a>代码中使用算式</h4><p>比如把一个宽为100%的元素分成3分，每份根本不知怎么分配，一点都不好计算。而sass可以直接运用算式可以很轻松的解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123; 　　</span><br><span class="line">    margin: (14px&#x2F;2); 　　</span><br><span class="line">    top: 50px + 100px; 　　</span><br><span class="line">    right: $var * 10%; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sass注释"><a href="#sass注释" class="headerlink" title="sass注释"></a>sass注释</h4><p>sass中有时也要使用注释，支持/* */ 与 // 的注释，而他们之间却被编译之后却会有不同的效果</p>
<ul>
<li>/* comment */  //会保留到编译后的文件。</li>
<li>单行注释: comment  //只保留在SASS源文件中，编译后被省略。</li>
<li>在/<em>后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会独占一行，保留这条注释，通常可以用于声明版权信息。<br>/</em>!  　　　　重要注释！ */</li>
</ul>
<h3 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a>代码的重用</h3><h4 id="类的继承-extend"><a href="#类的继承-extend" class="headerlink" title="类的继承(@extend)"></a>类的继承(@extend)</h4><p>在写css的时候，通常会遇到两个元素样式一样的情况，但是其中一个元素又添加了额外的样式，在sass中可以直接使用@extend来引用另外另外一个元素完全的样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class1 &#123; 　　　　</span><br><span class="line">border: 1px solid #ddd; &#125;  </span><br><span class="line"> </span><br><span class="line">.class2 &#123; 　　　　</span><br><span class="line">@extend .class1; 　　　　</span><br><span class="line">font-size:120%; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="混合模式-mixin-amp-amp-include"><a href="#混合模式-mixin-amp-amp-include" class="headerlink" title="混合模式(@mixin &amp;&amp; @include)"></a>混合模式(@mixin &amp;&amp; @include)</h4><p>既然可以用@extend引用一个元素的样式代码块，那会不会存在一个代码块，需要被多处使用？在写项目的过程中，肯定会有，比如flex样式，就经常重复写。在sass中，用@mixin 命令定义一个代码块， 解决了这个问题，使用@include命令调用这个代码块，使得定义好的代码块加入到项目中，避免了从复书写的麻烦和。让经常重复书写的代码块只需要写一次就好，多次被@include加到项目中。定义的代码块不会被编译，不会出现在.css文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@mixin flex &#123; 　　　　</span><br><span class="line">    float: left; 　　　　</span><br><span class="line">    margin-left: 10px; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">div &#123; 　　　　</span><br><span class="line">    @include flex; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@mixin 强大之处不仅可以定义代码块，还可以加入一个或者多个参数，把它封装成一个“函数”，在调用的时候加入参数可以灵活多变地被调用，如果使用默认值可以不填参数项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@mixin left($value: 10px) &#123; 　　　　</span><br><span class="line">    float: left; 　　　　</span><br><span class="line">    margin-right: $value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候可以根据需要加入参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;     </span><br><span class="line">    @include left(100px) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引入引用-import"><a href="#引入引用-import" class="headerlink" title="引入引用(@import)"></a>引入引用(@import)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;path&#x2F;filename.scss&quot;; &#x2F;&#x2F;相当于 @import url(test.css);</span><br></pre></td></tr></table></figure>

<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="if"><a href="#if" class="headerlink" title="@if"></a>@if</h4><p>@if就像js里面的判断语句if，判断是否符合条件，如果返回的结果是true，才会输出{}里面的代码块，否则不会输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;  </span><br><span class="line">    @if 1 + 1 &#x3D;&#x3D; 2 &#123; border: 1px solid; &#125;   </span><br><span class="line">    @if 5 &lt; 3 &#123; border: 2px dotted; &#125;   </span><br><span class="line">    @if null  &#123; border: 3px double; &#125; </span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F;编译后p &#123;border: 1px solid; &#125;</span><br></pre></td></tr></table></figure>
<p>这个用法也可以用于自适应，判断屏幕的宽度，从而对应输出适应各种屏幕的样式代码块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@if $container-width &lt; 960&#123;   </span><br><span class="line">    width: $container-width - 300px;   </span><br><span class="line">    background-color: red; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="else"><a href="#else" class="headerlink" title="@else"></a>@else</h4><p>这个也是相当于js语法里面的else语句，如果 if 语句的条件为false，则执行该代码块。@if后面可以跟多个@if else，当@if else的判断全部都为false时，左后执行@else代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@if lightness($color) &gt; 30% &#123; 　　　　</span><br><span class="line">    background-color: #000; 　　</span><br><span class="line">&#125; @else &#123; 　　　　</span><br><span class="line">    background-color: #fff; 　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="@for"></a>@for</h4><p>@for也是相当于JavaScript for 循环，可以将代码快执行指定的次数，在这个格式里面，要存在一个变量，例子中就是$i，存在一个循环的范围，$i from 1 to 10，在这个范围里面循环执行{}里面的代码快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@for $i from 1 through 3 &#123;   </span><br><span class="line">    .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;编译为 </span><br><span class="line">.item-1 &#123;   width: 2em; &#125; </span><br><span class="line">.item-2 &#123;   width: 4em; &#125; </span><br><span class="line">.item-3 &#123;   width: 6em; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="while"><a href="#while" class="headerlink" title="@while"></a>@while</h4><p>@while循环同样也等同于JavaScript while 循环，判断条件，符合则执行下面的代码快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$i: 6; 　　</span><br><span class="line">@while $i &gt; 0 &#123; 　　　　</span><br><span class="line">    .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; 　　　　</span><br><span class="line">    $i: $i - 2; 　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="each"><a href="#each" class="headerlink" title="@each"></a>@each</h4><p>@each等同与each（）方法，使每个匹配的元素都执行{}代码块。在@each用法里会存在一个值列表，更像是一个数组，将变量作用于数组的每一项，对应输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@each $member in a, b, c, d &#123; 　　　　</span><br><span class="line">.#&#123;$member&#125; &#123; 　　　　　　</span><br><span class="line">background-image: url(&quot;&#x2F;image&#x2F;#&#123;$member&#125;.jpg&quot;); 　　　　</span><br><span class="line">  &#125; 　　</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;编译后   </span><br><span class="line">.a&#123;background-image: url(&quot;&#x2F;image&#x2F;#&#123;$member&#125;.jpg&quot;);&#125;   </span><br><span class="line">.b&#123;background-image: url(&quot;&#x2F;image&#x2F;#&#123;$member&#125;.jpg&quot;);&#125;   </span><br><span class="line">.c&#123;background-image: url(&quot;&#x2F;image&#x2F;#&#123;$member&#125;.jpg&quot;);&#125;   </span><br><span class="line">.d&#123;background-image: url(&quot;&#x2F;image&#x2F;#&#123;$member&#125;.jpg&quot;);&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>在sass中还可以使用@function自定义函数，和@mixin一样，可以使用一个或者多个参数，更像javascript中的function函数，@function定义的函数可以包含多条语句，需要使用@return输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@function double($n) &#123; 　　　　</span><br><span class="line">    @return $n * 2; 　　</span><br><span class="line">&#125; 　　</span><br><span class="line"></span><br><span class="line">#sidebar &#123; </span><br><span class="line">    width: double(5px);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译后   </span><br><span class="line">#sidebar &#123; 　　　　</span><br><span class="line">    width: 10px; 　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.所有变量用$声明；<br>2.用&amp;代替父元素。<br>3.镶嵌在属性中的变量用#{};</p>
<ul>
<li>继承类名用： @extend .类名；</li>
<li>声明代码块用：@mixin 名 (变量参数){  }；</li>
<li>引用代码快：@include 名；</li>
<li>定义函数@function 函数名(变量参数){ @return 输出语句 }</li>
</ul>
<h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><h2 id="Sass和Less的比较"><a href="#Sass和Less的比较" class="headerlink" title="Sass和Less的比较"></a>Sass和Less的比较</h2><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><h4 id="Less环境较Sass简单"><a href="#Less环境较Sass简单" class="headerlink" title="Less环境较Sass简单"></a>Less环境较Sass简单</h4><p>Cass的安装需要安装Ruby环境，Less基于JavaScript，是需要引入Less.js来处理代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放在项目中，有less.app、SimpleLess、CodeKit.app这样的工具，也有在线编辑地址</p>
<h4 id="Less使用较Sass简单"><a href="#Less使用较Sass简单" class="headerlink" title="Less使用较Sass简单"></a>Less使用较Sass简单</h4><p>LESS 并没有裁剪 CSS 原有的特性，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。只要你了解 CSS 基础就可以很容易上手</p>
<h4 id="从功能出发，Sass较Less略强大一些"><a href="#从功能出发，Sass较Less略强大一些" class="headerlink" title="从功能出发，Sass较Less略强大一些"></a>从功能出发，Sass较Less略强大一些</h4><ul>
<li>sass有变量和作用域。</li>
</ul>
<p>-$variable，like php；<br>-#｛$variable｝like ruby；<br>-变量有全局和局部之分，并且有优先级。</p>
<ul>
<li>sass有函数的概念；</li>
</ul>
<p>-@function和@return以及函数参数（还有不定参）可以让你像js开发那样封装你想要的逻辑。<br>-@mixin类似function但缺少像function的编程逻辑，更多的是提高css代码段的复用性和模块化，这个用的人也是最多的。<br>-ruby提供了非常丰富的内置原生api。</p>
<ul>
<li>进程控制：</li>
</ul>
<p>-条件：@if @else；<br>-循环遍历：@for @each @while<br>-继承：@extend<br>-引用：@import</p>
<ul>
<li>数据结构：</li>
</ul>
<p>-$list类型=数组；<br>-$map类型=object；<br>其余的也有string、number、function等类型</p>
<h4 id="Less与Sass处理机制不一样"><a href="#Less与Sass处理机制不一样" class="headerlink" title="Less与Sass处理机制不一样"></a>Less与Sass处理机制不一样</h4><p>前者是通过客户端处理的，后者是通过服务端处理，相比较之下前者解析会比后者慢一点</p>
<h4 id="关于变量在Less和Sass中的唯一区别就是Less用-，Sass用-。"><a href="#关于变量在Less和Sass中的唯一区别就是Less用-，Sass用-。" class="headerlink" title="关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。"></a>关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。</h4><h3 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h3><p>Less和Sass在语法上有些共性，比如下面这些：</p>
<ul>
<li>混入(Mixins)——class中的class；</li>
<li>参数混入——可以传递参数的class，就像函数一样；</li>
<li>嵌套规则——Class中嵌套class，从而减少重复的代码；</li>
<li>运算——CSS中用上数学；</li>
<li>颜色功能——可以编辑颜色；</li>
<li>名字空间(namespace)——分组样式，从而可以被调用；</li>
<li>作用域——局部修改样式；</li>
<li>JavaScript 赋值——在CSS中使用JavaScript表达式赋值</li>
</ul>
<h2 id="为什么选择使用Sass而不是Less"><a href="#为什么选择使用Sass而不是Less" class="headerlink" title="为什么选择使用Sass而不是Less"></a>为什么选择使用Sass而不是Less</h2><ul>
<li>Sass在市面上有一些成熟的框架，比如说Compass，而且有很多框架也在使用Sass，比如说Foundation。</li>
<li>就国外讨论的热度来说，Sass绝对优于LESS。</li>
<li>就学习教程来说，Sass的教程要优于LESS。在国内LESS集中的教程是LESS中文官网，而Sass的中文教程，慢慢在国内也较为普遍。</li>
<li>Sass也是成熟的CSS预处理器之一，而且有一个稳定，强大的团队在维护。</li>
<li>同时还有Scss对sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。</li>
<li>bootstrap（Web框架）最新推出的版本4，使用的就是Sass</li>
</ul>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/10/04/FroEnd-Vue/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>npm 命令参数的区别</title>
    <url>/2019/01/06/FroEnd-npm%20%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><pre><code>npm init :创建package.json这个文件
npm run dev :执行npm script中的命令
npm install moduleName ： 安装模块到项目目录下
npm install moduleName -g： -g 将模块安装到全局，具体安装到磁盘哪个位置，要看npm config prefix的位置。查看：npm config ls,修改：npm config set prefix.
npm install moduleName --save：（简写：-S） -save 将模块安装到项目目录下，并在package文件的dependencies属性写入依赖。
npm install moduleName --save-dev ：（简写：-D） -save-dev 将模块安装到项目目录下，并在package文件的devDependencies属性写入依赖。</code></pre><h2 id="命令的区别"><a href="#命令的区别" class="headerlink" title="命令的区别"></a>命令的区别</h2><p>   npm install moduleName 命令<br>    1. 安装模块到项目node_modules目录下。<br>    2. 不会修改package.json文件。<br>    3. 运行 npm install 初始化项目时不会下载模块。</p>
<pre><code>npm install moduleName -g 命令
1. 安装模块到全局，不会在项目node_modules目录中保存模块包。
2. 不会修改package.json文件。
3. 运行 npm install 初始化项目时不会下载模块。

npm install moduleName --save 命令
1. 安装模块到项目node_modules目录下。
2. 会在package.json文件的dependencies 属性将模块依赖写入。
3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。
4. 运行npm install --production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。

npm install  moduleName --save-dev 命令
1. 安装模块到项目node_modules目录下。
2. 会在package.json文件的devDependencies 属性将模块依赖写入。
3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。
4. 运行npm install --production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用原则:运行时需要用到的包使用–save，否则使用–save-dev。<br>devDependencies 属性下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。<br>像 express 这些模块是项目运行必备的，应该安装在 dependencies 属性下，所以我们应该使用 -save 的形式安装。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm安装（Windows篇）</title>
    <url>/2021/01/05/FroEnd-nvm%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><ul>
<li>node version manager（node版本管理工具）.通过将多个node 版本安装在指定路径，然后通过 nvm 命令切换时，就会切换我们环境变量中 node 命令指定的实际执行的软件路径。<br>使用场景：比如我们手上同时在做好几个项目，这些项目的需求都不太一样，导致了这些个项目需要依赖的nodejs版本也不同，这种情况下，我们就可以通过nvm来切换nodejs的版本，而不需要频繁地下载/卸载不同版本nodejs来满足当前项目的要求</li>
<li><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">windows系统下的nvm 安装</a></li>
</ul>
<h2 id="常用nvm命令"><a href="#常用nvm命令" class="headerlink" title="常用nvm命令"></a>常用nvm命令</h2><ul>
<li><p>nvm list 命令 - 显示版本列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm list &#x2F;&#x2F; 显示已安装的版本（同 nvm list installed）</span><br><span class="line">nvm list installed &#x2F;&#x2F; 显示已安装的版本</span><br><span class="line">nvm list available &#x2F;&#x2F; 显示所有可以下载的版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>nvm install 命令 - 安装指定版本nodejs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install 14.5.0 &#x2F;&#x2F; 安装14.5.0版本node</span><br><span class="line">nvm install latest &#x2F;&#x2F; 安装最新版本node</span><br></pre></td></tr></table></figure>
</li>
<li><p>nvm use 命令 - 使用指定版本node<br>nvm use 14.5.0 // 使用14.5.0版本node</p>
</li>
<li><p>nvm uninstall 命令 - 卸载指定版本 node<br>nvm uninstall 14.5.0 // 卸载14.5.0版本node</p>
</li>
</ul>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol>
<li>nvm arch ：显示node是运行在32位还是64位系统上的</li>
<li>nvm on ：开启nodejs版本管理</li>
<li>nvm off ：关闭nodejs版本管理</li>
<li>nvm proxy [url] ：设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。</li>
<li>nvm node_mirror [url] ：<a href="https://nodejs.org/dist/" target="_blank" rel="noopener">默认node镜像</a>如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。</li>
<li>nvm npm_mirror [url] ：[默认npm镜像](<a href="https://github.com/npm/cli/archive/]如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。" target="_blank" rel="noopener">https://github.com/npm/cli/archive/]如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。</a></li>
<li>nvm root [path] ：设置存储不同版本node的目录。如果未设置，默认使用当前目录。</li>
<li>nvm version ：显示nvm版本。version可简化为v。</li>
</ol>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>Node-JS</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录演变(原理与实现简介)</title>
    <url>/2020/09/12/FroEnd-%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86(SSO)/</url>
    <content><![CDATA[<h2 id="Single-Sign-On"><a href="#Single-Sign-On" class="headerlink" title="Single Sign On"></a>Single Sign On</h2><p><a href="https://blog.csdn.net/yuxin6866/article/details/73522312" target="_blank" rel="noopener">单点登陆四种方案</a></p>
<h2 id="web系统登录演变"><a href="#web系统登录演变" class="headerlink" title="web系统登录演变"></a>web系统登录演变</h2><h3 id="单系统登录机制"><a href="#单系统登录机制" class="headerlink" title="单系统登录机制"></a>单系统登录机制</h3><p>web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系<br><img src="/web/1.png" alt="单系统登录机制"></p>
<p>但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制</p>
<h4 id="会话机制"><a href="#会话机制" class="headerlink" title="会话机制"></a>会话机制</h4><p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联<br><img src="/web/2.png" alt="会话机制"></p>
<p>服务器在内存中保存会话对象，浏览器怎么保存会话id呢？</p>
<ul>
<li>请求参数:将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。</li>
<li>cookie:那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息<br>　　tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图</li>
</ul>
<p><img src="/web/3.png" alt="会话机制"></p>
<h4 id="登录状态"><a href="#登录状态" class="headerlink" title="登录状态"></a>登录状态</h4><p>有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次登陆</span><br><span class="line">HttpSession session &#x3D; request.getSession();</span><br><span class="line">session.setAttribute(&quot;isLogin&quot;, true);</span><br><span class="line">&#x2F;&#x2F;用户再次访问时，tomcat在会话对象中查看登录状态</span><br><span class="line">HttpSession session &#x3D; request.getSession();</span><br><span class="line">session.getAttribute(&quot;isLogin&quot;);</span><br></pre></td></tr></table></figure>

<p>实现了登录状态的浏览器请求服务器模型如下图描述<br><img src="/web/4.png" alt="登录状态"></p>
<p>每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。</p>
<h3 id="多系统的登录机制"><a href="#多系统的登录机制" class="headerlink" title="多系统的登录机制"></a>多系统的登录机制</h3><p>web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样<br><img src="/web/5.png" alt="多系统的登录机制"></p>
<p>web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了<br><img src="/web/6.png" alt="多系统的登录机制"></p>
<h4 id="多系统存在的问题"><a href="#多系统存在的问题" class="headerlink" title="多系统存在的问题"></a>多系统存在的问题</h4><p>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？<br>问题:多系统的域不同，因跨域导致cookie不能维护会话状态</p>
<h3 id="单点登录机制-SSO"><a href="#单点登录机制-SSO" class="headerlink" title="单点登录机制(SSO)"></a>单点登录机制(SSO)</h3><p>什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分</p>
<h4 id="单点登录解决什么问题"><a href="#单点登录解决什么问题" class="headerlink" title="单点登录解决什么问题"></a>单点登录解决什么问题</h4><h5 id="解决多系统cookie保持会话问题"><a href="#解决多系统cookie保持会话问题" class="headerlink" title="解决多系统cookie保持会话问题"></a>解决多系统cookie保持会话问题</h5><p><font color ="red">单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</font><br><img src="/web/7.png" alt="单系统登录机制"></p>
<p>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。然而，可行并不代表好，共享cookie的方式存在众多局限。</p>
<ul>
<li>应用群域名得统一；</li>
<li>其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；</li>
<li>第三，cookie本身不安全。<br>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录</li>
</ul>
<h5 id="Cookie跨域问题"><a href="#Cookie跨域问题" class="headerlink" title="Cookie跨域问题"></a>Cookie跨域问题</h5><p>上面我们解决了Session不能共享的问题，但其实还有另一个问题。Cookie是不能跨域的<br>比如说，我们请求 <a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a> 时，浏览器会自动把google.com的Cookie带过去给google的服务器，而不会把 <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> 的Cookie带过去给google的服务器。这就意味着，由于域名不同，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p>
<p>针对Cookie存在跨域问题，有几种解决方案：</p>
<ol>
<li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li>
<li>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。</li>
<li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）<br>到这里，我们已经可以实现单点登录了</li>
</ol>
<h4 id="登录原理"><a href="#登录原理" class="headerlink" title="登录原理"></a>登录原理</h4><p>　　相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明:<br>下面对上图简要描述<br><img src="/web/8.png" alt="单系统登录机制"></p>
<ol>
<li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户未登录，将用户引导至登录页面</li>
<li>用户输入用户名密码提交登录申请</li>
<li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</li>
<li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li>
<li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统1</li>
<li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li>
<li>用户访问系统2的受保护资源</li>
<li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li>
<li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统2</li>
<li>系统2使用该令牌创建与用户的局部会话，返回受保护资源<br>　　<br>　　用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</li>
<li>局部会话存在，全局会话一定存在</li>
<li>全局会话存在，局部会话不一定存在</li>
<li>全局会话销毁，局部会话必须销毁</li>
</ol>
<p>你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数</p>
<h4 id="注销原理"><a href="#注销原理" class="headerlink" title="注销原理"></a>注销原理</h4><p>　　单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明<br><img src="/web/9.png" alt="单系统登录机制"></p>
<h3 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h3><p>　　单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述<br><img src="/web/10.png" alt="单系统登录机制"></p>
<p>sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>　　只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）</p>
<h4 id="sso-client"><a href="#sso-client" class="headerlink" title="sso-client"></a>sso-client</h4><ol>
<li>拦截子系统未登录用户请求，跳转至sso认证中心</li>
<li>接收并存储sso认证中心发送的令牌</li>
<li>与sso-server通信，校验令牌的有效性</li>
<li>建立局部会话</li>
<li>拦截用户注销请求，向sso认证中心发送注销请求</li>
<li>接收sso认证中心发出的注销请求，销毁局部会话</li>
</ol>
<h4 id="sso-server"><a href="#sso-server" class="headerlink" title="sso-server"></a>sso-server</h4><ol>
<li>验证用户的登录信息</li>
<li>创建全局会话</li>
<li>创建授权令牌</li>
<li>与sso-client通信发送令牌</li>
<li>校验sso-client令牌有效性</li>
<li>系统注册</li>
<li>接收sso-client注销请求，注销所有会话</li>
</ol>
<h4 id="实现sso"><a href="#实现sso" class="headerlink" title="实现sso"></a>实现sso</h4><h5 id="sso-client拦截未登录请求"><a href="#sso-client拦截未登录请求" class="headerlink" title="sso-client拦截未登录请求"></a>sso-client拦截未登录请求</h5><p>　　java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest req &#x3D; (HttpServletRequest) request;</span><br><span class="line">    HttpServletResponse res &#x3D; (HttpServletResponse) response;</span><br><span class="line">    HttpSession session &#x3D; req.getSession();</span><br><span class="line">     </span><br><span class="line">    if (session.getAttribute(&quot;isLogin&quot;)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;跳转至sso认证中心</span><br><span class="line">    res.sendRedirect(&quot;sso-server-url-with-system-url&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sso-server拦截未登录请求"><a href="#sso-server拦截未登录请求" class="headerlink" title="sso-server拦截未登录请求"></a>sso-server拦截未登录请求</h5><p>拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样</p>
<h5 id="sso-server验证用户登录信息"><a href="#sso-server验证用户登录信息" class="headerlink" title="sso-server验证用户登录信息"></a>sso-server验证用户登录信息</h5><p>用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">public String login(String username, String password, HttpServletRequest req) &#123;</span><br><span class="line">    this.checkLoginInfo(username, password);</span><br><span class="line">    req.getSession().setAttribute(&quot;isLogin&quot;, true);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sso-server创建授权令牌"><a href="#sso-server创建授权令牌" class="headerlink" title="sso-server创建授权令牌"></a>sso-server创建授权令牌</h5><p>授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子<br>String token = UUID.randomUUID().toString();</p>
<h5 id="sso-client取得令牌并校验"><a href="#sso-client取得令牌并校验" class="headerlink" title="sso-client取得令牌并校验"></a>sso-client取得令牌并校验</h5><p>sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 请求附带token参数</span><br><span class="line">String token &#x3D; req.getParameter(&quot;token&quot;);</span><br><span class="line">if (token !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 去sso认证中心校验token</span><br><span class="line">    boolean verifyResult &#x3D; this.verify(&quot;sso-server-verify-url&quot;, token);</span><br><span class="line">    if (!verifyResult) &#123;</span><br><span class="line">        res.sendRedirect(&quot;sso-server-url&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HttpPost httpPost &#x3D; new HttpPost(&quot;sso-server-verify-url-with-token&quot;);</span><br><span class="line">HttpResponse httpResponse &#x3D; httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure>

<h5 id="sso-server接收并处理校验令牌请求"><a href="#sso-server接收并处理校验令牌请求" class="headerlink" title="sso-server接收并处理校验令牌请求"></a>sso-server接收并处理校验令牌请求</h5><p>　　用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）<br>　　令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。<br>　　令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话</p>
<p><img src="/web/11.png" alt="单系统登录机制"></p>
<h5 id="sso-client校验令牌成功创建局部会话"><a href="#sso-client校验令牌成功创建局部会话" class="headerlink" title="sso-client校验令牌成功创建局部会话"></a>sso-client校验令牌成功创建局部会话</h5><p>令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (verifyResult) &#123;</span><br><span class="line">    session.setAttribute(&quot;isLogin&quot;, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求</p>
<h5 id="注销过程"><a href="#注销过程" class="headerlink" title="注销过程"></a>注销过程</h5><p>　用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String logout &#x3D; req.getParameter(&quot;logout&quot;);</span><br><span class="line">if (logout !&#x3D; null) &#123;</span><br><span class="line">    this.ssoServer.logout(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;logout&quot;)</span><br><span class="line">public String logout(HttpServletRequest req) &#123;</span><br><span class="line">    HttpSession session &#x3D; req.getSession();</span><br><span class="line">    if (session !&#x3D; null) &#123;</span><br><span class="line">        session.invalidate();&#x2F;&#x2F;触发LogoutListener</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;redirect:&#x2F;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LogoutListener implements HttpSessionListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sessionCreated(HttpSessionEvent event) &#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void sessionDestroyed(HttpSessionEvent event) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过httpClient向所有注册系统发送注销请求</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>SSO</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>package打包</title>
    <url>/2019/10/30/FroEnd-%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><h3 id="0配置的打包工具parcel"><a href="#0配置的打包工具parcel" class="headerlink" title="0配置的打包工具parcel"></a>0配置的打包工具parcel</h3><p><a href="https://parceljs.org/" target="_blank" rel="noopener">点击进入parcel官网</a><br><a href="https://parceljs.org/getting_started.html" target="_blank" rel="noopener">Parcel文档</a><br><a href="https://github.com/parcel-bundler/parcel" target="_blank" rel="noopener">parcel的GitHub</a></p>
<h2 id="WebPack"><a href="#WebPack" class="headerlink" title="WebPack"></a>WebPack</h2><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack官网</a></p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>parcel</tag>
      </tags>
  </entry>
  <entry>
    <title>实现扫码登录的方案与原理</title>
    <url>/2021/02/19/FroEnd-%E6%89%AB%E7%A0%81%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h2 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h2><h3 id="网页端-服务器"><a href="#网页端-服务器" class="headerlink" title="网页端+服务器"></a>网页端+服务器</h3><p>接下来就是对于这个服务的详细实现。首先，大概说一下原理：用户打开网站的登录页面的时候，向浏览器的服务器发送获取登录二维码的请求。<br>服务器收到请求后，随机生成一个uuid，将这个id作为key值存入redis服务器，同时设置一个过期时间，再过期后，用户登录二维码需要进行刷新重新获取。同时，将这个key值和本公司的验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片（二维码生成，网上有很多现成的接口和源码，这里不再介绍。）然后，将二维码图片和uuid一起返回给用户浏览器。<br>浏览器拿到二维码和uuid后，会每隔一秒向浏览器发送一次，登录是否成功的请求。请求中携带有uuid作为当前页面的标识符。这里有的同学就会奇怪了，服务器只存了个uuid在redis中作为key值，怎么会有用户的id信息呢？<br>这里确实会有用户的id信息，这个id信息是由手机服务器存入redis中的。</p>
<h3 id="手机端-服务器"><a href="#手机端-服务器" class="headerlink" title="手机端+服务器"></a>手机端+服务器</h3><p>话说，浏览器拿到二维码后，将二维码展示到网页上，并给用户一个提示：请掏出您的手机，打开扫一扫进行登录。用户拿出手机扫描二维码，就可以得到一个验证信息和一个uuid（扫描二维码获取字符串的功能在网上同样有很多demo，这里就不详细介绍了）。<br>由于手机端已经进行过了登录，在访问手机端的服务器的时候，参数中都回携带一个用户的token，手机端服务器可以从中解析到用户的userId（这里从token中取值而不是手机端直接传userid是为了安全，直接传userid可能会被截获和修改，token是加密的，被修改的风险会小很多）。<br>手机端将解析到的数据和用户token一起作为参数，向服务器发送验证登录请求（这里的服务器是手机服务器，手机端的服务器跟网页端服务器不是同一台服务器）。服务器收到请求后，首先对比参数中的验证信息，确定是否为用户登录请求接口。如果是，返回一个确认信息给手机端。<br>手机端收到返回后，将登录确认框显示给用户（防止用户误操作，同时使登录更加人性化）。用户确认是进行的登录操作后，手机再次发送请求。服务器拿到uuId和userId后，将用户的userid作为value值存入redis中以uuid作为key的键值对中。</p>
<h3 id="登录成功"><a href="#登录成功" class="headerlink" title="登录成功"></a>登录成功</h3><p>然后，浏览器再次发送请求的时候，浏览器端的服务器就可以得到一个用户Id，并调用登录的方法，声成一个浏览器端的token，再浏览器再次发送请求的时候，将用户信息返回给浏览器，登录成功。这里存储用户id而不是直接存储用户信息是因为，手机端的用户信息，不一定是和浏览器端的用户信息完全一致。</p>
<h2 id="登录原理图如下"><a href="#登录原理图如下" class="headerlink" title="登录原理图如下"></a>登录原理图如下</h2><p><img src="/frontend/%E6%89%AB%E7%A0%81%E7%99%BB%E9%99%86.png" alt="扫码登陆" title="扫码登陆"></p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>扫码登陆</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈SPA&amp;&amp;SEO&amp;&amp;SSR</title>
    <url>/2019/11/09/FroEnd-%E6%B5%85%E8%B0%88SPA&amp;&amp;SEO&amp;&amp;SSR/</url>
    <content><![CDATA[<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>SPA全称是 single page application (在百度百科和一些文章中使用的是 single page web application，经过一番查询了解，我觉得single page application才应该是它的全称)。<br>SPA是一种 网络应用程序(WebApp)模型。在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而在SPA这个模型中，是通过动态地重写页面的部分与用户交互，而避免了过多的数据交换，响应速度自然相对更高。</p>
<h3 id="SPA框架"><a href="#SPA框架" class="headerlink" title="SPA框架"></a>SPA框架</h3><p>AngularJS<br>React<br>Vue.js</p>
<h3 id="SPA的优点"><a href="#SPA的优点" class="headerlink" title="SPA的优点"></a>SPA的优点</h3><p>基本上前面所说的前后端分离的优点它都有，另外还有以下的一些优点</p>
<p>页面之间的切换非常快<br>一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染）<br>后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等</p>
<h3 id="SPA的缺点"><a href="#SPA的缺点" class="headerlink" title="SPA的缺点"></a>SPA的缺点</h3><p>首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。<br>不利于SEO</p>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p>之前对于SEO的了解不多，也是最近才对SEO有了一些基本的了解。SEO（Search Engine Optimization），中文一般译作：搜索引擎优化。SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。</p>
<p>前面我们谈到的SPA不利于SEO，因为就目前而言，部分搜索引擎如Google、bing等，它们的爬虫虽然已经支持执行JS甚至是通过AJAX获取数据了，但是对于异步数据的支持也还不足(也可能是搜索引擎提供商觉得没必要)</p>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>SSR是 Server-Side Rendering(服务器端渲染)的缩写，在普通的SPA中，一般是将框架及网站页面代码发送到浏览器，然后在浏览器中生成和操作DOM（这里也是第一次访问SPA网站在同等带宽及网络延迟下比传统的在后端生成HTML发送到浏览器要更慢的主要原因），但其实也可以将SPA应用打包到服务器上，在服务器上渲染出HTML，发送到浏览器，这样的HTML页面还不具备交互能力，所以还需要与SPA框架配合，在浏览器上“混合”成可交互的应用程序。所以，只要能合理地运用SSR技术，不仅能一定程度上解决首屏慢的问题，还能获得更好的SEO。</p>
<h3 id="SSR的优点"><a href="#SSR的优点" class="headerlink" title="SSR的优点"></a>SSR的优点</h3><p>更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了。这个个人深有体会，我的博客最开始仅仅使用了Vue.js，而没有做服务端渲染，加之服务器不在大陆，第一次输入地址到看到完整的页面几乎是过了4、5秒，有时候还更长。<br>更好的SSR，我们可以将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据</p>
<h3 id="SSR的缺点"><a href="#SSR的缺点" class="headerlink" title="SSR的缺点"></a>SSR的缺点</h3><p>相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源<br>一些常用的浏览器API可能无法正常使用，比如window、docment和alert等，如果使用的话需要对运行的环境加以判断<br>开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂<br>可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致。</p>
<h3 id="SSR常用框架"><a href="#SSR常用框架" class="headerlink" title="SSR常用框架"></a>SSR常用框架</h3><p><a href="https://nextjs.org/" target="_blank" rel="noopener">React 的 Next</a><br><a href="https://nuxtjs.org/" target="_blank" rel="noopener">Vue.js 的 Nuxt</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前后端分离降低了前端和后端的耦合度，提高了开发效率；<br>SPA是前后端分离中前端的一种解决方案；<br>SEO对与很多网站很重要而普通的SPA又不利于SEO；<br>SSR的出现一定程度上解决了SPA中首屏慢的问题，又极大减少了普通SPA对于SEO的不利影响。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>FrameWork</tag>
      </tags>
  </entry>
  <entry>
    <title>测试工具Jest/enzyme.md</title>
    <url>/2019/12/06/FroEnd-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Jest&amp;enzyme/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Jest 是Facebook的一个专门进行Javascript单元测试的工具，这些应用当然也包括了 React 应用。它的优点之一是自带了对 React 的支持，同时也很容易支持其它框架。<br><a href="https://segmentfault.com/a/1190000008628067" target="_blank" rel="noopener">Javascript单元测试工具-Jest 学习笔记</a><br><a href="基于Jest+Enzyme的React单元测试">基于Jest+Enzyme的React单元测试</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>npm i jest -D（安装到本地）<br>npm i jest -g（安装到全局）</p>
<h3 id="基本配置解读"><a href="#基本配置解读" class="headerlink" title="基本配置解读"></a>基本配置解读</h3><p>在package.json添加配置项”jest” : { 配置项 }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &quot;jest&quot;: &#123;</span><br><span class="line">  &quot;transform&quot;: &#123;</span><br><span class="line">    &quot;.(ts|tsx)&quot;: &quot;ts-jest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;testEnvironment&quot;: &quot;node&quot;,</span><br><span class="line">  &quot;testRegex&quot;: &quot;(&#x2F;__tests__&#x2F;.*|\\.(test|spec))\\.(ts|tsx|js)$&quot;,</span><br><span class="line">  &quot;moduleFileExtensions&quot;: [</span><br><span class="line">    &quot;ts&quot;,</span><br><span class="line">    &quot;tsx&quot;,</span><br><span class="line">    &quot;js&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;coveragePathIgnorePatterns&quot;: [</span><br><span class="line">    &quot;&#x2F;node_modules&#x2F;&quot;,</span><br><span class="line">    &quot;&#x2F;test&#x2F;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;coverageThreshold&quot;: &#123;</span><br><span class="line">    &quot;global&quot;: &#123;</span><br><span class="line">      &quot;branches&quot;: 90,</span><br><span class="line">      &quot;functions&quot;: 95,</span><br><span class="line">      &quot;lines&quot;: 95,</span><br><span class="line">      &quot;statements&quot;: 95</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;collectCoverageFrom&quot;: [</span><br><span class="line">    &quot;src&#x2F;*.&#123;js,ts&#125;&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置项的作用"><a href="#配置项的作用" class="headerlink" title="配置项的作用"></a>配置项的作用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform:简单地说就是一种转换器配置</span><br><span class="line">&quot;transform&quot;: &#123;</span><br><span class="line">    &quot;.(ts|tsx)&quot;: &quot;ts-jest&quot;,&#x2F;&#x2F;表示的就是ts-jest工具把.ts和.tsx文件内容转换成js，因为我们现在基本上也都是用ts去编写测试代码，所以要配置转换器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">testEnvironment:测试环境，默认值是：jsdom，可修改为node</span><br><span class="line">&quot;testEnvironment&quot;: &quot;node&quot;,&#x2F;&#x2F;表示它是一个类浏览器的测试环境，我们可以使用浏览器环境中的一些API</span><br><span class="line"></span><br><span class="line">testMatch:设置识别哪些文件是测试文件（glob形式），与testRegex互斥，不能同时写</span><br><span class="line">testMatch: [&#39;\*\*&#x2F;\_\_tests\_\_&#x2F;\*\*&#x2F;\*.js?(x)&#39;,&#39;\*\*&#x2F;?(*.)(spec|test).js?(x)&#39;]</span><br><span class="line"></span><br><span class="line">testRegex:要测试文件的正则表达式&#x2F;&#x2F;表示test目录下所有以.test.ts和.spec.ts的文件都需要跑测试</span><br><span class="line">&quot;testRegex&quot;: &quot;(&#x2F;__tests__&#x2F;.*|\\.(test|spec))\\.(ts|tsx|js)$&quot;,</span><br><span class="line"></span><br><span class="line">moduleFileExtensions:模块文件扩展名，当你去引入一个模块并没有指定拓展名的时候，它会依次尝试去添加这些扩展名去拟引入模块文件</span><br><span class="line">&quot;moduleFileExtensions&quot;: [&quot;ts&quot;, &quot;tsx&quot;,&quot;js&quot;,&#39;js&#39;,&#39;json&#39;,&#39;jsx&#39;,&#39;node&#39;],&#x2F;&#x2F;表示优先找.ts的模块，其次是.tsx和.js</span><br><span class="line"></span><br><span class="line">coverageThreshold:测试覆盖率的阈值设定，当我们的测试覆盖率达不到阈值的时候，测试会失败</span><br><span class="line">&#x2F;&#x2F;表示全局的代码分支覆盖率要达到90%以上，方法覆盖率达到95%，代码行数覆盖率达到95%，声明语句达到95%</span><br><span class="line">&quot;coverageThreshold&quot;: &#123;&quot;global&quot;: &#123;&quot;branches&quot;: 90,&quot;functions&quot;: 95,&quot;lines&quot;: 95,&quot;statements&quot;: 95&#125;&#125;,</span><br><span class="line"></span><br><span class="line">collectCoverageFrom:收集指定文件的测试覆盖率（即使你没为这些文件编写测试，它的值为glob patterns类型）</span><br><span class="line">&quot;collectCoverageFrom&quot;: [&quot;src&#x2F;*.&#123;js,ts&#125;&quot;]&#x2F;&#x2F;表示收集src目录以及所有组目录中的js和ts文件的测试覆盖率</span><br><span class="line"></span><br><span class="line">rootDir:默认值：当前目录，一般是package.json所在的目录。</span><br><span class="line">rootDir: &#39; &#39;</span><br><span class="line"></span><br><span class="line">setupFileAfterEnv:测试框架安装后立即执行的代码文件列表</span><br><span class="line">&#x2F;&#x2F;表示每次跑具体测试代码之前会先运行&#x2F;test&#x2F;boot.ts中的代码</span><br><span class="line">&#x2F;&#x2F;&lt;rootDir&gt;表示当前项目的根目录</span><br><span class="line">&quot;setupFileAfterEnv&quot;: [&quot;&lt;rootDir&gt;&#x2F;test&#x2F;boot.ts&quot;]</span><br><span class="line"></span><br><span class="line">一般配置：</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    testMatch: [&#39;&lt;rootDir&gt;&#x2F;test&#x2F;\*\*&#x2F;\*.js&#39;],</span><br><span class="line">    testEnvironment: &#39;jsdom&#39;,</span><br><span class="line">    rootDir: &#39;&#39;,</span><br><span class="line">    moduleFileExtensions: [&#39;js&#39;,&#39;json&#39;,&#39;jsx&#39;,&#39;node&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="config配置文件"><a href="#config配置文件" class="headerlink" title="config配置文件"></a>config配置文件</h3><p><a href="https://facebook.github.io/jest/docs/en/cli.html" target="_blank" rel="noopener">官方文档</a><br>jest.config.js<br>新建jest.config.js并添加配置项module.exports = { 配置项 }</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>npx jest（安装到本地的前提下）<br>jest（安装到全局的前提下） 修改”script” 中的”test” 为”jest”后使用npm run test</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>分组（Test Group）：descripe(描述语,function)<br>测试用例（Test Case）：test(描述语,function)<br>断言（Assert）：expect(运行需测试的方法并返回实际结果).toBe(预期结果)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; for example</span><br><span class="line">Pencil.query &#x3D;(name, url)&#x3D;&gt; &#123;  &#x2F;&#x2F;方法，返回捕获</span><br><span class="line">    &#x2F;&#x2F; ?hello&#x3D;test&amp;wonghan&#x3D;handsome</span><br><span class="line">    var reg &#x3D; new RegExp(&#39;(?:\\?|&amp;)&#39; + name + &#39;&#x3D;(.*?)(?:&amp;|$)&#39;)</span><br><span class="line">    var ret &#x3D; reg.exec(url) || []</span><br><span class="line">    return ret[1]</span><br><span class="line">&#125;</span><br><span class="line">test(&#39;query&#39;,()&#x3D;&gt;&#123;  &#x2F;&#x2F; testCase</span><br><span class="line">    &#x2F;&#x2F; 断言</span><br><span class="line">    expect(Pencil.query(&#39;hello&#39;, &#39;?hello&#x3D;test&#39;)).toBe(&#39;test&#39;)</span><br><span class="line">    expect(Pencil.query(&#39;hello&#39;, &#39;?hello2&#x3D;test&#39;)).toBe(undefined)  </span><br><span class="line">    &#x2F;&#x2F;可以写多个&#96;ecpect()&#96;</span><br><span class="line">&#125;)</span><br><span class="line">test(&#39;query2&#39;,()&#x3D;&gt;&#123;</span><br><span class="line">    expect(Pencil.query(&#39;hello&#x2F;test&#39;, &#39;?hello&#x2F;test&#x3D;test&#39;)).toBe(&#39;test&#39;)</span><br><span class="line">&#125;) </span><br><span class="line">    &#x2F;&#x2F;可以写多个&#96;test()&#96;</span><br><span class="line">describe(&#39;test query&#39;,()&#x3D;&gt;&#123;</span><br><span class="line">    test(&#39;query3&#39;,()&#x3D;&gt;&#123;  &#x2F;&#x2F; testCase</span><br><span class="line">        &#x2F;&#x2F; assert</span><br><span class="line">        expect(Pencil.query(&#39;hello&#39;, &#39;?hello&#x3D;test&#39;)).toBe(&#39;test&#39;)</span><br><span class="line">        expect(Pencil.query(&#39;hello&#39;, &#39;?hello2&#x3D;test&#39;)).toBe(undefined)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Jest-Matcher"><a href="#Jest-Matcher" class="headerlink" title="Jest Matcher"></a>Jest Matcher</h4><p>Matchers俗称断言库，例如上面的expect().toBe()便是其中之一，其他常见用法如下：</p>
<p>1.相等断言<br>toBe(value)： 比较数字、字符串<br>toEqual(value)： 比较对象、数组<br>toBeNull()<br>toBeUndefined()</p>
<p>2.包含断言<br>toHaveProperty(keyPath, value)： 是否有对应的属性<br>toContain(item)： 是否包含对应的值，括号里写上数组、字符串<br>toMatch(regexpOrString)： 括号里写上正则</p>
<p>3.逻辑断言<br>toBeTruthy()<br>toBeFalsy()<br>在JavaScript中，有六个falsy值：false，0，’’，null， undefined，和NaN。其他一切都是Truthy。</p>
<p>toBeGreaterThan(number)： 大于<br>toBeLessThan(number)： 小于</p>
<p>4.not<br>取反，用法见下面例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; for example</span><br><span class="line">test(&#39;matchers&#39;,()&#x3D;&gt;&#123;</span><br><span class="line">    const a &#x3D; &#123;</span><br><span class="line">        hello: &#39;jest&#39;,</span><br><span class="line">        hi :&#123;</span><br><span class="line">            name: &#39;jest&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">const b &#x3D; &#123;</span><br><span class="line">    hello: &#39;jest&#39;,</span><br><span class="line">    hi:&#123;</span><br><span class="line">        name: &#39;jest&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 以下结果均为true</span><br><span class="line">expect(a).toEqual(b)</span><br><span class="line">expect([1,2,3]).toEqual([1,2,3])</span><br><span class="line">expect(null).toBeNull()</span><br><span class="line">expect([1,2,3]).toContain(1)</span><br><span class="line">expect(b).toHaveProperty(&#39;hi&#39;)</span><br><span class="line">expect(&#39;123&#39;).toContain(&#39;2&#39;)</span><br><span class="line">expect(&#39;123&#39;).toMatch(&#x2F;^\d+$&#x2F;)</span><br><span class="line">expect(&#39;123&#39;).not.toContain(&#39;4&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="常见踩坑"><a href="#常见踩坑" class="headerlink" title="常见踩坑"></a>常见踩坑</h3><ol>
<li>Unexpected token import<br>Jest 默认只支持你所使用的 node.js 版本所支持的 JS 特性，例如 import export 就不支持，所以要么你的代码使用系统 node.js 兼容的语法写 (也就是使用 require)，要么在这里使用 Babel 转义一下。</li>
</ol>
<p>在 Jest 中使用 Babel 很简单，只需要安装 babel-jest 并新建一个 .babelrc 加入你想要的配置就行了，Jest 会自动使用 babel-jest。这里我们简单地使用 babel-preset-env 即可，对应的 .babelrc 是:<br>{<br>  “presets”: [“env”]<br>}<br>在大多数时候你的项目本身就已经在使用 .babelrc 了，所以这一步甚至也省略掉了。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>Jest中间件</tag>
        <tag>测试中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Cross-origin问题</title>
    <url>/2021/01/09/FroEnd-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Mm-xicuTVhjFM2ECxIU2QQ" target="_blank" rel="noopener">Spring Boot 中通过 CORS 解决跨域问题</a><br><a href="https://mp.weixin.qq.com/s/1Y4eEckZedjiH1cq0Z66XQ" target="_blank" rel="noopener">Spring Boot 解决跨域问题的 3 种方案！</a></p>
<p><a href="https://mp.weixin.qq.com/s/-KnnyYsVJY58f7tBF4L9cw" target="_blank" rel="noopener">SpringBoot 实现前后端分离的跨域访问（CORS）</a></p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>转发与重定向</title>
    <url>/2021/05/07/FroEnd-%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>request.getRequestDispatcher(目标地址).forward(request，response)：请求转发是服务器将请求转发给别的servlet处理，是服务器内部的行为</p>
<h3 id="请求转发的过程"><a href="#请求转发的过程" class="headerlink" title="请求转发的过程"></a>请求转发的过程</h3><p>客户端向服务器发送请求，服务器将请求指派给一个servlet处理（命名为A），A处理后发现自己处理不了该请求，就调用request.getRequestDispatcher(目标).forward(request，response)方法将请求转发给servlet（B）让B处理，B处理成功后将结果返回给客户端。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>转发是在服务器端完成的，与客户端无关</li>
<li>转发是同一次请求，无论服务器端转发多少次都只有一次请求</li>
<li>转发的客户端地址栏不会变化，无论最后响应的是哪个servlet地址栏都不会改变</li>
<li>转发必须在同一台服务器下完成，是服务器内部行为</li>
</ol>
<p><img src="/web/12.png" alt="请求转发的过程"></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>response.sendredirect（URL）：是通过各种方法将请求重新定个方向转到其它位置</p>
<h3 id="重定向过程"><a href="#重定向过程" class="headerlink" title="重定向过程"></a>重定向过程</h3><p>客户端发送一个请求到服务器，服务器匹配Servlet，这都和请求转发一样。Servlet处理完之后调用了response.sendRedirect()方法。当这个Servlet处理完后，看到response.sendRedirect()方法，立即向客户端返回个响应，响应行告诉客户端你必须再重新发送一个请求，去访问另一个目标，客户端收到这个请求后，立刻发出一个新的请求，去请求重定向后的目标,在这两个请求互不干扰、相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。因此，在sendRedirect()里面是两个请求，两个响应。</p>
<p><img src="/web/13.png" alt="重定向过程"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>1、重定向是在客户端发生的；<br>2、重定向是两次或以上请求；<br>3、重定向地址栏有变化；<br>4、重定向可以在不同的服务器下完成。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>特殊的应用：对数据进行修改、删除、添加操作的时候，应该用response.sendRedirect()。如果是采用了request.getRequestDispatcher().forward(request,response)，那么操作前后的地址栏都不会发生改变，仍然是修改的控制器，如果此时再对当前页面刷新的话，就会重新发送一次请求对数据进行修改，这也就是有的人在刷新一次页面就增加一条数据的原因。</p>
<p>如何采用sendRedirect()方式传递数据：<br>1、可以选择session，但要在第二个文件中删除；<br>2、可以在请求的url中带上参数，如”add.htm?id=122”</p>
<h2 id="转发和重定向的路径问题"><a href="#转发和重定向的路径问题" class="headerlink" title="转发和重定向的路径问题"></a>转发和重定向的路径问题</h2><p>1）使用相对路径在重定向和转发中没有区别<br>2）重定向和请求转发使用绝对路径时，根/路径代表了不同含义<br>重定向response.sendRedirect(“xxx”)是服务器向客户端发送一个请求头信息，由客户端再请求一次服务器。/指的Tomcat的根目录,写绝对路径应该写成”/当前Web程序根名称/资源名” 。如”/WebModule/login.jsp”,”/bbs/servlet/LoginServlet”<br>转发是在服务器内部进行的，写绝对路径/开头指的是当前的Web应用程序。绝对路径写法就是”/login.jsp”或”/servlet/LoginServlet”。</p>
<p>总结：以上要注意是区分是从服务器外的请求，还在是内部转发，从服务器外的请求，从Tomcat根写起(就是要包括当前Web的根)；是服务器内部的转发，很简单了，因为在当前服务器内，/写起指的就是当前Web的根目录。</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>转发</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title>Jar包依赖冲突排查思路和解决方法</title>
    <url>/2021/01/07/Issue-Jar%E5%8C%85%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Llps6z99cpPMN2ekeQljrA" target="_blank" rel="noopener">Jar包依赖冲突排查思路和解决方法</a></p>
]]></content>
      <categories>
        <category>Issue</category>
      </categories>
      <tags>
        <tag>排查问题</tag>
      </tags>
  </entry>
  <entry>
    <title>生产问题工具箱</title>
    <url>/2021/01/07/Issue-%E6%8E%92%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%9F%A5%E5%B7%A5%E5%85%B7%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="Linux命令类"><a href="#Linux命令类" class="headerlink" title="Linux命令类"></a>Linux命令类</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>最常用的tail -f</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式</span><br></pre></td></tr></table></figure>

<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep forest f.txt     #文件查找</span><br><span class="line">grep forest f.txt cpf.txt #多文件查找</span><br><span class="line">grep &#39;log&#39; &#x2F;home&#x2F;admin -r -n #目录下查找所有符合关键字的文件</span><br><span class="line">cat f.txt | grep -i shopbase    </span><br><span class="line">grep &#39;shopbase&#39; &#x2F;home&#x2F;admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀</span><br><span class="line">grep &#39;shopbase&#39; &#x2F;home&#x2F;admin -r -n --exclude *.&#123;vm,java&#125; #反匹配</span><br><span class="line">seq 10 | grep 5 -A 3    #上匹配</span><br><span class="line">seq 10 | grep 5 -B 3    #下匹配</span><br><span class="line">seq 10 | grep 5 -C 3    #上下匹配，平时用这个就妥了</span><br><span class="line">cat f.txt | grep -c &#39;SHOPBASE&#39;</span><br></pre></td></tr></table></figure>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#123;print $4,$6&#125;&#39; f.txt</span><br><span class="line">awk &#39;&#123;print NR,$0&#125;&#39; f.txt cpf.txt    </span><br><span class="line">awk &#39;&#123;print FNR,$0&#125;&#39; f.txt cpf.txt</span><br><span class="line">awk &#39;&#123;print FNR,FILENAME,$0&#125;&#39; f.txt cpf.txt</span><br><span class="line">awk &#39;&#123;print FILENAME,&quot;NR&#x3D;&quot;NR,&quot;FNR&#x3D;&quot;FNR,&quot;$&quot;NF&quot;&#x3D;&quot;$NF&#125;&#39; f.txt cpf.txt</span><br><span class="line">echo 1:2:3:4 | awk -F: &#39;&#123;print $1,$2,$3,$4&#125;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#x2F;ldb&#x2F; &#123;print&#125;&#39; f.txt   #匹配ldb</span><br><span class="line">awk &#39;!&#x2F;ldb&#x2F; &#123;print&#125;&#39; f.txt  #不匹配ldb</span><br><span class="line">awk &#39;&#x2F;ldb&#x2F; &amp;&amp; &#x2F;LISTEN&#x2F; &#123;print&#125;&#39; f.txt   #匹配ldb和LISTEN</span><br><span class="line">awk &#39;$5 ~ &#x2F;ldb&#x2F; &#123;print&#125;&#39; f.txt #第五列匹配ldb</span><br></pre></td></tr></table></figure>

<h4 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h4><ul>
<li>NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</li>
<li>FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</li>
<li>NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field</li>
</ul>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u admin find &#x2F;home&#x2F;admin &#x2F;tmp &#x2F;usr -name *.log(多个目录去找)</span><br><span class="line">find . -iname *.txt(大小写都匹配)</span><br><span class="line">find . -type d(当前目录下的所有子目录)</span><br><span class="line">find &#x2F;usr -type l(当前目录下所有的符号链接)</span><br><span class="line">find &#x2F;usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)</span><br><span class="line">find &#x2F;home&#x2F;admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)</span><br><span class="line">find &#x2F;home&#x2F;admin f -perm 777 -exec ls -l &#123;&#125; ; (按照权限查询文件)</span><br><span class="line">find &#x2F;home&#x2F;admin -atime -1  1天内访问过的文件</span><br><span class="line">find &#x2F;home&#x2F;admin -ctime -1  1天内状态改变过的文件    </span><br><span class="line">find &#x2F;home&#x2F;admin -mtime -1  1天内修改过的文件</span><br><span class="line">find &#x2F;home&#x2F;admin -amin -1  1分钟内访问过的文件</span><br><span class="line">find &#x2F;home&#x2F;admin -cmin -1  1分钟内状态改变过的文件    </span><br><span class="line">find &#x2F;home&#x2F;admin -mmin -1  1分钟内修改过的文件</span><br></pre></td></tr></table></figure>

<h3 id="pgm"><a href="#pgm" class="headerlink" title="pgm"></a>pgm</h3><p>批量查询vm-shopbase满足条件的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pgm -A -f vm-shopbase &#39;cat &#x2F;home&#x2F;admin&#x2F;shopbase&#x2F;logs&#x2F;shopbase.log.2017-01-17|grep 2069861630&#39;</span><br></pre></td></tr></table></figure>

<h3 id="tsar"><a href="#tsar" class="headerlink" title="tsar"></a>tsar</h3><p>tsar是咱公司自己的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。</p>
<h4 id="tsar-1"><a href="#tsar-1" class="headerlink" title="tsar"></a>tsar</h4><p>可以查看最近一天的各项指标<br><img src="/prod/tsar%E5%91%BD%E4%BB%A4.png" alt="tsar" title="tsar"></p>
<h4 id="tsar-–live"><a href="#tsar-–live" class="headerlink" title="tsar –live"></a>tsar –live</h4><p>可以查看实时指标，默认五秒一刷<br><img src="/prod/tsar--live.png" alt="tsar--live" title="tsar--live"></p>
<h4 id="tsar-d-20161218"><a href="#tsar-d-20161218" class="headerlink" title="tsar -d 20161218"></a>tsar -d 20161218</h4><p>指定查看某天的数据，貌似最多只能看四个月的数据<br><img src="/prod/tsar-d.png" alt="tsar-d" title="tsar-d"></p>
<h4 id="tsar-–mem"><a href="#tsar-–mem" class="headerlink" title="tsar –mem"></a>tsar –mem</h4><p><img src="/prod/tsar--mem.png" alt="tsar--mem" title="tsar--mem"></p>
<h4 id="tsar-–load"><a href="#tsar-–load" class="headerlink" title="tsar –load"></a>tsar –load</h4><p><img src="/prod/tsar--load.png" alt="tsar--load" title="tsar--load"></p>
<h4 id="tsar-–cpu"><a href="#tsar-–cpu" class="headerlink" title="tsar –cpu"></a>tsar –cpu</h4><p><img src="/prod/tsar--cpu.png" alt="tsar--cpu" title="tsar--cpu"></p>
<p><font color = "red">当然这个也可以和-d参数配合来查询某天的单个指标的情况 </font></p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep java</span><br><span class="line">top -H -p pid</span><br></pre></td></tr></table></figure>
<p>获得线程10进制转16进制后jstack去抓看这个线程到底在干啥</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -nat|awk  &#39;&#123;print $6&#125;&#39;|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure>
<p>查看当前连接，注意close_wait偏高的情况，比如如下<br><img src="/prod/netstart.png" alt="netstart" title="netstart"><br><img src="/prod/netstart-pic.png" alt="netstart-pic" title="netstart-pic"></p>
<h2 id="排查利器"><a href="#排查利器" class="headerlink" title="排查利器"></a>排查利器</h2><h3 id="btrace"><a href="#btrace" class="headerlink" title="btrace"></a>btrace</h3><p>首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。简介什么的就不说了。直接上代码干</p>
<ol>
<li><p>查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈<br><img src="/prod/btrace1.png" alt="btrace1" title="btrace1"></p>
</li>
<li><p>监控当前服务方法被调用时返回的值以及请求的参数<br><img src="/prod/btrace2.png" alt="btrace2" title="btrace2"></p>
</li>
</ol>
<p>其他功能集团的一些工具或多或少都有，就不说了。<a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">感兴趣的请点击</a><br>注意:<br>经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果。<br>正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况。<br>由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。</p>
<h3 id="Greys"><a href="#Greys" class="headerlink" title="Greys"></a>Greys</h3><p>Greys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合):</p>
<p>sc -df xxx: 输出当前类的详情,包括源码位置和classloader结构</p>
<p>trace class method: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。对排查方法性能时很有帮助，<a href="http://www.atatech.org/articles/52947" target="_blank" rel="noopener">比如我之前这篇就是使用了trace命令</a></p>
<p>其他功能部分和btrace重合，可以选用，<a href="http://www.atatech.org/articles/26247" target="_blank" rel="noopener">感兴趣的请点击</a></p>
<p>另外相关联的是arthas，他是基于Greys的，<a href="http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc" target="_blank" rel="noopener">感兴趣的再点击</a></p>
<h3 id="javOSize"><a href="#javOSize" class="headerlink" title="javOSize"></a>javOSize</h3><p>就说一个功能<br>classes：通过修改了字节码，改变了类的内容，即时生效。所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。</p>
<p>其他功能Greys和btrace都能很轻易做的到，不说了。<br>可以看看我之前写的<a href="http://www.atatech.org/articles/38546" target="_blank" rel="noopener">一篇javOSize的简介</a><br><a href="http://www.javosize.com/" target="_blank" rel="noopener">官网请点击</a></p>
<h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><p>之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。<a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">官网请点击</a></p>
<h2 id="大杀器"><a href="#大杀器" class="headerlink" title="大杀器"></a>大杀器</h2><h3 id="eclipseMAT"><a href="#eclipseMAT" class="headerlink" title="eclipseMAT"></a>eclipseMAT</h3><p>可作为eclipse的插件，也可作为单独的程序打开。<a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">详情请点击</a></p>
<h3 id="zprofiler"><a href="#zprofiler" class="headerlink" title="zprofiler"></a>zprofiler</h3><p>集团内的开发应该是无人不知无人不晓了。简而言之一句话:有了zprofiler还要mat干嘛,<a href="zprofiler.alibaba-inc.com">详情请点击</a></p>
<h2 id="Java三板斧"><a href="#Java三板斧" class="headerlink" title="Java三板斧"></a>Java三板斧</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>sudo -u admin /opt/taobao/java/bin/jps -mlvV<br><img src="/prod/jps.png" alt="jps" title="jps"></p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><h4 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法:"></a>普通用法:</h4><p>sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815<br><img src="/prod/jstack%E6%99%AE%E9%80%9A%E7%94%A8%E6%B3%95.png" alt="jstack普通用法" title="jstack普通用法"></p>
<p>native+java栈:<br>sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815<br><img src="/prod/native+java%E6%A0%88.png" alt="native+java栈" title="native+java栈"></p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可看系统启动的参数，如下<br>sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815<br><img src="/prod/jinfo.png" alt="jinfo" title="jinfo"></p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>两个用途</p>
<ol>
<li><p>查看堆的情况<br>sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815<br><img src="/prod/jmap.png" alt="jmap" title="jmap"></p>
</li>
<li><p>dump</p>
</li>
</ol>
<ul>
<li><p>sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</p>
</li>
<li><p>sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:format=b,file=/tmp/heap3.bin 2815</p>
</li>
</ul>
<ol start="3">
<li>看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼<br>sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -histo 2815 | head -10<br><img src="/prod/jmap1.png" alt="jmap1" title="jmap1"></li>
</ol>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat参数众多，但是使用一个就够了<br>sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstat -gcutil 2815 1000<br><img src="/prod/jstat.png" alt="jstat" title="jstat"></p>
<h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><p>时至今日，jdb也是经常使用的。<br>jdb可以用来预发debug,假设你预发的java_home是/opt/taobao/java/，远程调试端口是8000.那么</p>
<ul>
<li>sudo -u admin /opt/taobao/java/bin/jdb -attach 8000.<br><img src="/prod/jbd.png" alt="jbd" title="jbd"><br>出现以上代表jdb启动成功。后续可以进行设置断点进行调试。<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html" target="_blank" rel="noopener">具体参数可见oracle官方说明</a></li>
</ul>
<h3 id="CHLSDB"><a href="#CHLSDB" class="headerlink" title="CHLSDB"></a>CHLSDB</h3><p>CHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。查询资料听说jstack和jmap等工具就是基于它的。</p>
<ul>
<li>sudo -u admin /opt/taobao/java/bin/java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB</li>
</ul>
<p>[更详细的可见R大此贴]<a href="http://rednaxelafx.iteye.com/blog/1847971" target="_blank" rel="noopener">http://rednaxelafx.iteye.com/blog/1847971</a></p>
<h2 id="plugin-of-intellij-idea"><a href="#plugin-of-intellij-idea" class="headerlink" title="plugin of intellij idea"></a>plugin of intellij idea</h2><h3 id="key-promoter"><a href="#key-promoter" class="headerlink" title="key promoter"></a>key promoter</h3><p>快捷键一次你记不住，多来几次你总能记住了吧？<br><img src="/prod/key-promoter.png" alt="key-promoter" title="key-promoter"></p>
<h3 id="maven-helper"><a href="#maven-helper" class="headerlink" title="maven helper"></a>maven helper</h3><p>分析maven依赖的好帮手。</p>
<h4 id="VM-options"><a href="#VM-options" class="headerlink" title="VM options"></a>VM options</h4><ol>
<li>你的类到底是从哪个文件加载进来的？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br><span class="line">结果形如[Loaded java.lang.invoke.MethodHandleImpl$Lazy from D:programmejdkjdk8U74jrelibt.jar]</span><br></pre></td></tr></table></figure></li>
<li>应用挂了输出dump文件</li>
</ol>
<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs/java.hprof<br>集团的vm参数里边基本都有这个选项</p>
<h4 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h4><p>把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn dependency:tree &gt; ~&#x2F;dependency.txt</span><br><span class="line">打出所有依赖</span><br><span class="line"></span><br><span class="line">mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId</span><br><span class="line">只打出指定groupId和artifactId的依赖关系</span><br><span class="line"></span><br><span class="line">-XX:+TraceClassLoading</span><br><span class="line">vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</span><br><span class="line"></span><br><span class="line">-verbose</span><br><span class="line">vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</span><br><span class="line"></span><br><span class="line">greys:sc</span><br><span class="line">greys的sc命令也能清晰的看到当前类是从哪里加载过来的</span><br></pre></td></tr></table></figure>
<p>tomcat-classloader-locate<br><a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject" target="_blank" rel="noopener">点击可以获知当前类是从哪里加载的curl</a></p>
<h4 id="ALI-TOMCAT"><a href="#ALI-TOMCAT" class="headerlink" title="ALI-TOMCAT"></a>ALI-TOMCAT</h4><ol>
<li><p><a href="http://localhost:8006/classloader/jars" target="_blank" rel="noopener">点击列出容器加载的jar列表curl</a></p>
</li>
<li><p><a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject" target="_blank" rel="noopener">点击列出当前当当前类加载的实际jar包位置，解决类冲突时有用curl</a></p>
</li>
</ol>
<h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><h5 id="gpref"><a href="#gpref" class="headerlink" title="gpref"></a>gpref</h5><p><a href="http://www.atatech.org/articles/33317" target="_blank" rel="noopener">点击</a></p>
<h5 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h5><p>如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的</p>
<ul>
<li>sudo dmesg|grep -i kill|less</li>
</ul>
<p>去找关键字oom_killer。找到的结果类似如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[6710782.021013] java invoked oom-killer: gfp_mask&#x3D;0xd0, order&#x3D;0, oom_adj&#x3D;0, oom_scoe_adj&#x3D;0</span><br><span class="line">[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68&#x2F;0x140 </span><br><span class="line">[6710782.257588] Task in &#x2F;LXC011175068174 killed as a result of limit of &#x2F;LXC011175068174 </span><br><span class="line">[6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child </span><br><span class="line">[6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB</span><br></pre></td></tr></table></figure>
<p>以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.<br>解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。</p>
<p>dmesg日志时间转换公式:<br>log实际时间=格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date -d &quot;1970-01-01 UTC &#96;echo &quot;$(date +%s)-$(cat &#x2F;proc&#x2F;uptime|cut -f 1 -d&#39; &#39;)+12288812.926194&quot;|bc &#96; seconds&quot;</span><br></pre></td></tr></table></figure>
<p>剩下的，就是看看为什么内存这么大，触发了OOM-Killer了</p>
<h4 id="新技能get"><a href="#新技能get" class="headerlink" title="新技能get"></a>新技能get</h4><p>想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。<a href="http://ifeve.com/guava-ratelimiter/" target="_blank" rel="noopener">详情可点击</a></p>
]]></content>
      <categories>
        <category>Issue</category>
      </categories>
      <tags>
        <tag>排查问题</tag>
        <tag>生产问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Assert关键字</title>
    <url>/2021/05/03/Java-Assert%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="Assert作用"><a href="#Assert作用" class="headerlink" title="Assert作用"></a>Assert作用</h2><p>Junit测试框架中Assert类就是实现断言的工具，主要作用如下：单元测试用于判断某个特定条件下某个方法的行为；执行单元测试为了证明某段代码的执行结果和期望的一致，下面介绍Junit测试库中几种常用的断言</p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>assert关键字用法简单，但是使用assert往往会让你陷入越来越深的陷阱中。应避免使用。笔者经过研究，总结了以下原因：</p>
<ul>
<li>assert关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。而现在主流的Java IDE工具默认都没有开启-ea断言检查功能。这就意味着你如果使用IDE工具编码，调试运行时候会有一定的麻烦。并且，对于Java Web应用，程序代码都是部署在容器里面，你没法直接去控制程序的运行，如果一定要开启-ea的开关，则需要更改Web容器的运行配置参数。这对程序的移 植和部署都带来很大的不便。</li>
<li>用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试 调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。</li>
<li>assert断言失败将面临程序的退出。这在一个生产环境下的应用是绝不能容忍的。一般都是通过异常处理来解决程序中潜在的错误。但是使用断言就很危险，一旦失败系统就挂了。</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li>assertEquals(expected, actual)：查看两个对象是否相等。类似于字符串比较使用的equals()方法；</li>
<li>assertNotEquals(first, second)：查看两个对象是否不相等。</li>
<li>expected为用户期望某一时刻对象的值，actual为某一时刻对象实际的值。如果这两值相等的话（通过对象的equals方法比较），说明代码运行是正确的。</li>
<li>assertNull(object)：查看对象是否为空。</li>
<li>assertNotNull(object)：查看对象是否不为空。</li>
<li>assertSame(expected, actual)：查看两个对象的引用是否相等，类似于使用“==”比较两个对象；</li>
<li>assertNotSame(unexpected, actual)：查看两个对象的引用是否不相等，类似于使用“!=”比较两个对象。</li>
<li>assertTrue(String message, boolean condition) 要求condition == true，查看运行的结果是否为true；</li>
<li>assertFalse(String message, boolean condition) 要求condition == false，查看运行的结果是否为false。<br>  以判断某个条件是真还是假，如果和预期的值相同则测试成功，否则测试失败。</li>
<li>assertArrayEquals(String message, XXX[] expecteds,XXX [] actuals) 要求expected.equalsArray(actual)，即查看两个数组是否相等。</li>
<li>assertThat(String reason, T actual, Matcher matcher) ：要求matcher.matches(actual) == true，使用Matcher做自定义的校验。</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Assert</tag>
      </tags>
  </entry>
  <entry>
    <title>BIO/NIO/AIO</title>
    <url>/2020/09/12/Java-BIO&amp;&amp;NIO&amp;&amp;AIO/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/paul_wei2008/article/details/72730074" target="_blank" rel="noopener">JAVA IO 以及 NIO 理解</a><br><a href="https://blog.csdn.net/yinwenjie/article/details/48472237" target="_blank" rel="noopener">架构设计：系统间通信（3）——IO通信模型和JAVA实践 上篇</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>面试知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CSV解析器</title>
    <url>/2021/06/26/Java-CSV%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="有三种用于CSV的开源API"><a href="#有三种用于CSV的开源API" class="headerlink" title="有三种用于CSV的开源API"></a>有三种用于CSV的开源API</h2><h3 id="OpenCSV"><a href="#OpenCSV" class="headerlink" title="OpenCSV"></a>OpenCSV</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.opencsv&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;opencsv&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.StringWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import au.com.bytecode.opencsv.CSVReader;</span><br><span class="line">import au.com.bytecode.opencsv.CSVWriter;</span><br><span class="line">import au.com.bytecode.opencsv.bean.CsvToBean;</span><br><span class="line">import au.com.bytecode.opencsv.bean.HeaderColumnNameTranslateMappingStrategy;</span><br><span class="line"> </span><br><span class="line">public class OpenCSVParserExample &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">		List&lt;Employee&gt; emps &#x3D; parseCSVFileLineByLine();</span><br><span class="line">		System.out.println(&quot;**********&quot;);</span><br><span class="line">		parseCSVFileAsList();</span><br><span class="line">		System.out.println(&quot;**********&quot;);</span><br><span class="line">		parseCSVToBeanList();</span><br><span class="line">		System.out.println(&quot;**********&quot;);</span><br><span class="line">		writeCSVData(emps);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private static void parseCSVToBeanList() throws IOException &#123;</span><br><span class="line">		</span><br><span class="line">		HeaderColumnNameTranslateMappingStrategy&lt;Employee&gt; beanStrategy &#x3D; new HeaderColumnNameTranslateMappingStrategy&lt;Employee&gt;();</span><br><span class="line">		beanStrategy.setType(Employee.class);</span><br><span class="line">		</span><br><span class="line">		Map&lt;String, String&gt; columnMapping &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">		columnMapping.put(&quot;ID&quot;, &quot;id&quot;);</span><br><span class="line">		columnMapping.put(&quot;Name&quot;, &quot;name&quot;);</span><br><span class="line">		columnMapping.put(&quot;Role&quot;, &quot;role&quot;);</span><br><span class="line">		&#x2F;&#x2F;columnMapping.put(&quot;Salary&quot;, &quot;salary&quot;);</span><br><span class="line">		</span><br><span class="line">		beanStrategy.setColumnMapping(columnMapping);</span><br><span class="line">		</span><br><span class="line">		CsvToBean&lt;Employee&gt; csvToBean &#x3D; new CsvToBean&lt;Employee&gt;();</span><br><span class="line">		CSVReader reader &#x3D; new CSVReader(new FileReader(&quot;employees.csv&quot;));</span><br><span class="line">		List&lt;Employee&gt; emps &#x3D; csvToBean.parse(beanStrategy, reader);</span><br><span class="line">		System.out.println(emps);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private static void writeCSVData(List&lt;Employee&gt; emps) throws IOException &#123;</span><br><span class="line">		StringWriter writer &#x3D; new StringWriter();</span><br><span class="line">		CSVWriter csvWriter &#x3D; new CSVWriter(writer,&#39;#&#39;);</span><br><span class="line">		List&lt;String[]&gt; data  &#x3D; toStringArray(emps);</span><br><span class="line">		csvWriter.writeAll(data);</span><br><span class="line">		csvWriter.close();</span><br><span class="line">		System.out.println(writer);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private static List&lt;String[]&gt; toStringArray(List&lt;Employee&gt; emps) &#123;</span><br><span class="line">		List&lt;String[]&gt; records &#x3D; new ArrayList&lt;String[]&gt;();</span><br><span class="line">		&#x2F;&#x2F;add header record</span><br><span class="line">		records.add(new String[]&#123;&quot;ID&quot;,&quot;Name&quot;,&quot;Role&quot;,&quot;Salary&quot;&#125;);</span><br><span class="line">		Iterator&lt;Employee&gt; it &#x3D; emps.iterator();</span><br><span class="line">		while(it.hasNext())&#123;</span><br><span class="line">			Employee emp &#x3D; it.next();</span><br><span class="line">			records.add(new String[]&#123;emp.getId(),emp.getName(),emp.getRole(),emp.getSalary()&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		return records;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private static List&lt;Employee&gt; parseCSVFileLineByLine() throws IOException &#123;</span><br><span class="line">		&#x2F;&#x2F;create CSVReader object</span><br><span class="line">		CSVReader reader &#x3D; new CSVReader(new FileReader(&quot;employees.csv&quot;), &#39;,&#39;);</span><br><span class="line">		</span><br><span class="line">		List&lt;Employee&gt; emps &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">		&#x2F;&#x2F;read line by line</span><br><span class="line">		String[] record &#x3D; null;</span><br><span class="line">		&#x2F;&#x2F;skip header row</span><br><span class="line">		reader.readNext();</span><br><span class="line">		</span><br><span class="line">		while((record &#x3D; reader.readNext()) !&#x3D; null)&#123;</span><br><span class="line">			Employee emp &#x3D; new Employee();</span><br><span class="line">			emp.setId(record[0]);</span><br><span class="line">			emp.setName(record[1]);</span><br><span class="line">			emp.setRole(record[2]);</span><br><span class="line">			emp.setSalary(record[3]);</span><br><span class="line">			emps.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		reader.close();</span><br><span class="line">		</span><br><span class="line">		System.out.println(emps);</span><br><span class="line">		return emps;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static void parseCSVFileAsList() throws IOException &#123;</span><br><span class="line">		&#x2F;&#x2F;create CSVReader object</span><br><span class="line">		CSVReader reader &#x3D; new CSVReader(new FileReader(&quot;employees.csv&quot;), &#39;,&#39;);</span><br><span class="line"> </span><br><span class="line">		List&lt;Employee&gt; emps &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">		&#x2F;&#x2F;read all lines at once</span><br><span class="line">		List&lt;String[]&gt; records &#x3D; reader.readAll();</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String[]&gt; iterator &#x3D; records.iterator();</span><br><span class="line">		&#x2F;&#x2F;skip header row</span><br><span class="line">		iterator.next();</span><br><span class="line">		</span><br><span class="line">		while(iterator.hasNext())&#123;</span><br><span class="line">			String[] record &#x3D; iterator.next();</span><br><span class="line">			Employee emp &#x3D; new Employee();</span><br><span class="line">			emp.setId(record[0]);</span><br><span class="line">			emp.setName(record[1]);</span><br><span class="line">			emp.setRole(record[2]);</span><br><span class="line">			emp.setSalary(record[3]);</span><br><span class="line">			emps.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		reader.close();</span><br><span class="line">		</span><br><span class="line">		System.out.println(emps);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Apache-Commmons-CSV"><a href="#Apache-Commmons-CSV" class="headerlink" title="Apache Commmons CSV"></a>Apache Commmons CSV</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-csv&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import org.apache.commons.csv.CSVFormat;</span><br><span class="line">import org.apache.commons.csv.CSVParser;</span><br><span class="line">import org.apache.commons.csv.CSVPrinter;</span><br><span class="line">import org.apache.commons.csv.CSVRecord;</span><br><span class="line"> </span><br><span class="line">public class ApacheCommonsCSVParserExample &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) throws FileNotFoundException, IOException &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;Create the CSVFormat object</span><br><span class="line">		CSVFormat format &#x3D; CSVFormat.RFC4180.withHeader().withDelimiter(&#39;,&#39;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;initialize the CSVParser object</span><br><span class="line">		CSVParser parser &#x3D; new CSVParser(new FileReader(&quot;employees.csv&quot;), format);</span><br><span class="line">		</span><br><span class="line">		List&lt;Employee&gt; emps &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">		for(CSVRecord record : parser)&#123;</span><br><span class="line">			Employee emp &#x3D; new Employee();</span><br><span class="line">			emp.setId(record.get(&quot;ID&quot;));</span><br><span class="line">			emp.setName(record.get(&quot;Name&quot;));</span><br><span class="line">			emp.setRole(record.get(&quot;Role&quot;));</span><br><span class="line">			emp.setSalary(record.get(&quot;Salary&quot;));</span><br><span class="line">			emps.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;close the parser</span><br><span class="line">		parser.close();</span><br><span class="line">		</span><br><span class="line">		System.out.println(emps);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;CSV Write Example using CSVPrinter</span><br><span class="line">		CSVPrinter printer &#x3D; new CSVPrinter(System.out, format.withDelimiter(&#39;#&#39;));</span><br><span class="line">		System.out.println(&quot;********&quot;);</span><br><span class="line">		printer.printRecord(&quot;ID&quot;,&quot;Name&quot;,&quot;Role&quot;,&quot;Salary&quot;);</span><br><span class="line">		for(Employee emp : emps)&#123;</span><br><span class="line">			List&lt;String&gt; empData &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">			empData.add(emp.getId());</span><br><span class="line">			empData.add(emp.getName());</span><br><span class="line">			empData.add(emp.getRole());</span><br><span class="line">			empData.add(emp.getSalary());</span><br><span class="line">			printer.printRecord(empData);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;close the printer</span><br><span class="line">		printer.close();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Super-CSV"><a href="#Super-CSV" class="headerlink" title="Super CSV"></a>Super CSV</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.supercsv&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;super-csv&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.StringWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import org.supercsv.cellprocessor.Optional;</span><br><span class="line">import org.supercsv.cellprocessor.constraint.NotNull;</span><br><span class="line">import org.supercsv.cellprocessor.constraint.UniqueHashCode;</span><br><span class="line">import org.supercsv.cellprocessor.ift.CellProcessor;</span><br><span class="line">import org.supercsv.io.CsvBeanReader;</span><br><span class="line">import org.supercsv.io.CsvBeanWriter;</span><br><span class="line">import org.supercsv.io.ICsvBeanReader;</span><br><span class="line">import org.supercsv.io.ICsvBeanWriter;</span><br><span class="line">import org.supercsv.prefs.CsvPreference;</span><br><span class="line"> </span><br><span class="line">public class SuperCSVParserExample &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">		List&lt;Employee&gt; emps &#x3D; readCSVToBean();</span><br><span class="line">		System.out.println(emps);</span><br><span class="line">		System.out.println(&quot;******&quot;);</span><br><span class="line">		writeCSVData(emps);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private static void writeCSVData(List&lt;Employee&gt; emps) throws IOException &#123;</span><br><span class="line">		ICsvBeanWriter beanWriter &#x3D; null;</span><br><span class="line">		StringWriter writer &#x3D; new StringWriter();</span><br><span class="line">		try&#123;</span><br><span class="line">			beanWriter &#x3D; new CsvBeanWriter(writer, CsvPreference.STANDARD_PREFERENCE);</span><br><span class="line">			final String[] header &#x3D; new String[]&#123;&quot;id&quot;,&quot;name&quot;,&quot;role&quot;,&quot;salary&quot;&#125;;</span><br><span class="line">			final CellProcessor[] processors &#x3D; getProcessors();</span><br><span class="line">            </span><br><span class="line">			&#x2F;&#x2F; write the header</span><br><span class="line">            beanWriter.writeHeader(header);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;write the bean&#39;s data</span><br><span class="line">            for(Employee emp: emps)&#123;</span><br><span class="line">            	beanWriter.write(emp, header, processors);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			if( beanWriter !&#x3D; null ) &#123;</span><br><span class="line">                beanWriter.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;CSV Data\n&quot;+writer.toString());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private static List&lt;Employee&gt; readCSVToBean() throws IOException &#123;</span><br><span class="line">		ICsvBeanReader beanReader &#x3D; null;</span><br><span class="line">		List&lt;Employee&gt; emps &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">		try &#123;</span><br><span class="line">			beanReader &#x3D; new CsvBeanReader(new FileReader(&quot;employees.csv&quot;),</span><br><span class="line">					CsvPreference.STANDARD_PREFERENCE);</span><br><span class="line"> </span><br><span class="line">			&#x2F;&#x2F; the name mapping provide the basis for bean setters </span><br><span class="line">			final String[] nameMapping &#x3D; new String[]&#123;&quot;id&quot;,&quot;name&quot;,&quot;role&quot;,&quot;salary&quot;&#125;;</span><br><span class="line">			&#x2F;&#x2F;just read the header, so that it don&#39;t get mapped to Employee object</span><br><span class="line">			final String[] header &#x3D; beanReader.getHeader(true);</span><br><span class="line">			final CellProcessor[] processors &#x3D; getProcessors();</span><br><span class="line"> </span><br><span class="line">			Employee emp;</span><br><span class="line">			</span><br><span class="line">			while ((emp &#x3D; beanReader.read(Employee.class, nameMapping,</span><br><span class="line">					processors)) !&#x3D; null) &#123;</span><br><span class="line">				emps.add(emp);</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			if (beanReader !&#x3D; null) &#123;</span><br><span class="line">				beanReader.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return emps;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private static CellProcessor[] getProcessors() &#123;</span><br><span class="line">		</span><br><span class="line">		final CellProcessor[] processors &#x3D; new CellProcessor[] &#123; </span><br><span class="line">                new UniqueHashCode(), &#x2F;&#x2F; ID (must be unique)</span><br><span class="line">                new NotNull(), &#x2F;&#x2F; Name</span><br><span class="line">                new Optional(), &#x2F;&#x2F; Role</span><br><span class="line">                new NotNull() &#x2F;&#x2F; Salary</span><br><span class="line">        &#125;;</span><br><span class="line">		return processors;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>csv</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS原理入门指南</title>
    <url>/2021/01/09/Java-DNS%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/jmljaDAywSZK4M1SCEOFxQ" target="_blank" rel="noopener">DNS 原理入门</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>ExceptionHandle</title>
    <url>/2021/10/07/Java-ExceptionHandle/</url>
    <content><![CDATA[<h2 id="背景问题"><a href="#背景问题" class="headerlink" title="背景问题"></a>背景问题</h2><p>SpringBoot的项目已经对有一定的异常处理了，但是对于我们开发者而言可能就不太合适了，因此我们需要对这些异常进行统一的捕获并处理。SpringBoot中有一个ControllerAdvice的注解，使用该注解表示开启了全局异常的捕获，我们只需在自定义一个方法使用ExceptionHandler注解然后定义捕获异常的类型即可对这些捕获的异常进行统一的处理。</p>
<h2 id="SpringBoot全局异常准备"><a href="#SpringBoot全局异常准备" class="headerlink" title="SpringBoot全局异常准备"></a>SpringBoot全局异常准备</h2><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IBaseExceptionInfo &#123;</span><br><span class="line">    &#x2F;** 错误码*&#x2F;</span><br><span class="line">    String getResultCode();</span><br><span class="line"></span><br><span class="line">    &#x2F;** 错误描述*&#x2F;</span><br><span class="line">    String getResultMsg();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum ExceptionEnum implements IBaseExceptionInfo &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据操作错误定义</span><br><span class="line">    SUCCESS(&quot;200&quot;, &quot;成功!&quot;),</span><br><span class="line">    BODY_NOT_MATCH(&quot;400&quot;,&quot;请求的数据格式不符!&quot;),</span><br><span class="line">    SIGNATURE_NOT_MATCH(&quot;401&quot;,&quot;请求的数字签名不匹配!&quot;),</span><br><span class="line">    NOT_FOUND(&quot;404&quot;, &quot;未找到该资源!&quot;),</span><br><span class="line">    INTERNAL_SERVER_ERROR(&quot;500&quot;, &quot;服务器内部错误!&quot;),</span><br><span class="line">    SERVER_BUSY(&quot;503&quot;,&quot;服务器正忙，请稍后再试!&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 错误码 *&#x2F;</span><br><span class="line">    private String resultCode;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 错误描述 *&#x2F;</span><br><span class="line">    private String resultMsg;</span><br><span class="line"></span><br><span class="line">    ExceptionEnum(String resultCode, String resultMsg) &#123;</span><br><span class="line">        this.resultCode &#x3D; resultCode;</span><br><span class="line">        this.resultMsg &#x3D; resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getResultCode() &#123;</span><br><span class="line">        return resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getResultMsg() &#123;</span><br><span class="line">        return resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BizException extends RuntimeException &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 错误码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected String errorCode;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 错误信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected String errorMsg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public BizException(IBaseExceptionInfo errorInfoInterface) &#123;</span><br><span class="line">        super(errorInfoInterface.getResultCode());</span><br><span class="line">        this.errorCode &#x3D; errorInfoInterface.getResultCode();</span><br><span class="line">        this.errorMsg &#x3D; errorInfoInterface.getResultMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(IBaseExceptionInfo errorInfoInterface, Throwable cause) &#123;</span><br><span class="line">        super(errorInfoInterface.getResultCode(), cause);</span><br><span class="line">        this.errorCode &#x3D; errorInfoInterface.getResultCode();</span><br><span class="line">        this.errorMsg &#x3D; errorInfoInterface.getResultMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String errorMsg) &#123;</span><br><span class="line">        super(errorMsg);</span><br><span class="line">        this.errorMsg &#x3D; errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String errorCode, String errorMsg, Throwable cause) &#123;</span><br><span class="line">        super(errorCode, cause);</span><br><span class="line">        this.errorCode &#x3D; errorCode;</span><br><span class="line">        this.errorMsg &#x3D; errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Throwable fillInStackTrace() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理自定义的业务异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D; BizException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResultBody bizExceptionHandler(HttpServletRequest req, BizException e)&#123;</span><br><span class="line">        logger.error(&quot;发生业务异常！原因是：&#123;&#125;&quot;,e.getErrorMsg());</span><br><span class="line">        return ResultBody.error(e.getErrorCode(),e.getErrorMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理空指针的异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D;NullPointerException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResultBody exceptionHandler(HttpServletRequest req, NullPointerException e)&#123;</span><br><span class="line">        logger.error(&quot;发生空指针异常！原因是:&quot;,e);</span><br><span class="line">        return ResultBody.error(ExceptionEnum.BODY_NOT_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理其他异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D;Exception.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResultBody exceptionHandler(HttpServletRequest req, Exception e)&#123;</span><br><span class="line">        logger.error(&quot;未知异常！原因是:&quot;,e);</span><br><span class="line">        return ResultBody.error(ExceptionEnum.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ResultBody &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 响应代码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 响应消息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 响应结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Object result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ResultBody(IBaseExceptionInfo errorInfo) &#123;</span><br><span class="line">        this.code &#x3D; errorInfo.getResultCode();</span><br><span class="line">        this.message &#x3D; errorInfo.getResultMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 成功</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static ResultBody success() &#123;</span><br><span class="line">        return success(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 成功</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static ResultBody success(Object data) &#123;</span><br><span class="line">        ResultBody rb &#x3D; new ResultBody();</span><br><span class="line">        rb.setCode(ExceptionEnum.SUCCESS.getResultCode());</span><br><span class="line">        rb.setMessage(ExceptionEnum.SUCCESS.getResultMsg());</span><br><span class="line">        rb.setResult(data);</span><br><span class="line">        return rb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 失败ss</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static ResultBody error(IBaseExceptionInfo errorInfo) &#123;</span><br><span class="line">        ResultBody rb &#x3D; new ResultBody();</span><br><span class="line">        rb.setCode(errorInfo.getResultCode());</span><br><span class="line">        rb.setMessage(errorInfo.getResultMsg());</span><br><span class="line">        rb.setResult(null);</span><br><span class="line">        return rb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 失败</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static ResultBody error(String code, String message) &#123;</span><br><span class="line">        ResultBody rb &#x3D; new ResultBody();</span><br><span class="line">        rb.setCode(code);</span><br><span class="line">        rb.setMessage(message);</span><br><span class="line">        rb.setResult(null);</span><br><span class="line">        return rb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 失败</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static ResultBody error( String message) &#123;</span><br><span class="line">        ResultBody rb &#x3D; new ResultBody();</span><br><span class="line">        rb.setCode(&quot;-1&quot;);</span><br><span class="line">        rb.setMessage(message);</span><br><span class="line">        rb.setResult(null);</span><br><span class="line">        return rb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        GsonBuilder gsonBuilder &#x3D; new GsonBuilder();</span><br><span class="line">        gsonBuilder.setPrettyPrinting();</span><br><span class="line">        Gson gson &#x3D; gsonBuilder.create();</span><br><span class="line">        return gson.toJson(this).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line">    private String bizId;</span><br><span class="line">    private String bizCode;</span><br><span class="line">    &#x2F;** 编号 *&#x2F;</span><br><span class="line">    private int id;</span><br><span class="line">    &#x2F;** 姓名 *&#x2F;</span><br><span class="line">    private String name;</span><br><span class="line">    &#x2F;** 年龄 *&#x2F;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;bizId&#x3D;&#39;&quot; + bizId + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, bizCode&#x3D;&#39;&quot; + bizCode + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.project.springboot.template.controller;</span><br><span class="line"></span><br><span class="line">import com.project.springboot.template.commons.exception.BizException;</span><br><span class="line">import com.project.springboot.template.models.response.User;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;api&quot;)</span><br><span class="line">public class UserRestController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public boolean insert(@RequestBody User user) &#123;</span><br><span class="line">        System.out.println(&quot;开始新增...&quot;);</span><br><span class="line">        &#x2F;&#x2F;如果姓名为空就手动抛出一个自定义的异常！</span><br><span class="line">        if(user.getName()&#x3D;&#x3D;null)&#123;</span><br><span class="line">            throw  new BizException(&quot;-1&quot;,&quot;用户姓名不能为空！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public boolean update(@RequestBody User user) &#123;</span><br><span class="line">        System.out.println(&quot;开始更新...&quot;);</span><br><span class="line">        &#x2F;&#x2F;这里故意造成一个空指针的异常，并且不进行处理</span><br><span class="line">        String str&#x3D;null;</span><br><span class="line">        str.equals(&quot;111&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public boolean delete(@RequestBody User user)  &#123;</span><br><span class="line">        System.out.println(&quot;开始删除...&quot;);</span><br><span class="line">        &#x2F;&#x2F;这里故意造成一个异常，并且不进行处理</span><br><span class="line">        Integer.parseInt(&quot;abc123&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public List&lt;User&gt; findByUser(User user) &#123;</span><br><span class="line">        System.out.println(&quot;开始查询...&quot;);</span><br><span class="line">        List&lt;User&gt; userList &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        User user2&#x3D;User.builder()</span><br><span class="line">                .bizCode(&quot;001&quot;)</span><br><span class="line">                .bizId(&quot;123456&quot;)</span><br><span class="line">                .age(18)</span><br><span class="line">                .name(&quot;xuwujing&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        return userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream</title>
    <url>/2021/02/19/Java-Java8%20Stream/</url>
    <content><![CDATA[<h2 id="方法引用-双冒号"><a href="#方法引用-双冒号" class="headerlink" title="方法引用( 双冒号:: )"></a>方法引用( 双冒号:: )</h2><p>方法引用分为三种，方法引用通过一对双冒号:: 来表示，方法引用是一种函数式接口的另一种书写方式</p>
<ol>
<li>静态方法引用，通过类名::静态方法名， 如 Integer::parseInt</li>
<li>实例方法引用，通过实例对象::实例方法，如 str::substring</li>
<li>构造方法引用，通过类名::new， 如 User::new</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过方法引用，可以将方法的引用赋值给一个变量,通过赋值给Function，说明方法引用也是一种函数式接口的书写方式，Lambda表达式也是一种函数式接口，Lambda表达式一般用于自己提供方法体，而方法引用一般直接引用现成的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String username, Integer age) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Getter&amp;Setter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int parseInt(String s) throws NumberFormatException &#123;</span><br><span class="line">        return parseInt(s,10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用双冒号::来构造静态函数引用</span><br><span class="line">    Function&lt;String, Integer&gt; fun &#x3D; Integer::parseInt;</span><br><span class="line">    Integer value &#x3D; fun.apply(&quot;123&quot;);</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用双冒号::来构造非静态函数引用</span><br><span class="line">    String content &#x3D; &quot;Hello JDK8&quot;;</span><br><span class="line">    Function&lt;Integer, String&gt; func &#x3D; content::substring;</span><br><span class="line">    String result &#x3D; func.apply(1);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数引用</span><br><span class="line">    BiFunction&lt;String, Integer, User&gt; biFunction &#x3D; User::new;</span><br><span class="line">    User user &#x3D; biFunction.apply(&quot;mengday&quot;, 28);</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 函数引用也是一种函数式接口，所以也可以将函数引用作为方法的参数</span><br><span class="line">    sayHello(String::toUpperCase, &quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法有两个参数，一个是</span><br><span class="line">private static void sayHello(Function&lt;String, String&gt; func, String parameter)&#123;</span><br><span class="line">    String result &#x3D; func.apply(parameter);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream概述"><a href="#Stream概述" class="headerlink" title="Stream概述"></a><a href="https://zhuanlan.zhihu.com/p/299064490" target="_blank" rel="noopener">Stream概述</a></h2><p><img src="/img/Java8-Stream.png" alt="Java8 Stream" title="Java8 Stream"></p>
<p>什么是Stream?</p>
<ul>
<li>Stream将要处理的元素集合看作一种流，在流的过程中,借助Stream API对流中的元素进行操作，比如:筛选、排序、聚合等</li>
</ul>
<p>Stream可以由数组或集合创建，对流的操作分为两种:</p>
<ul>
<li>中间操作，每次返回一个新的流，可以有多个</li>
<li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值</li>
</ul>
<p>Stream有几个特性：</p>
<ul>
<li>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果</li>
<li>stream不会改变数据源，通常情况下会产生一个新的集合或一个值</li>
<li>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行</li>
</ul>
<h2 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h2><h3 id="通过-java-util-Collection-stream-方法用集合创建流"><a href="#通过-java-util-Collection-stream-方法用集合创建流" class="headerlink" title="通过 java.util.Collection.stream() 方法用集合创建流"></a>通过 java.util.Collection.stream() 方法用集合创建流</h3><p>实现Collection类的容器类,List/Map….</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">&#x2F;&#x2F; 创建一个顺序流</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; list.stream();</span><br><span class="line">&#x2F;&#x2F; 创建一个并行流</span><br><span class="line">Stream&lt;String&gt; parallelStream &#x3D; list.parallelStream();</span><br></pre></td></tr></table></figure>

<h3 id="使用java-util-Arrays-stream-T-array-方法用数组创建流"><a href="#使用java-util-Arrays-stream-T-array-方法用数组创建流" class="headerlink" title="使用java.util.Arrays.stream(T[] array)方法用数组创建流"></a>使用java.util.Arrays.stream(T[] array)方法用数组创建流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] array&#x3D;&#123;1,3,5,6,8&#125;;</span><br><span class="line">IntStream stream &#x3D; Arrays.stream(array);</span><br></pre></td></tr></table></figure>

<h3 id="使用Stream的静态方法：of-、iterate-、generate"><a href="#使用Stream的静态方法：of-、iterate-、generate" class="headerlink" title="使用Stream的静态方法：of()、iterate()、generate()"></a>使用Stream的静态方法：of()、iterate()、generate()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream &#x3D; Stream.of(1, 2, 3, 4, 5, 6);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 &#x3D; Stream.iterate(0, (x) -&gt; x + 3).limit(4);</span><br><span class="line">stream2.forEach(System.out::println); &#x2F;&#x2F; 0 2 4 6 8 10</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 &#x3D; Stream.generate(Math::random).limit(3);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="stream和parallelStream的简单区分："><a href="#stream和parallelStream的简单区分：" class="headerlink" title="stream和parallelStream的简单区分："></a>stream和parallelStream的简单区分：</h3><p>stream是顺序流，由主线程按顺序对流执行操作，而parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处<br><img src="/img/%E9%A1%BA%E5%BA%8F%E6%B5%81%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%B5%81.png" alt="顺序流与并行流" title="顺序流与并行流"></p>
<p>除了直接创建并行流，还可以通过parallel()把顺序流转换成并行流<br>Optional<Integer> findFirst = list.stream().parallel().filter(x-&gt;x&gt;6).findFirst();</p>
<h2 id="Stream的使用"><a href="#Stream的使用" class="headerlink" title="Stream的使用"></a>Stream的使用</h2><p><a href="https://www.runoob.com/java/java8-optional-class.html" target="_blank" rel="noopener" title="Java 8 Optional 类">Java 8 Optional类使用教程</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;案例使用的员工类</span><br><span class="line">List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">personList.add(new Person(&quot;Tom&quot;, 8900, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">personList.add(new Person(&quot;Jack&quot;, 7000, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">personList.add(new Person(&quot;Lily&quot;, 7800, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line">personList.add(new Person(&quot;Anni&quot;, 8200, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line">personList.add(new Person(&quot;Owen&quot;, 9500, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">personList.add(new Person(&quot;Alisa&quot;, 7900, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">	private String name;  &#x2F;&#x2F; 姓名</span><br><span class="line">	private int salary; &#x2F;&#x2F; 薪资</span><br><span class="line">	private int age; &#x2F;&#x2F; 年龄</span><br><span class="line">	private String sex; &#x2F;&#x2F;性别</span><br><span class="line">	private String area;  &#x2F;&#x2F; 地区</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 构造方法</span><br><span class="line">	public Person(String name, int salary, int age,String sex,String area) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.salary &#x3D; salary;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">		this.sex &#x3D; sex;</span><br><span class="line">		this.area &#x3D; area;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 省略了get和set，请自行添加</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历-匹配（foreach-find-match-findFirst-findAny-anyMatch）"><a href="#遍历-匹配（foreach-find-match-findFirst-findAny-anyMatch）" class="headerlink" title="遍历/匹配（foreach/find/match/findFirst/findAny/anyMatch）"></a>遍历/匹配（foreach/find/match/findFirst/findAny/anyMatch）</h3><p>Stream也是支持类似集合的遍历和匹配元素的，只是Stream中的元素是以Optional类型存在的。Stream的遍历、匹配非常简单<br><img src="/img/%E9%81%8D%E5%8E%86%E4%B8%8E%E5%8C%B9%E9%85%8D.png" alt="遍历与匹配" title="遍历与匹配"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; Arrays.asList(7, 6, 9, 3, 8, 2, 1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历输出符合条件的元素</span><br><span class="line">        list.stream().filter(x -&gt; x &gt; 6).forEach(System.out::println);</span><br><span class="line">        &#x2F;&#x2F; 匹配第一个</span><br><span class="line">        Optional&lt;Integer&gt; findFirst &#x3D; list.stream().filter(x -&gt; x &gt; 6).findFirst();</span><br><span class="line">        &#x2F;&#x2F; &lt;font color&#x3D;&quot;red&quot;&gt;匹配任意（适用于并行流）&lt;&#x2F;font&gt;</span><br><span class="line">        Optional&lt;Integer&gt; findAny &#x3D; list.parallelStream().filter(x -&gt; x &gt; 6).findAny();</span><br><span class="line">        &#x2F;&#x2F; 是否包含符合特定条件的元素</span><br><span class="line">        boolean anyMatch &#x3D; list.stream().anyMatch(x -&gt; x &lt; 6);</span><br><span class="line">        System.out.println(&quot;匹配第一个值：&quot; + findFirst.get());</span><br><span class="line">        System.out.println(&quot;匹配任意一个值：&quot; + findAny.get());</span><br><span class="line">        System.out.println(&quot;是否存在大于6的值：&quot; + anyMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="筛选-filter"><a href="#筛选-filter" class="headerlink" title="筛选(filter)"></a>筛选(filter)</h3><p>filter:是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 筛选出Integer集合中大于7的元素，并打印出来</span><br><span class="line">		List&lt;Integer&gt; list &#x3D; Arrays.asList(6, 7, 3, 8, 1, 2, 9);</span><br><span class="line">		Stream&lt;Integer&gt; stream &#x3D; list.stream();</span><br><span class="line">		stream.filter(x -&gt; x &gt; 7).forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预期结果：8 9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; fiterList &#x3D; personList.stream().filter(x -&gt; x.getSalary() &gt; 8000).map(Person::getName)</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		System.out.print(&quot;高于8000的员工姓名：&quot; + fiterList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高于8000的员工姓名：[Tom, Anni, Owen]</p>
<h3 id="聚合（max-min-count"><a href="#聚合（max-min-count" class="headerlink" title="聚合（max/min/count)"></a>聚合（max/min/count)</h3><p>max、min、count这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据统计。Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作<br><img src="/img/%E8%81%9A%E5%90%88.png" alt="聚合" title="聚合"></p>
<h4 id="获取String集合中最长的元素"><a href="#获取String集合中最长的元素" class="headerlink" title="获取String集合中最长的元素"></a>获取String集合中最长的元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;String&gt; list &#x3D; Arrays.asList(&quot;adnm&quot;, &quot;admmt&quot;, &quot;pot&quot;, &quot;xbangd&quot;, &quot;weoujgsd&quot;);</span><br><span class="line"></span><br><span class="line">		Optional&lt;String&gt; max &#x3D; list.stream().max(Comparator.comparing(String::length));</span><br><span class="line">		System.out.println(&quot;最长的字符串：&quot; + max.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最长的字符串：weoujgsd</p>
<h4 id="获取Integer集合中的最大值"><a href="#获取Integer集合中的最大值" class="headerlink" title="获取Integer集合中的最大值"></a>获取Integer集合中的最大值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Integer&gt; list &#x3D; Arrays.asList(7, 6, 9, 4, 11, 6);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 自然排序</span><br><span class="line">		Optional&lt;Integer&gt; max &#x3D; list.stream().max(Integer::compareTo);</span><br><span class="line">		&#x2F;&#x2F; 自定义排序</span><br><span class="line">		Optional&lt;Integer&gt; max2 &#x3D; list.stream().max(new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">				return o1.compareTo(o2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(&quot;自然排序的最大值：&quot; + max.get());</span><br><span class="line">		System.out.println(&quot;自定义排序的最大值：&quot; + max2.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然排序的最大值：11<br>自定义排序的最大值：11</p>
<h4 id="获取员工工资最高的人"><a href="#获取员工工资最高的人" class="headerlink" title="获取员工工资最高的人"></a>获取员工工资最高的人</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line"></span><br><span class="line">		Optional&lt;Person&gt; max &#x3D; personList.stream().max(Comparator.comparingInt(Person::getSalary));</span><br><span class="line">		System.out.println(&quot;员工工资最大值：&quot; + max.get().getSalary());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>员工工资最大值：9500</p>
<h4 id="计算Integer集合中大于6的元素的个数"><a href="#计算Integer集合中大于6的元素的个数" class="headerlink" title="计算Integer集合中大于6的元素的个数"></a>计算Integer集合中大于6的元素的个数</h4><p>public class StreamTest {<br>    public static void main(String[] args) {<br>        List<Integer> list = Arrays.asList(7, 6, 4, 8, 2, 11, 9);</p>
<pre><code>    long count = list.stream().filter(x -&gt; x &gt; 6).count();
    System.out.println(&quot;list中大于6的元素个数：&quot; + count);
}</code></pre><p>}<br>list中大于6的元素个数：4</p>
<h4 id="映射-map-flatMap"><a href="#映射-map-flatMap" class="headerlink" title="映射(map/flatMap)"></a>映射(map/flatMap)</h4><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为map和flatMap：</p>
<ul>
<li>map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>
<li>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。<br><img src="/img/%E6%98%A0%E5%B0%84.png" alt="映射" title="映射"></li>
</ul>
<h4 id="英文字符串数组的元素全部改为大写。整数数组每个元素-3"><a href="#英文字符串数组的元素全部改为大写。整数数组每个元素-3" class="headerlink" title="英文字符串数组的元素全部改为大写。整数数组每个元素+3"></a>英文字符串数组的元素全部改为大写。整数数组每个元素+3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String[] strArr &#x3D; &#123; &quot;abcd&quot;, &quot;bcdd&quot;, &quot;defde&quot;, &quot;fTr&quot; &#125;;</span><br><span class="line">		List&lt;String&gt; strList &#x3D; Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		List&lt;Integer&gt; intList &#x3D; Arrays.asList(1, 3, 5, 7, 9, 11);</span><br><span class="line">		List&lt;Integer&gt; intListNew &#x3D; intList.stream().map(x -&gt; x + 3).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;每个元素大写：&quot; + strList);</span><br><span class="line">		System.out.println(&quot;每个元素+3：&quot; + intListNew);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个元素大写：[ABCD, BCDD, DEFDE, FTR]<br>每个元素+3：[4, 6, 8, 10, 12, 14]</p>
<h4 id="将员工的薪资全部增加1000"><a href="#将员工的薪资全部增加1000" class="headerlink" title="将员工的薪资全部增加1000"></a>将员工的薪资全部增加1000</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 不改变原来员工集合的方式</span><br><span class="line">		List&lt;Person&gt; personListNew &#x3D; personList.stream().map(person -&gt; &#123;</span><br><span class="line">			Person personNew &#x3D; new Person(person.getName(), 0, 0, null, null);</span><br><span class="line">			personNew.setSalary(person.getSalary() + 10000);</span><br><span class="line">			return personNew;</span><br><span class="line">		&#125;).collect(Collectors.toList());</span><br><span class="line">		System.out.println(&quot;一次改动前：&quot; + personList.get(0).getName() + &quot;--&gt;  &quot; + personList.get(0).getSalary());</span><br><span class="line">		System.out.println(&quot;一次改动后：&quot; + personListNew.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 改变原来员工集合的方式</span><br><span class="line">		List&lt;Person&gt; personListNew2 &#x3D; personList.stream().map(person -&gt; &#123;</span><br><span class="line">			person.setSalary(person.getSalary() + 10000);</span><br><span class="line">			return person;</span><br><span class="line">		&#125;).collect(Collectors.toList());</span><br><span class="line">		System.out.println(&quot;二次改动前：&quot; + personList.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class="line">		System.out.println(&quot;二次改动后：&quot; + personListNew2.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一次改动前：Tom–&gt;8900<br>一次改动后：Tom–&gt;18900<br>二次改动前：Tom–&gt;18900<br>二次改动后：Tom–&gt;18900</p>
<h4 id="将两个字符数组合并成一个新的字符数组"><a href="#将两个字符数组合并成一个新的字符数组" class="headerlink" title="将两个字符数组合并成一个新的字符数组"></a>将两个字符数组合并成一个新的字符数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;String&gt; list &#x3D; Arrays.asList(&quot;m,k,l,a&quot;, &quot;1,3,5,7&quot;);</span><br><span class="line">		List&lt;String&gt; listNew &#x3D; list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">			&#x2F;&#x2F; 将每个元素转换成一个stream</span><br><span class="line">			String[] split &#x3D; s.split(&quot;,&quot;);</span><br><span class="line">			Stream&lt;String&gt; s2 &#x3D; Arrays.stream(split);</span><br><span class="line">			return s2;</span><br><span class="line">		&#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;处理前的集合：&quot; + list);</span><br><span class="line">		System.out.println(&quot;处理后的集合：&quot; + listNew);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理前的集合：[m-k-l-a, 1-3-5]<br>处理后的集合：[m, k, l, a, 1, 3, 5]</p>
<h3 id="归约-reduce"><a href="#归约-reduce" class="headerlink" title="归约(reduce)"></a>归约(reduce)</h3><p>归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作<br><a href="/img/归集(Stream).png" title="归集(Stream)">归集(Stream)</a></p>
<h4 id="求Integer集合的元素之和、乘积和最大值"><a href="#求Integer集合的元素之和、乘积和最大值" class="headerlink" title="求Integer集合的元素之和、乘积和最大值"></a>求Integer集合的元素之和、乘积和最大值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 3, 2, 8, 11, 4);</span><br><span class="line">		&#x2F;&#x2F; 求和方式1</span><br><span class="line">		Optional&lt;Integer&gt; sum &#x3D; list.stream().reduce((x, y) -&gt; x + y);</span><br><span class="line">		&#x2F;&#x2F; 求和方式2</span><br><span class="line">		Optional&lt;Integer&gt; sum2 &#x3D; list.stream().reduce(Integer::sum);</span><br><span class="line">		&#x2F;&#x2F; 求和方式3</span><br><span class="line">		Integer sum3 &#x3D; list.stream().reduce(0, Integer::sum);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 求乘积</span><br><span class="line">		Optional&lt;Integer&gt; product &#x3D; list.stream().reduce((x, y) -&gt; x * y);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 求最大值方式1</span><br><span class="line">		Optional&lt;Integer&gt; max &#x3D; list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class="line">		&#x2F;&#x2F; 求最大值写法2</span><br><span class="line">		Integer max2 &#x3D; list.stream().reduce(1, Integer::max);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;list求和：&quot; + sum.get() + &quot;,&quot; + sum2.get() + &quot;,&quot; + sum3);</span><br><span class="line">		System.out.println(&quot;list求积：&quot; + product.get());</span><br><span class="line">		System.out.println(&quot;list求和：&quot; + max.get() + &quot;,&quot; + max2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list求和：29,29,29<br>list求积：2112<br>list求和：11,11</p>
<h4 id="求所有员工的工资之和和最高工资"><a href="#求所有员工的工资之和和最高工资" class="headerlink" title="求所有员工的工资之和和最高工资"></a>求所有员工的工资之和和最高工资</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 求工资之和方式1：</span><br><span class="line">		Optional&lt;Integer&gt; sumSalary &#x3D; personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">		&#x2F;&#x2F; 求工资之和方式2：</span><br><span class="line">		Integer sumSalary2 &#x3D; personList.stream().reduce(0, (sum, p) -&gt; sum +&#x3D; p.getSalary(),</span><br><span class="line">				(sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line">		&#x2F;&#x2F; 求工资之和方式3：</span><br><span class="line">		Integer sumSalary3 &#x3D; personList.stream().reduce(0, (sum, p) -&gt; sum +&#x3D; p.getSalary(), Integer::sum);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 求最高工资方式1：</span><br><span class="line">		Integer maxSalary &#x3D; personList.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class="line">				Integer::max);</span><br><span class="line">		&#x2F;&#x2F; 求最高工资方式2：</span><br><span class="line">		Integer maxSalary2 &#x3D; personList.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class="line">				(max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;工资之和：&quot; + sumSalary.get() + &quot;,&quot; + sumSalary2 + &quot;,&quot; + sumSalary3);</span><br><span class="line">		System.out.println(&quot;最高工资：&quot; + maxSalary + &quot;,&quot; + maxSalary2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工资之和：49300,49300,49300<br>最高工资：9500,9500</p>
<h3 id="收集-collect"><a href="#收集-collect" class="headerlink" title="收集(collect)"></a>收集(collect)</h3><p>collect:可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合<br>collect主要依赖java.util.stream.Collectors类内置的静态方法</p>
<h4 id="归集-toList-toSet-toMap"><a href="#归集-toList-toSet-toMap" class="headerlink" title="归集(toList/toSet/toMap)"></a>归集(toList/toSet/toMap)</h4><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。toList、toSet和toMap比较常用，另外还有toCollection、toConcurrentMap等复杂一些的用法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20);</span><br><span class="line">		List&lt;Integer&gt; listNew &#x3D; list.stream().filter(x -&gt; x % 2 &#x3D;&#x3D; 0).collect(Collectors.toList());</span><br><span class="line">		Set&lt;Integer&gt; set &#x3D; list.stream().filter(x -&gt; x % 2 &#x3D;&#x3D; 0).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line">		</span><br><span class="line">		Map&lt;?, Person&gt; map &#x3D; personList.stream().filter(p -&gt; p.getSalary() &gt; 8000)</span><br><span class="line">				.collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class="line">		System.out.println(&quot;toList:&quot; + listNew);</span><br><span class="line">		System.out.println(&quot;toSet:&quot; + set);</span><br><span class="line">		System.out.println(&quot;toMap:&quot; + map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toList：[6, 4, 6, 6, 20]<br>toSet：[4, 20, 6]<br>toMap：{Tom=mutest.Person@5fd0d5ae, Anni=mutest.Person@2d98a335}</p>
<h4 id="统计-count-averaging"><a href="#统计-count-averaging" class="headerlink" title="统计(count/averaging)"></a>统计(count/averaging)</h4><p>Collectors提供了一系列用于数据统计的静态方法：</p>
<ul>
<li>计数：count</li>
<li>平均值：averagingInt、averagingLong、averagingDouble</li>
<li>最值：maxBy、minBy</li>
<li>求和：summingInt、summingLong、summingDouble<br>统计以上所有：summarizingInt、summarizingLong、summarizingDouble<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;统计员工人数、平均工资、工资总额、最高工资</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 求总数</span><br><span class="line">		Long count &#x3D; personList.stream().collect(Collectors.counting());</span><br><span class="line">		&#x2F;&#x2F; 求平均工资</span><br><span class="line">		Double average &#x3D; personList.stream().collect(Collectors.averagingDouble(Person::getSalary));</span><br><span class="line">		&#x2F;&#x2F; 求最高工资</span><br><span class="line">		Optional&lt;Integer&gt; max &#x3D; personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));</span><br><span class="line">		&#x2F;&#x2F; 求工资之和</span><br><span class="line">		Integer sum &#x3D; personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class="line">		&#x2F;&#x2F; 一次性统计所有信息</span><br><span class="line">		DoubleSummaryStatistics collect &#x3D; personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;员工总数：&quot; + count);</span><br><span class="line">		System.out.println(&quot;员工平均工资：&quot; + average);</span><br><span class="line">		System.out.println(&quot;员工工资总和：&quot; + sum);</span><br><span class="line">		System.out.println(&quot;员工工资所有统计：&quot; + collect);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
员工总数：3<br>员工平均工资：7900.0<br>员工工资总和：23700<br>员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000,min=7000.000000, average=7900.000000, max=8900.000000}</li>
</ul>
<h4 id="分组-partitioningBy-groupingBy"><a href="#分组-partitioningBy-groupingBy" class="headerlink" title="分组(partitioningBy/groupingBy)"></a>分组(partitioningBy/groupingBy)</h4><ul>
<li>分区：将stream按条件分为两个Map，比如员工按薪资是否高于8000分为两部分。</li>
<li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Anni&quot;, 8200, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Owen&quot;, 9500, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Alisa&quot;, 7900, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 将员工按薪资是否高于8000分组</span><br><span class="line">        Map&lt;Boolean, List&lt;Person&gt;&gt; part &#x3D; personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; 8000));</span><br><span class="line">        &#x2F;&#x2F; 将员工按性别分组</span><br><span class="line">        Map&lt;String, List&lt;Person&gt;&gt; group &#x3D; personList.stream().collect(Collectors.groupingBy(Person::getSex));</span><br><span class="line">        &#x2F;&#x2F; 将员工先按性别分组，再按地区分组</span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 &#x3D; personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));</span><br><span class="line">        System.out.println(&quot;员工按薪资是否大于8000分组情况：&quot; + part);</span><br><span class="line">        System.out.println(&quot;员工按性别分组情况：&quot; + group);</span><br><span class="line">        System.out.println(&quot;员工按性别、地区：&quot; + group2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
员工按薪资是否大于8000分组情况：{false=[mutest.Person@2d98a335, mutest.Person@16b98e56, mutest.Person@7ef20235], true=[mutest.Person@27d6c5e0, mutest.Person@4f3f5b24, mutest.Person@15aeb7ab]}<br>员工按性别分组情况：{female=[mutest.Person@16b98e56, mutest.Person@4f3f5b24, mutest.Person@7ef20235], male=[mutest.Person@27d6c5e0, mutest.Person@2d98a335, mutest.Person@15aeb7ab]}<br>员工按性别、地区：{female={New York=[mutest.Person@4f3f5b24, mutest.Person@7ef20235], Washington=[mutest.Person@16b98e56]}, male={New York=[mutest.Person@27d6c5e0, mutest.Person@15aeb7ab], Washington=[mutest.Person@2d98a335]}}</li>
</ul>
<h4 id="接合-joining"><a href="#接合-joining" class="headerlink" title="接合(joining)"></a>接合(joining)</h4><p>joining:可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line"></span><br><span class="line">		String names &#x3D; personList.stream().map(p -&gt; p.getName()).collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">		System.out.println(&quot;所有员工的姓名：&quot; + names);</span><br><span class="line">		List&lt;String&gt; list &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class="line">		String string &#x3D; list.stream().collect(Collectors.joining(&quot;-&quot;));</span><br><span class="line">		System.out.println(&quot;拼接后的字符串：&quot; + string);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有员工的姓名：Tom,Jack,Lily<br>拼接后的字符串：A-B-C</p>
<h4 id="归约-reducing"><a href="#归约-reducing" class="headerlink" title="归约(reducing)"></a>归约(reducing)</h4><p>Collectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）</span><br><span class="line">		Integer sum &#x3D; personList.stream().collect(Collectors.reducing(0, Person::getSalary, (i, j) -&gt; (i + j - 5000)));</span><br><span class="line">		System.out.println(&quot;员工扣税薪资总和：&quot; + sum);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; stream的reduce</span><br><span class="line">		Optional&lt;Integer&gt; sum2 &#x3D; personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">		System.out.println(&quot;员工薪资总和：&quot; + sum2.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>员工扣税薪资总和：8700<br>员工薪资总和：23700</p>
<h3 id="排序-sorted"><a href="#排序-sorted" class="headerlink" title="排序(sorted)"></a>排序(sorted)</h3><ul>
<li>sorted()：自然排序，流中元素需实现Comparable接口</li>
<li>sorted(Comparator com)：Comparator排序器自定义排序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">		personList.add(new Person(&quot;Sherry&quot;, 9000, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Tom&quot;, 8900, 22, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Jack&quot;, 9000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Lily&quot;, 8800, 26, &quot;male&quot;, &quot;New York&quot;));</span><br><span class="line">		personList.add(new Person(&quot;Alisa&quot;, 9000, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 按工资升序排序（自然排序）</span><br><span class="line">		List&lt;String&gt; newList &#x3D; personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		&#x2F;&#x2F; 按工资倒序排序</span><br><span class="line">		List&lt;String&gt; newList2 &#x3D; personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())</span><br><span class="line">				.map(Person::getName).collect(Collectors.toList());</span><br><span class="line">		&#x2F;&#x2F; 先按工资再按年龄升序排序</span><br><span class="line">		List&lt;String&gt; newList3 &#x3D; personList.stream()</span><br><span class="line">				.sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		&#x2F;&#x2F; 先按工资再按年龄自定义排序（降序）</span><br><span class="line">		List&lt;String&gt; newList4 &#x3D; personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class="line">			if (p1.getSalary() &#x3D;&#x3D; p2.getSalary()) &#123;</span><br><span class="line">				return p2.getAge() - p1.getAge();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return p2.getSalary() - p1.getSalary();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).map(Person::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;按工资升序排序：&quot; + newList);</span><br><span class="line">		System.out.println(&quot;按工资降序排序：&quot; + newList2);</span><br><span class="line">		System.out.println(&quot;先按工资再按年龄升序排序：&quot; + newList3);</span><br><span class="line">		System.out.println(&quot;先按工资再按年龄自定义降序排序：&quot; + newList4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
按工资自然排序：[Lily, Tom, Sherry, Jack, Alisa]<br>按工资降序排序：[Sherry, Jack, Alisa,Tom, Lily]<br>先按工资再按年龄自然排序：[Sherry, Jack, Alisa, Tom, Lily]<br>先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</li>
</ul>
<h3 id="提取-组合"><a href="#提取-组合" class="headerlink" title="提取/组合"></a>提取/组合</h3><p>流也可以进行合并、去重、限制、跳过等操作</p>
<p><img src="/img/Stream-%E6%8F%90%E5%8F%961.png" alt="Stream-提取" title="Stream-提取"><br><img src="/img/Stream-%E6%8F%90%E5%8F%962.png" alt="Stream-提取" title="Stream-提取"><br><img src="/img/Stream-%E6%8F%90%E5%8F%963.png" alt="Stream-提取" title="Stream-提取"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String[] arr1 &#x3D; &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; &#125;;</span><br><span class="line">		String[] arr2 &#x3D; &#123; &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot; &#125;;</span><br><span class="line"></span><br><span class="line">		Stream&lt;String&gt; stream1 &#x3D; Stream.of(arr1);</span><br><span class="line">		Stream&lt;String&gt; stream2 &#x3D; Stream.of(arr2);</span><br><span class="line">		&#x2F;&#x2F; concat:合并两个流 distinct：去重</span><br><span class="line">		List&lt;String&gt; newList &#x3D; Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());</span><br><span class="line">		&#x2F;&#x2F; limit：限制从流中获得前n个数据</span><br><span class="line">		List&lt;Integer&gt; collect &#x3D; Stream.iterate(1, x -&gt; x + 2).limit(10).collect(Collectors.toList());</span><br><span class="line">		&#x2F;&#x2F; skip：跳过前n个数据</span><br><span class="line">		List&lt;Integer&gt; collect2 &#x3D; Stream.iterate(1, x -&gt; x + 2).skip(1).limit(5).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;流合并：&quot; + newList);</span><br><span class="line">		System.out.println(&quot;limit：&quot; + collect);</span><br><span class="line">		System.out.println(&quot;skip：&quot; + collect2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流合并：[a, b, c, d, e, f, g]<br>limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]<br>skip：[3, 5, 7, 9, 11]</p>
<p>##Optional常用方法</p>
<ul>
<li>创建 Optional 对象，使用of(T) 或者 ofNullable(T)，它们的不同点在于对于传入的参数为null时，是如何处理的。</li>
<li>of(T) 如果传入的参数为null，会报NullPointerException</li>
<li>ofNullable(T) 如果传入的参数为null，它会返回一个empty的Optional对象。</li>
<li>ifPresent() 判断是否有值（不推荐直接使用这个方法，看看是否可以使用orElse(T)方法）</li>
<li>get() 获取值；这个方法迷惑性比较大，如果直接调用，在没有值的情况下，会报NoSuchElementException异常。</li>
<li>设置默认值，orElse(T) 或者 orElseGet(T)；orElseGet(T)是orElse(T)的延迟调用版。</li>
<li>orElseThrow(T) 没有值的情况抛异常</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Mock-data</title>
    <url>/2019/02/12/Java-Mockito%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h2><p>Mock（模拟对象）是以可控的方式模拟真实对象行为的假的对象。程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。</p>
<blockquote>
<p>在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。</p>
</blockquote>
<p>在下面的情形，可能需要使用模拟对象来代替真实对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 真实对象的行为是不确定的（例如，当前的时间或当前的温度）；</span><br><span class="line">* 真实对象很难搭建起来；</span><br><span class="line">* 真实对象的行为很难触发（例如，网络错误）；</span><br><span class="line">* 真实对象速度很慢（例如，一个完整的数据库，在测试之前可能需要初始化）；</span><br><span class="line">* 真实的对象是用户界面，或包括用户界面在内；</span><br><span class="line">* 真实的对象使用了回调机制；</span><br><span class="line">* 真实对象可能还不存在；</span><br><span class="line">* 真实对象可能包含不能用作测试（而不是为实际工作）的信息和方法。</span><br></pre></td></tr></table></figure>

<h2 id="Mockito的简单使用"><a href="#Mockito的简单使用" class="headerlink" title="Mockito的简单使用"></a>Mockito的简单使用</h2><p>Mockito是GitHub上使用最广泛的Mock框架,并与JUnit结合使用.Mockito框架可以创建和配置mock对象.使用Mockito简化了具有外部依赖的类的测试开发!</p>
<h3 id="基于-Spring-的单元测试编写"><a href="#基于-Spring-的单元测试编写" class="headerlink" title="基于 Spring 的单元测试编写"></a>基于 Spring 的单元测试编写</h3><p>首先我们项目一般都是 MVC 分层的，而单元测试主要是在 Dao 层和 Service 层上进行编写。从项目结构上来说，Service 层是依赖 Dao 层的，但是从单元测试角度，对某个 Service 进行单元的时候，他所有依赖的类都应该进行Mock。而 Dao 层单元测试就比较简单了，只依赖数据库中的数据。</p>
<p>一般使用Mockito的步骤:<br>模拟任何外部依赖并将这些模拟对象插入测试代码中<br>执行测试中的代码<br>验证代码是否按照预期执行<br><img src="/img/mock.png" alt="mock依赖" title="mock依赖"></p>
<h2 id="mock依赖配置"><a href="#mock依赖配置" class="headerlink" title="mock依赖配置"></a>mock依赖配置</h2><h3 id="Android项目"><a href="#Android项目" class="headerlink" title="Android项目:"></a>Android项目:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    &#x2F;&#x2F; ... more entries</span><br><span class="line">    testCompile &#39;junit:junit:4.12&#39;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; required if you want to use Mockito for unit tests</span><br><span class="line">    testCompile &#39;org.mockito:mockito-core:2.+&#39;</span><br><span class="line">    &#x2F;&#x2F; required if you want to use Mockito for Android tests</span><br><span class="line">    androidTestCompile &#39;org.mockito:mockito-android:2.7.22&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a>Mockito</h3><p>SpringBoot 中的 pom.xml 文件需要添加的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="常用的-Mockito-方法："><a href="#常用的-Mockito-方法：" class="headerlink" title="常用的 Mockito 方法："></a>常用的 Mockito 方法：</h2><table>
<thead>
<tr>
<th>描述</th>
<th>方法名</th>
</tr>
</thead>
<tbody><tr>
<td>1.verify验证行为是否发生</td>
<td>Mockito.verify(mock)</td>
</tr>
<tr>
<td>2.多次触发返回不同值</td>
<td>Mockito.when(methodCall).thenReturn(value1).thenReturn(value2)</td>
</tr>
<tr>
<td>3.doThrow模拟抛出异常</td>
<td>Mockito.doThrow(toBeThrown).when(mock).[method]</td>
</tr>
<tr>
<td>4.Mock返回默认模拟对象</td>
<td>Mockito.mock(classToMock,defaultAnswer)</td>
</tr>
<tr>
<td>5.参数匹配（直接执行不判断）</td>
<td>Mockito.doReturn(toBeReturned).when(mock).[method]</td>
</tr>
<tr>
<td>6.预期回调接口生成期望值</td>
<td>Mockito.when(methodCall).thenAnswer(answer))</td>
</tr>
<tr>
<td>7.预期回调接口生成期望值（直接执行不判断）</td>
<td>Mockito.doAnswer(answer).when(methodCall).[method]</td>
</tr>
<tr>
<td>8.spy监控真实对象,设置真实对象行为</td>
<td>Mockito.spy(Object)</td>
</tr>
<tr>
<td>9.doNothing不做任何返回</td>
<td>Mockito.doNothing().when(mock).[method]</td>
</tr>
<tr>
<td>10.reset重置mock</td>
<td>reset(mock)</td>
</tr>
<tr>
<td>11.调用真实的方法</td>
<td>Mockito.doCallRealMethod().when(mock).[method]</td>
</tr>
<tr>
<td>11.调用真实的方法</td>
<td>//等价于Mockito.when(mock.[method]).thenCallRealMethod();</td>
</tr>
</tbody></table>
<h4 id="1-verify验证行为是否发生"><a href="#1-verify验证行为是否发生" class="headerlink" title="1.verify验证行为是否发生"></a>1.verify验证行为是否发生</h4><blockquote>
<p>调用真实的方法 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;模拟创建一个List对象</span><br><span class="line">List&lt;Integer&gt; mock &#x3D;  Mockito.mock(List.class);</span><br><span class="line">&#x2F;&#x2F;调用mock对象的方法</span><br><span class="line">mock.add(1);</span><br><span class="line">mock.clear();</span><br><span class="line">&#x2F;&#x2F;验证方法是否执行</span><br><span class="line">Mockito.verify(mock).add(1);</span><br><span class="line">Mockito.verify(mock).clear();</span><br></pre></td></tr></table></figure>

<h4 id="2-多次触发返回不同值"><a href="#2-多次触发返回不同值" class="headerlink" title="2.多次触发返回不同值"></a>2.多次触发返回不同值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;mock一个Iterator类</span><br><span class="line">Iterator iterator &#x3D; mock(Iterator.class);</span><br><span class="line">&#x2F;&#x2F;预设当iterator调用next()时第一次返回hello，第n次都返回world</span><br><span class="line">Mockito.when(iterator.next()).thenReturn(&quot;hello&quot;).thenReturn(&quot;world&quot;);</span><br><span class="line">&#x2F;&#x2F;使用mock的对象</span><br><span class="line">String result &#x3D; iterator.next() + &quot; &quot; + iterator.next() + &quot; &quot; + iterator.next();</span><br><span class="line">&#x2F;&#x2F;验证结果</span><br><span class="line">Assert.assertEquals(&quot;hello world world&quot;,result);</span><br></pre></td></tr></table></figure>

<h4 id="3-doThrow模拟抛出异常"><a href="#3-doThrow模拟抛出异常" class="headerlink" title="3.doThrow模拟抛出异常"></a>3.doThrow模拟抛出异常</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test(expected &#x3D; IOException.class)&#x2F;&#x2F;期望报IO异常</span><br><span class="line">public void when_thenThrow() throws IOException&#123;</span><br><span class="line">      OutputStream mock &#x3D; Mockito.mock(OutputStream.class);</span><br><span class="line">      &#x2F;&#x2F;预设当流关闭时抛出异常</span><br><span class="line">      Mockito.doThrow(new IOException()).when(mock).close();</span><br><span class="line">      mock.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Mock返回默认模拟对象"><a href="#4-Mock返回默认模拟对象" class="headerlink" title="4.Mock返回默认模拟对象"></a>4.Mock返回默认模拟对象</h4><blockquote>
<p>RETURNS_DEEP_STUBS 是创建mock对象时的备选参数之一<br>以下方法deepstubsTest和deepstubsTest2是等价的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    private B b;</span><br><span class="line">    public B getB()&#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setB(B b)&#123;</span><br><span class="line">        this.b&#x3D;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getSex(Integer sex)&#123;</span><br><span class="line">        if(sex&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return &quot;man&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return &quot;woman&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void deepstubsTest()&#123;</span><br><span class="line">    A a&#x3D;Mockito.mock(A.class,Mockito.RETURNS_DEEP_STUBS);</span><br><span class="line">    Mockito.when(a.getB().getName()).thenReturn(&quot;Beijing&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;Beijing&quot;,a.getB().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void deepstubsTest2()&#123;</span><br><span class="line">    A a&#x3D;Mockito.mock(A.class);</span><br><span class="line">    B b&#x3D;Mockito.mock(B.class);</span><br><span class="line">    Mockito.when(a.getB()).thenReturn(b);</span><br><span class="line">    Mockito.when(b.getName()).thenReturn(&quot;Beijing&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;Beijing&quot;,a.getB().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-参数匹配"><a href="#5-参数匹配" class="headerlink" title="5.参数匹配"></a>5.参数匹配</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getSex(Integer sex)&#123;</span><br><span class="line">        if(sex&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return &quot;man&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return &quot;woman&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void with_arguments()&#123;</span><br><span class="line">    B b &#x3D; Mockito.mock(B.class);</span><br><span class="line">    &#x2F;&#x2F;预设根据不同的参数返回不同的结果</span><br><span class="line">    Mockito.when(b.getSex(1)).thenReturn(&quot;男&quot;);</span><br><span class="line">    Mockito.when(b.getSex(2)).thenReturn(&quot;女&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;男&quot;, b.getSex(1));</span><br><span class="line">    Assert.assertEquals(&quot;女&quot;, b.getSex(2));</span><br><span class="line">    &#x2F;&#x2F;对于没有预设的情况会返回默认值</span><br><span class="line">    Assert.assertEquals(null, b.getSex(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-匹配任意参数"><a href="#5-匹配任意参数" class="headerlink" title="5.匹配任意参数"></a>5.匹配任意参数</h4><p>Mockito.anyInt() 任何 int 值 ；<br>Mockito.anyLong() 任何 long 值 ；<br>Mockito.anyString() 任何 String 值 ；<br>Mockito.any(XXX.class) 任何 XXX 类型的值 等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class IsValid extends ArgumentMatcher&lt;List&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(Object obj) &#123;</span><br><span class="line">        return obj.equals(1) || obj.equals(2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void with_unspecified_arguments()&#123;</span><br><span class="line">    List list &#x3D; Mockito.mock(List.class);</span><br><span class="line">    &#x2F;&#x2F;匹配任意参数</span><br><span class="line">    Mockito.when(list.get(Mockito.anyInt())).thenReturn(1);</span><br><span class="line">    &#x2F;&#x2F;argThat(Matches&lt;T&gt; matcher)方法用来应用自定义的规则，可以传入任何实现Matcher接口的实现类。</span><br><span class="line">    Mockito.when(list.contains(Mockito.argThat(new IsValid()))).thenReturn(true);</span><br><span class="line">    Assert.assertEquals(1,list.get(1));</span><br><span class="line">    Assert.assertEquals(1,list.get(999));</span><br><span class="line">    Assert.assertTrue(list.contains(1));</span><br><span class="line">    Assert.assertTrue(!list.contains(3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用了参数匹配，那么所有的参数都必须通过matchers来匹配<br>Mockito继承Matchers，anyInt()等均为Matchers方法<br>当传入两个参数，其中一个参数采用任意参数时，指定参数需要matchers来对比</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Comparator comparator &#x3D; mock(Comparator.class);</span><br><span class="line">comparator.compare(&quot;nihao&quot;,&quot;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;如果你使用了参数匹配，那么所有的参数都必须通过matchers来匹配</span><br><span class="line">Mockito.verify(comparator).compare(Mockito.anyString(),Mockito.eq(&quot;hello&quot;));</span><br><span class="line">&#x2F;&#x2F;下面的为无效的参数匹配使用</span><br><span class="line">&#x2F;&#x2F;verify(comparator).compare(anyString(),&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="5-自定义参数匹配"><a href="#5-自定义参数匹配" class="headerlink" title="5.自定义参数匹配"></a>5.自定义参数匹配</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class IsListofTwoElements extends ArgumentMatcher&lt;List&gt;</span><br><span class="line">&#123;</span><br><span class="line">   public boolean matches(Object list)</span><br><span class="line">   &#123;</span><br><span class="line">       return((List)list).size()&#x3D;&#x3D;3;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void argumentMatchersTest()&#123;</span><br><span class="line">   &#x2F;&#x2F;创建mock对象</span><br><span class="line">   List&lt;String&gt; mock &#x3D; mock(List.class);</span><br><span class="line">   &#x2F;&#x2F;argThat(Matches&lt;T&gt; matcher)方法用来应用自定义的规则，可以传入任何实现Matcher接口的实现类。</span><br><span class="line">   Mockito.when(mock.addAll(Mockito.argThat(new IsListofTwoElements()))).thenReturn(true);</span><br><span class="line">   Assert.assertTrue(mock.addAll(Arrays.asList(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-预期回调接口生成期望值"><a href="#6-预期回调接口生成期望值" class="headerlink" title="6.预期回调接口生成期望值"></a>6.预期回调接口生成期望值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private class CustomAnswer implements Answer&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">        Object[] args &#x3D; invocation.getArguments();</span><br><span class="line">        return &quot;hello world:&quot;+args[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void answerTest()&#123;</span><br><span class="line">      List mockList &#x3D; Mockito.mock(List.class);</span><br><span class="line">      &#x2F;&#x2F;使用方法预期回调接口生成期望值（Answer结构）</span><br><span class="line">      Mockito.when(mockList.get(Mockito.anyInt())).thenAnswer(new CustomAnswer());</span><br><span class="line">      Assert.assertEquals(&quot;hello world:0&quot;,mockList.get(0));</span><br><span class="line">      Assert.assertEquals(&quot;hello world:999&quot;,mockList.get(999));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">等价于：(也可使用匿名内部类实现)</span><br><span class="line">@Test</span><br><span class="line"> public void answer_with_callback()&#123;</span><br><span class="line">      &#x2F;&#x2F;使用Answer来生成我们我们期望的返回</span><br><span class="line">      Mockito.when(mockList.get(Mockito.anyInt())).thenAnswer(new Answer&lt;Object&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public Object answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">              Object[] args &#x3D; invocation.getArguments();</span><br><span class="line">              return &quot;hello world:&quot;+args[0];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      Assert.assertEquals(&quot;hello world:0&quot;,mockList.get(0));</span><br><span class="line">     Assert. assertEquals(&quot;hello world:999&quot;,mockList.get(999));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-预期回调接口生成期望值（直接执行）"><a href="#7-预期回调接口生成期望值（直接执行）" class="headerlink" title="7.预期回调接口生成期望值（直接执行）"></a>7.预期回调接口生成期望值（直接执行）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomAnswer implements Answer&lt;String&gt; &#123;  </span><br><span class="line">  public String answer(InvocationOnMock invocation) throws Throwable &#123;  </span><br><span class="line">      Object[] args &#x3D; invocation.getArguments();  </span><br><span class="line">      Integer num &#x3D; (Integer)args[0];  </span><br><span class="line">      if( num&gt;3 )&#123;  </span><br><span class="line">          return &quot;大于三&quot;;  </span><br><span class="line">      &#125; else &#123;  </span><br><span class="line">          return &quot;小于三&quot;;   </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void testAnswer1()&#123;</span><br><span class="line">List&lt;String&gt; mock &#x3D; Mockito.mock(List.class);  </span><br><span class="line">      Mockito.doAnswer(new CustomAnswer()).when(mock).get(Mockito.anyInt());  </span><br><span class="line">      Assert.assertEquals(&quot;大于三&quot;, mock.get(4));</span><br><span class="line">      Assert.assertEquals(&quot;小于三&quot;, mock.get(2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-用spy监控真实对象-设置真实对象行为"><a href="#8-用spy监控真实对象-设置真实对象行为" class="headerlink" title="8.用spy监控真实对象,设置真实对象行为"></a>8.用spy监控真实对象,设置真实对象行为</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test(expected &#x3D; IndexOutOfBoundsException.class)</span><br><span class="line">  public void spy_on_real_objects()&#123;</span><br><span class="line">      List list &#x3D; new LinkedList();</span><br><span class="line">      List spy &#x3D; Mockito.spy(list);</span><br><span class="line">      &#x2F;&#x2F;下面预设的spy.get(0)会报错，因为会调用真实对象的get(0)，所以会抛出越界异常</span><br><span class="line">      &#x2F;&#x2F;Mockito.when(spy.get(0)).thenReturn(3);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;使用doReturn-when可以避免when-thenReturn调用真实对象api</span><br><span class="line">      Mockito.doReturn(999).when(spy).get(999);</span><br><span class="line">      &#x2F;&#x2F;预设size()期望值</span><br><span class="line">      Mockito.when(spy.size()).thenReturn(100);</span><br><span class="line">      &#x2F;&#x2F;调用真实对象的api</span><br><span class="line">      spy.add(1);</span><br><span class="line">      spy.add(2);</span><br><span class="line">      Assert.assertEquals(100,spy.size());</span><br><span class="line">      Assert.assertEquals(1,spy.get(0));</span><br><span class="line">      Assert.assertEquals(2,spy.get(1));</span><br><span class="line">      Assert.assertEquals(999,spy.get(999));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-不做任何返回"><a href="#9-不做任何返回" class="headerlink" title="9.不做任何返回"></a>9.不做任何返回</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private void setName(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void Test() &#123;</span><br><span class="line">    A a &#x3D; Mockito.mock(A.class);</span><br><span class="line">    &#x2F;&#x2F;void 方法才能调用doNothing()</span><br><span class="line">    Mockito.doNothing().when(a.setName(Mockito.anyString()));</span><br><span class="line">    a.setName(&quot;bb&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;bb&quot;,a.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="10-重置-mock"><a href="#10-重置-mock" class="headerlink" title="10.重置 mock"></a>10.重置 mock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void reset_mock()&#123;</span><br><span class="line">        List list &#x3D; mock(List.class);</span><br><span class="line">        Mockito. when(list.size()).thenReturn(10);</span><br><span class="line">        list.add(1);</span><br><span class="line">        Assert.assertEquals(10,list.size());</span><br><span class="line">        &#x2F;&#x2F;重置mock，清除所有的互动和预设</span><br><span class="line">        Mockito.reset(list);</span><br><span class="line">        Assert.assertEquals(0,list.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-调用真实的方法"><a href="#11-调用真实的方法" class="headerlink" title="11.调用真实的方法"></a>11.调用真实的方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return &quot;zhangsan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void Test() &#123;</span><br><span class="line">    A a &#x3D; Mockito.mock(A.class);</span><br><span class="line">    &#x2F;&#x2F;void 方法才能调用doNothing()</span><br><span class="line">    Mockito.when(a.getName()).thenReturn(&quot;bb&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;bb&quot;,a.getName());</span><br><span class="line">    &#x2F;&#x2F;等价于Mockito.when(a.getName()).thenCallRealMethod();</span><br><span class="line">    Mockito.doCallRealMethod().when(a).getName();</span><br><span class="line">    Assert.assertEquals(&quot;zhangsan&quot;,a.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改对未预设的调用返回默认期望（指定返回值）"><a href="#修改对未预设的调用返回默认期望（指定返回值）" class="headerlink" title="修改对未预设的调用返回默认期望（指定返回值）"></a>修改对未预设的调用返回默认期望（指定返回值）</h4><p>//mock对象使用Answer来对未预设的调用返回默认期望值<br>List mock = Mockito.mock(List.class,new Answer() {<br>     @Override<br>     public Object answer(InvocationOnMock invocation) throws Throwable {<br>         return 999;<br>     }<br> });<br> //下面的get(1)没有预设，通常情况下会返回NULL，但是使用了Answer改变了默认期望值<br> Assert.assertEquals(999, mock.get(1));<br> //下面的size()没有预设，通常情况下会返回0，但是使用了Answer改变了默认期望值<br> Assert.assertEquals(999,mock.size());</p>
<h4 id="Mock-注解"><a href="#Mock-注解" class="headerlink" title="@Mock 注解"></a>@Mock 注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MockitoTest &#123;</span><br><span class="line">    @Mock</span><br><span class="line">    private List mockList;</span><br><span class="line">    &#x2F;&#x2F;必须在基类中添加初始化mock的代码，否则报错mock的对象为NULL</span><br><span class="line">    public MockitoTest()&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void AnnoTest() &#123;</span><br><span class="line">            mockList.add(1);</span><br><span class="line">        Mockito.verify(mockList).add(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MockBean"><a href="#MockBean" class="headerlink" title="@MockBean"></a>@MockBean</h4><blockquote>
<p>使用 @MockBean 可以解决单元测试中的一些依赖问题，示例如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ServiceWithMockBeanTest &#123;</span><br><span class="line">    @MockBean</span><br><span class="line">    SampleDependencyA dependencyA;</span><br><span class="line">    @Autowired</span><br><span class="line">    SampleService sampleService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testDependency() &#123;</span><br><span class="line">        when(dependencyA.getExternalValue(anyString())).thenReturn(&quot;mock val: A&quot;);</span><br><span class="line">        assertEquals(&quot;mock val: A&quot;, sampleService.foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@MockBean 只能 mock 本地的代码——或者说是自己写的代码，对于储存在库中而且又是以 Bean 的形式装配到代码中的类无能为力。<br>@SpyBean 解决了 SpringBoot 的单元测试中 @MockBean 不能 mock 库中自动装配的 Bean 的局限（目前还没需求，有需要的自己查阅资料）。</p>
</blockquote>
<h4 id="指定测试类使用运行器：MockitoJUnitRunner"><a href="#指定测试类使用运行器：MockitoJUnitRunner" class="headerlink" title="指定测试类使用运行器：MockitoJUnitRunner"></a>指定测试类使用运行器：MockitoJUnitRunner</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)</span><br><span class="line">public class MockitoTest2 &#123;</span><br><span class="line">    @Mock</span><br><span class="line">    private List mockList;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shorthand()&#123;</span><br><span class="line">        mockList.add(1);</span><br><span class="line">        Mockito.verify(mockList).add(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Mock</tag>
        <tag>UnitTest</tag>
      </tags>
  </entry>
  <entry>
    <title>PO,BO,VO和POJO的区别</title>
    <url>/2018/12/18/Java-PO,BO,VO%E5%92%8CPOJO%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="PO-BO-VO和POJO的区别"><a href="#PO-BO-VO和POJO的区别" class="headerlink" title="PO,BO,VO和POJO的区别"></a>PO,BO,VO和POJO的区别</h2><h3 id="POJO对象"><a href="#POJO对象" class="headerlink" title="POJO对象"></a>POJO对象</h3><p>POJO：plain ordinary java object 无规则简单java对象<br>一个中间对象，可以转化为PO、DTO、VO。<br>1.POJO持久化之后==〉PO<br>（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）<br>2.POJO传输过程中==〉DTO<br>3.POJO用作表示层==〉VO<br>PO 和VO都应该属于它。</p>
<h3 id="PO对象"><a href="#PO对象" class="headerlink" title="PO对象"></a>PO对象</h3><p>PO：persistent object 持久对象<br>1.有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。<br>2.在hibernate持久化框架中与insert/delet操作密切相关。<br>3.PO中不应该包含任何对数据库的操作。</p>
<h3 id="DTO（TO）对象"><a href="#DTO（TO）对象" class="headerlink" title="DTO（TO）对象"></a>DTO（TO）对象</h3><p>DTO（TO）：Data Transfer Object 数据传输对象</p>
<p>1.用在需要跨进程或远程传输时，它不应该包含业务逻辑。<br>2.比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</p>
<h3 id="BO对象"><a href="#BO对象" class="headerlink" title="BO对象"></a>BO对象</h3><p>BO：business object 业务对象</p>
<p>业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。<br>比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。<br>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。<br>这样处理业务逻辑时，我们就可以针对BO去处理。<br>封装业务逻辑为一个对象（可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用）。</p>
<p>关于BO主要有三种概念<br>1.只包含业务对象的属性；<br>2.包含业务方法；<br>3.者都包含。<br>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。</p>
<h3 id="DAO对象"><a href="#DAO对象" class="headerlink" title="DAO对象"></a>DAO对象</h3><p>DAO：data access object数据访问对象</p>
<p>1.主要用来封装对DB的访问（CRUD操作）。<br>2.通过接收Business层的数据，把POJO持久化为PO。</p>
<h3 id="VO对象"><a href="#VO对象" class="headerlink" title="VO对象"></a>VO对象</h3><p>VO：value object 值对象 / view object 表现层对象</p>
<p>1.主要对应页面显示（web页面/swt、swing界面）的数据对象。<br>2.可以和表对应，也可以不，这根据业务的需要。</p>
<h2 id="实体转换工具"><a href="#实体转换工具" class="headerlink" title="实体转换工具()"></a>实体转换工具()</h2><h3 id="SpringFrame-BeanUtil转换工具"><a href="#SpringFrame-BeanUtil转换工具" class="headerlink" title="SpringFrame-BeanUtil转换工具"></a>SpringFrame-BeanUtil转换工具</h3><p>org.springframework.beans.BeanUtils;<br><a href="/file/BackEnd-Java-BeanConvertor.java">封装BeanUtils工具类</a></p>
<h3 id="asm实现比spring-BeanUtils性能更好的属性拷贝框架"><a href="#asm实现比spring-BeanUtils性能更好的属性拷贝框架" class="headerlink" title="asm实现比spring BeanUtils性能更好的属性拷贝框架"></a>asm实现比spring BeanUtils性能更好的属性拷贝框架</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.houbb&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bean-mapping-asm&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.2.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="BeanMapping"><a href="#BeanMapping" class="headerlink" title="BeanMapping"></a>BeanMapping</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.houbb&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bean-mapping-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.2.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Mapstruct转换"><a href="#Mapstruct转换" class="headerlink" title="Mapstruct转换"></a><a href="https://www.cnblogs.com/mmzs/p/12735212.html" target="_blank" rel="noopener">Mapstruct转换</a></h3><p><a href="https://blog.csdn.net/Z143430039/article/details/111054479" target="_blank" rel="noopener">Mapstruct 使用教程</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mapstruct&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapstruct&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.1.Final&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>BackEnd</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot 配置文件位置</title>
    <url>/2021/07/23/Java-Spring%20boot%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Spring-boot-的Application-properties-配置文件可以是以下几个地方："><a href="#Spring-boot-的Application-properties-配置文件可以是以下几个地方：" class="headerlink" title="Spring boot 的Application.properties 配置文件可以是以下几个地方："></a>Spring boot 的Application.properties 配置文件可以是以下几个地方：</h2><p>classpath:/,classpath:/config/,file:./,file:./config/.</p>
<p>但要注意的是加载的顺序是倒过来的：<br>file:./config/<br>file:./<br>classpath:/config/<br>classpath:/</p>
<p>可以通过spring.config.location增加自定义的配置文件存放目录，比如：<br>classpath:/custom-config/,file:./custom-config/</p>
<p>那么最终的寻找路径是：<br>file:./custom-config/<br>classpath:custom-config/<br>file:./config/<br>file:./<br>classpath:/config/<br>classpath:/</p>
<p>可以通过spring.config.name 修改默认的配置文件名称，比如：<br>$ java -jar myproject.jar –spring.config.name=myproject</p>
<p>可以通过spring.config.location指定配置文件，比如：<br>$ java -jar myproject.jar –spring.config.location=classpath:/default.properties,classpath:/override.properties</p>
<p>可以通过spring.config.location指定配置文件的位置，比如：<br>$ java -jar myproject.jar –<br>spring.config.additional-location=classpath:/custom-config/,file:./custom-config/</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal原理及源码解析</title>
    <url>/2021/05/07/Java-ThreadLocal%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="ThreadLocal解决的问题"><a href="#ThreadLocal解决的问题" class="headerlink" title="ThreadLocal解决的问题"></a>ThreadLocal解决的问题</h2><p><img src="/java/ThreadLocal0.png" alt="ThreadLocal解决的问题"><br>ThreadLocal解决线程局部变量统一定义问题，多线程数据不能共享。（InheritableThreadLocal特例除外）不能解决并发问题。解决了：基于类级别的变量定义，每一个线程单独维护自己线程内的变量值（存、取、删的功能）；多线程产生的原因就是因为多个线程间存在共享变量。如果我们每个线程都有属于自己的变量。就不会存在变量共享的问题了。ThreadLocal对象的作用就是用来实现每个线程一个变量的作用，每个线程有自己的变量，自己用自己的，就不会出现共享的问题了。</p>
<h2 id="ThreadLocal结构源码结构"><a href="#ThreadLocal结构源码结构" class="headerlink" title="ThreadLocal结构源码结构"></a>ThreadLocal结构源码结构</h2><p>下面我们从源码层面分析，ThreadLocal是怎么和当前线程绑定起来的 ？我们进Thread的源码看一下。在源码中可以看到一个threadLocals的成员变量。类型为ThreadLocalMap。</p>
<h3 id="threadLocals-对象"><a href="#threadLocals-对象" class="headerlink" title="threadLocals 对象"></a>threadLocals 对象</h3><p><img src="/java/ThreadLocal1.png" alt="threadLocals"></p>
<h3 id="ThreadLocalMap-静态内部类"><a href="#ThreadLocalMap-静态内部类" class="headerlink" title="ThreadLocalMap 静态内部类"></a>ThreadLocalMap 静态内部类</h3><p>ThreadLocalMap,去看它的源码：<br><img src="/java/ThreadLocal2.png" alt="ThreadLocalMap"></p>
<p>ThreadLocalMap是ThreadLocal的一个静态内部类。ThreadLocalMap 内部是一个private Entry<a href="数组容器"></a>,Entry(K,V)结构存入数组,一共有两个地方初始化，一个是ThreadLocal类set方法中，一个是ThreadLocal类get方法中</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>先看get方法的源码：<br><img src="/java/ThreadLocal3.png" alt="get方法"></p>
<h3 id="setInitialValue方法"><a href="#setInitialValue方法" class="headerlink" title="setInitialValue方法"></a>setInitialValue方法</h3><p><img src="/java/ThreadLocal4.png" alt="setInitialValue方法"><br>如果我们没有往ThreadLocal对象中set值，直接就调用get方法的话，map为空。此时就会调用setInitialValue方法，初始化一个ThreadLocalMap对象。如果map不为空，会根据当前线程对象从ThreadLocalMap中取出当前线程对象对应的value值。我们可以看到，map先是获取了一个Entry对象，真正的值是放在这个Entry对象中，下面我们会详细说出。</p>
<h3 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a>initialValue方法</h3><p>一个initialValue方法，这个方法是给ThreadLocal赋初始化值的。初始是这样的<br><img src="/java/ThreadLocal5.png" alt="initialValue方法"></p>
<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>我们可以看到该方法的访问权限是protected，也就是子类复写使用。我们可以overriden该方法。初次调用get方法时，赋一个初始值。<br>好了，继续回到ThreadLocalMap的初始化问题。除了上面说的get方法。还有就是在set方法中，继续看源码：<br><img src="/java/ThreadLocal6.png" alt="set方法"></p>
<h3 id="Entry对象"><a href="#Entry对象" class="headerlink" title="Entry对象"></a>Entry对象</h3><p>说完ThreadLocalMap对象的初始化，继续说Entry对象。这个Entry对象又是什么呢?<br>点进源码去看看：<br><img src="/java/ThreadLocal7.png" alt="Entry对象"></p>
<h3 id="getMap方法"><a href="#getMap方法" class="headerlink" title="getMap方法"></a>getMap方法</h3><p>set方法挺清晰的，就是获取当前线程对象，然后获取ThreadLocalMap映射表对象。<br>看一下getMap方法的源码<br><img src="/java/ThreadLocal9.png" alt="getMap方法"></p>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p><img src="/java/ThreadLocal11.png" alt="remove方法"><br>首先根据key计算一下Entry所在的索引，然后判断是否为空，如果不为空，就判断该下标对应的key是否等于我们传入的key，如果相等，就会清除掉Entry对象对应的key，同时清除掉value。同时还有这个Entry对象。</p>
<h3 id="ThreadLocalMap的set方法"><a href="#ThreadLocalMap的set方法" class="headerlink" title="ThreadLocalMap的set方法"></a>ThreadLocalMap的set方法</h3><p><img src="/java/ThreadLocal10.png" alt="ThreadLocalMap"></p>
<p>首先获取Entry数组，然后利用算法计算Entry数组的一个索引下标，准备存放新的Entry对象。如果当前ThreadLocal对象关联的Entry对象在Entry数组中已经存在，就覆盖原来的值。如果计算的索引所关联的Entry对象的key为空。说明存在GC回收掉key的情况，这个时候就会清除掉该key对应的value以及Entry对象。<br>如果在for循环中没有返回的话，就会新建一个新的Entry。然后将Entry数组中的长度加1，同时判断该数组是否需要扩展。</p>
<h3 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h3><p>可以看到，Entry对象继承了弱引用对象WeakReference，弱引用对象意为：在GC时会回收的对象。( java一共有4种引用类型，弱引用是其中一种，相关知识可以百度了解一下)。从构造函数中可以看到，Entry将key，也就是当前ThreadLocal对象传递给了弱引用，所以在GC时，如果ThreadLocal对象没有强引用的话，当前Entry中的key（ThreadLocal对象）会被GC回收。Thread，ThreadLocal，ThreadLocalMap，Entry。这几个对象之间的关系是怎么样的呢?<br><img src="/java/ThreadLocal8a.png" alt="ThreadLocalMap"><br><img src="/java/ThreadLocal8.png" alt="ThreadLocalMap"></p>
<h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>上图可以看出，ThreadLocalMap中维护的是一个Entry数组作为存放threadLocal的Entry对象容器?<br>为什么ThreadLocalMap中引用的Entry是一个数组类型呢？因为在一个线程中，我们可以new多个ThreadLocal对象。多个ThreadLocal对象就对应着一个ThreadLocalMap(以thread对象绑定)，一个map(数组容器)threadLocal Entry对象，以threadlocal对象计算数组下标。</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>这里有一个问题，为什么ThreadLocal的作者要将Entry中的key设计成弱引用呢？<br>　　如果当前ThreadLocal对象没有强引用存在，就通知GC回收该key，此时key变为null。同时，作者在set，get中，都对key为null的情况做了处理。会清除掉key为null的Entry对象。这样就可以避免，我们使用了set和get方法，但是没有显示调用remove清除该key的问题。一定程度上避免了内存泄露的问题。<br>　　虽然作者做了很多处理，但是由于线程池技术的普及，ThreadLocal对象使用不当，还是会造成内存泄露。为什么呢？原因是：我们在线程池中取出的链接不会销毁，会返回到池中复用。如果我们对ThreadLocal对象手动set了一个值，但是后期没有再次调用set和get方法。下一次GC发生时，会回收掉key，但是由于value为一个强引用，所以导致key为null，永远无法被取出。该块内存空间永远无法被使用。内存泄露。所以，我们在使用ThreadLocal对象时，用完的值要注意执行remove操作。</p>
<p><font color='red'>另外，ThreadLocal的最佳实践是用static关键字修饰，防止产生多个ThreadLocal对象，内存浪费。【ThreadLocalMap是不是使用static引用而不是creatMap时使用new？】</font></p>
<h2 id="ThreadLocal内存模型原理"><a href="#ThreadLocal内存模型原理" class="headerlink" title="ThreadLocal内存模型原理"></a>ThreadLocal内存模型原理</h2><p><img src="/java/ThreadLocal12.png" alt="ThreadLocalMap"></p>
<p>图中左边是栈，右边是堆。线程的一些局部变量和引用使用的内存属于Stack（栈）区，而普通的对象是存储在Heap（堆）区。</p>
<ul>
<li>线程运行时，我们定义的TheadLocal对象被初始化，存储在Heap，同时线程运行的栈区保存了指向该实例的引用，也就是图中的ThreadLocalRef。</li>
<li>当ThreadLocal的set/get被调用时，虚拟机会根据当前线程的引用也就是CurrentThreadRef找到其对应在堆区的实例，然后查看其对用的TheadLocalMap实例是否被创建，如果没有，则创建并初始化。</li>
<li>Map实例化之后，也就拿到了该ThreadLocalMap的句柄，那么就可以将当前ThreadLocal对象作为key，进行存取操作。</li>
<li>图中的虚线，表示key对应ThreadLocal实例的引用是个弱引用。</li>
</ul>
<h2 id="ThreadLocal避免内存泄漏"><a href="#ThreadLocal避免内存泄漏" class="headerlink" title="ThreadLocal避免内存泄漏"></a>ThreadLocal避免内存泄漏</h2><p>通过前面几小结我们分析了ThreadLocal的类设计以及内存模型，同时也重点分析了发生内存泄露的条件和特定场景。最后结合项目中的经验给出建议使用ThreadLocal的场景：<br>当需要存储线程私有变量的时候。<br>当需要实现线程安全的变量时。<br>当需要减少线程资源竞争的时候。<br>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？<br><font color ='red'>每次使用完ThreadLocal，建议调用它的remove()方法，清除数据。</font></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建单元测试</title>
    <url>/2020/12/09/Java-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="点击可以查找Manven依赖"><a href="#点击可以查找Manven依赖" class="headerlink" title="点击可以查找Manven依赖"></a><a href="https://search.maven.org/" target="_blank" rel="noopener">点击可以查找Manven依赖</a></h2><h2 id="Junit-单元测试"><a href="#Junit-单元测试" class="headerlink" title="Junit-单元测试"></a><a href="vogella.com/tutorials/JUnit/article.html#junittesting">Junit-单元测试</a></h2><p><a href="https://junit.org/junit5/docs/current/user-guide/#overview" target="_blank" rel="noopener">JUnit 5官方文档</a><br>JUnit 5= JUnit Platform + JUnit Jupiter + JUnit Vintage</p>
<ul>
<li>JUnit Platform是在JVM上启动测试框架的基础</li>
<li>JUnit Jupiter是JUnit5扩展的新的编程模型和扩展模型，用来编写测试用例。Jupiter子项目为在平台上运行Jupiter的测试提供了一个TestEngine(测试引擎)</li>
<li>JUnit Vintage提供了一个在平台上运行JUnit 3和JUnit 4的TestEngine</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.junit.platform&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit-platform-launcher&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.0.1&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.0.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Mockito-模拟数据"><a href="#Mockito-模拟数据" class="headerlink" title="Mockito-模拟数据"></a><a href="https://www.vogella.com/tutorials/Mockito/article.html" target="_blank" rel="noopener">Mockito-模拟数据</a></h2><p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/Unit-tests-with-Mockito.md" target="_blank" rel="noopener">Unit-tests-with-Mockito</a><br><a href="http://mockito.github.io/" target="_blank" rel="noopener">Mockito框架</a></p>
<p>Mock作用:</p>
<ul>
<li>验证这个对象的某些方法的调用情况,调用了多少次,参数是什么等等</li>
<li>指定这个对象的某些方法的行为,返回特定的值,或者是执行特定的动作</li>
<li>spy与mock的唯一区别就是默认行为不一样:spy对象的方法默认调用真实的逻辑,mock对象的方法默认什么都不做,或直接返回默认值</li>
</ul>
<h2 id="MockServer"><a href="#MockServer" class="headerlink" title="MockServer"></a>MockServer</h2><h2 id="Sonarlint-质量控制"><a href="#Sonarlint-质量控制" class="headerlink" title="Sonarlint-质量控制"></a>Sonarlint-质量控制</h2><h3 id="SonarLint插件安装"><a href="#SonarLint插件安装" class="headerlink" title="SonarLint插件安装"></a>SonarLint插件安装</h3><p>IDEA菜单栏选择File-&gt;Settings，左边栏选择Plugins—&gt;下载SonarLint(可能需要翻墙)</p>
<h3 id="IDEA-SonarLint使用"><a href="#IDEA-SonarLint使用" class="headerlink" title="IDEA SonarLint使用"></a>IDEA SonarLint使用</h3><ul>
<li>安装SonarLint插件重启后，IDEA Tool Windows部分会出现SonarLint View。如果没有出现，选择菜单View-&gt;Tool Windows-&gt;SonarLint会显示</li>
</ul>
<h4 id="激活SonarLint在线检测"><a href="#激活SonarLint在线检测" class="headerlink" title="激活SonarLint在线检测"></a>激活SonarLint在线检测</h4><h4 id="安装sonarqube检测"><a href="#安装sonarqube检测" class="headerlink" title="安装sonarqube检测"></a>安装sonarqube检测</h4><p><a href="https://cloud.tencent.com/developer/article/1484850" target="_blank" rel="noopener">SonarQube部署及代码质量扫描入门教程</a><br><a href="https://www.jianshu.com/p/ecde17e91711" target="_blank" rel="noopener">Sonar代码质量与技术债</a><br><a href="https://mp.weixin.qq.com/s/V_IpoSDcWr37BE3sWKTbyw" target="_blank" rel="noopener">Jenkins+SonarQube+Gitlab搭建自动化持续代码扫描质平台</a><br><a href="https://www.jianshu.com/p/7d1c0f5dcc78" target="_blank" rel="noopener">SonarQube 搭建代码质量管理平台（一）</a><br><a href="https://www.jianshu.com/p/dd2b2be06d38" target="_blank" rel="noopener">SonarQube 搭建代码质量管理平台（二）</a></p>
<h2 id="Jacoco-覆盖率"><a href="#Jacoco-覆盖率" class="headerlink" title="Jacoco-覆盖率"></a>Jacoco-覆盖率</h2><h3 id="在-pom-xml中引入Jacoco与Junit依赖"><a href="#在-pom-xml中引入Jacoco与Junit依赖" class="headerlink" title="在 pom.xml中引入Jacoco与Junit依赖"></a>在 pom.xml中引入Jacoco与Junit依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.jacoco&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jacoco-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.8.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>在构建配置中设置Jacoco规则与引入maven surefire plugin<br>1.maven-surefire-plugin：该插件也可以称为测试运行器(Test Runner)，它能兼容JUnit 3、JUnit 4以及TestNG，在pom中如不显式配置就会用默认配置。在默认情况下，该插件的test目标会自动执行测试源码路径（默认为src/test/java/）下所有符合一组命名模式的测试类。这组模式为：<br>|默认包含的测试类|    默认排除的测试类|<br>|—————|—————–|<br>|/＊Test.java <br> /Test＊.java <br> /＊TestCase.java <br>|Abstract＊TestCase.java|</p>
<p>2.Jacoco规则为（以下第三点配置为例子）</p>
<ul>
<li>在<configuration>中配置具体生成的jacoco-unit.exec的目录，同步通过<include>指定；</li>
<li>在<rules>中配置对应的覆盖率检测规则；</li>
<li>在<executions>中配置执行步骤：<br>1.prepare-agent(即构建jacoco-unit.exec)；<br>2.check(即根据在<rules>定义的规矩进行检测)；<br>3.package(生成覆盖率报告，默认生成在target/site/index.html)</li>
</ul>
<h3 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h3><p><a href="https://blog.csdn.net/weixin_40514600/article/details/102583631" target="_blank" rel="noopener">参考文件</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;guns&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.18.1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">               	    &lt;!-- 不跳过测试 --&gt;</span><br><span class="line">                    &lt;skipTests&gt;false&lt;&#x2F;skipTests&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.jacoco&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jacoco-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;0.8.2&lt;&#x2F;version&gt;</span><br><span class="line">                 &lt;configuration&gt;</span><br><span class="line">                    &lt;skip&gt;false&lt;&#x2F;skip&gt;</span><br><span class="line">                    &lt;destFile&gt;target&#x2F;coverage-reports&#x2F;jacoco-unit.exec&lt;&#x2F;destFile&gt;</span><br><span class="line">                    &lt;dataFile&gt;target&#x2F;coverage-reports&#x2F;jacoco-unit.exec&lt;&#x2F;dataFile&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**&#x2F;stylefeng&#x2F;guns&#x2F;**&lt;&#x2F;include&gt;</span><br><span class="line">                        &lt;!--&lt;include&gt;**&#x2F;service&#x2F;impl&#x2F;*.class&lt;&#x2F;include&gt;--&gt;</span><br><span class="line">                    &lt;&#x2F;includes&gt;</span><br><span class="line">                    &lt;!-- rules里面指定覆盖规则 --&gt;</span><br><span class="line">                    &lt;rules&gt;</span><br><span class="line">                        &lt;rule implementation&#x3D;&quot;org.jacoco.maven.RuleConfiguration&quot;&gt;</span><br><span class="line">                            &lt;element&gt;BUNDLE&lt;&#x2F;element&gt;</span><br><span class="line">                            &lt;limits&gt;　　</span><br><span class="line">                                &lt;!-- 指定方法覆盖到50% --&gt;</span><br><span class="line">                                &lt;limit implementation&#x3D;&quot;org.jacoco.report.check.Limit&quot;&gt;</span><br><span class="line">                                    &lt;counter&gt;METHOD&lt;&#x2F;counter&gt;</span><br><span class="line">                                    &lt;value&gt;COVEREDRATIO&lt;&#x2F;value&gt;</span><br><span class="line">                                    &lt;minimum&gt;0.01&lt;&#x2F;minimum&gt;</span><br><span class="line">                                &lt;&#x2F;limit&gt;</span><br><span class="line">                                &lt;!-- 指定分支覆盖到50% --&gt;</span><br><span class="line">                                &lt;limit implementation&#x3D;&quot;org.jacoco.report.check.Limit&quot;&gt;</span><br><span class="line">                                    &lt;counter&gt;BRANCH&lt;&#x2F;counter&gt;</span><br><span class="line">                                    &lt;value&gt;COVEREDRATIO&lt;&#x2F;value&gt;</span><br><span class="line">                                    &lt;minimum&gt;0.01&lt;&#x2F;minimum&gt;</span><br><span class="line">                                &lt;&#x2F;limit&gt;</span><br><span class="line">                                &lt;!-- 指定类覆盖到100%，不能遗失任何类 --&gt;</span><br><span class="line">                                &lt;limit implementation&#x3D;&quot;org.jacoco.report.check.Limit&quot;&gt;</span><br><span class="line">                                    &lt;counter&gt;CLASS&lt;&#x2F;counter&gt;</span><br><span class="line">                                    &lt;value&gt;MISSEDCOUNT&lt;&#x2F;value&gt;</span><br><span class="line">                                    &lt;maximum&gt;100&lt;&#x2F;maximum&gt;</span><br><span class="line">                                &lt;&#x2F;limit&gt;</span><br><span class="line">                            &lt;&#x2F;limits&gt;</span><br><span class="line">                        &lt;&#x2F;rule&gt;</span><br><span class="line">                    &lt;&#x2F;rules&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个--&gt;</span><br><span class="line">                    &lt;!-- 参数 传给被测程序，用于监控JVM中的调用。 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;jacoco-initialize&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;prepare-agent&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                    &lt;!--这个check:对代码进行检测，控制项目构建成功还是失败--&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;check&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;check&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                    &lt;!--这个report:对代码进行检测，然后生成index.html在--&gt;</span><br><span class="line">                    &lt;!--target&#x2F;site&#x2F;index.html 中可以查看检测的详细结果--&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                        	 &lt;!-- 指定覆盖率报告的生成位置 --&gt;</span><br><span class="line">                            &lt;outputDirectory&gt;$&#123;basedir&#125;&#x2F;target&#x2F;coverage-reports&lt;&#x2F;outputDirectory&gt;</span><br><span class="line">                        &lt;&#x2F;configuration&gt;</span><br><span class="line">                        &lt;id&gt;default-report&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;phase&gt;prepare-package&lt;&#x2F;phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;report&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure>

<h3 id="项目根目录下运行mvn命令"><a href="#项目根目录下运行mvn命令" class="headerlink" title="项目根目录下运行mvn命令"></a>项目根目录下运行mvn命令</h3><p>mvn clean install</p>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>访问target目下的index.html,查看覆盖率报告</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>UnitTest</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable原理</title>
    <url>/2020/12/12/Java-Serializable/</url>
    <content><![CDATA[<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><ul>
<li>把对象转换为字节序列的过程称为对象的序列化</li>
<li>把字节序列恢复为对象的过程称为对象的反序列化</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>实现接口:Serializable接口(设置开发工具生成serialVersionUID)<br>如果要为序列化的类中忽略某个字段,可添加transient/static关键字</p>
<h2 id="为什么要序列化对象"><a href="#为什么要序列化对象" class="headerlink" title="为什么要序列化对象"></a>为什么要序列化对象</h2><p>对象的序列化主要有两种用途：<br>　　1) 把对象的字节序列永久地保存到硬盘上,通常存放在一个文件中；<br>　　2)将类创建的对象转化为字节流实现跨平台的目的。按值将对象从一个应用程序域发送至另一个应用程序域。实现 serializabel接口 的作用是就是可以把对象存到字节流,然后可以恢复,所以你想如果你的对象没实现序列化怎么才能进行持久化和网络传输呢,要持久化和网络传输就得转为字节流,所以在分布式应用中及设计数据持久化的场景中,你就得实现序列化。</p>
<h3 id="两种方式生成serialVersionUID"><a href="#两种方式生成serialVersionUID" class="headerlink" title="两种方式生成serialVersionUID"></a>两种方式生成serialVersionUID</h3><p>第一种方式生成的是1L:<br>    private static final long serialVersionUID = 1L;<br>第二种是根据类名、属性、方法等生成的:<br>    private static final long serialVersionUID = -6367006705587584157L;</p>
<h3 id="序列化ID的作用："><a href="#序列化ID的作用：" class="headerlink" title="序列化ID的作用："></a>序列化ID的作用：</h3><pre><code>其实,这个序列化ID起着关键的作用,它决定着是否能够成功反序列化!简单来说,java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时,会把加载在JVM的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较,如果相同则认为是一致的,便可以进行反序列化,否则就会报序列化版本不一致的异常。等会我们可以通过代码验证一下。</code></pre><h3 id="序列化ID如何产生："><a href="#序列化ID如何产生：" class="headerlink" title="序列化ID如何产生："></a>序列化ID如何产生：</h3><pre><code>当我们一个实体类中没有显示的定义一个名为“serialVersionUID”、类型为long的变量时,Java序列化机制会根据编译时的class自动生成一个serialVersionUID作为序列化版本比较,这种情况下,只有同一次编译生成的class才会生成相同的serialVersionUID。譬如,当我们编写一个类时,随着时间的推移,我们因为需求改动,需要在本地类中添加其他的字段,这个时候再反序列化时便会出现serialVersionUID不一致,导致反序列化失败。那么如何解决呢？便是在本地类中添加一个“serialVersionUID”变量,值保持不变,便可以进行序列化和反序列化。</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>虚拟机是否允许反序列化,不仅取决于类路径和功能代码是否一致,一个非常重要的一点是两个类的序列化 ID 是否一致(就是 private static final long serialVersionUID = 1L)。</code></pre><h2 id="是不是每个实体bean都要实现序列化"><a href="#是不是每个实体bean都要实现序列化" class="headerlink" title="是不是每个实体bean都要实现序列化"></a>是不是每个实体bean都要实现序列化</h2><p> bean 是否需要持久化存储媒体中以及是否需要传输给另一个应用,没有的话就不需要,例如我们利用 fastjson 将实体类转化成 json 字符串时,并不涉及到转化为字节流,所以其实跟序列化没有关系</p>
<h2 id="有的时候并没有实现序列化-依然可以持久化到数据库"><a href="#有的时候并没有实现序列化-依然可以持久化到数据库" class="headerlink" title="有的时候并没有实现序列化,依然可以持久化到数据库"></a>有的时候并没有实现序列化,依然可以持久化到数据库</h2><p>实体类中常用的数据类型,例如 Date、String 等等,它们已经实现了序列化,而一些基本类型,数据库里面有与之对应的数据结构,从我们的类声明来看,我们没有实现 serializabel接口 ,其实是在声明的各个不同变量的时候,由具体的数据类型帮助我们实现了序列化操作。</p>
<h2 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SerialTest &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个小明</span><br><span class="line">		User user &#x3D; new User(1,&quot;小明&quot;);</span><br><span class="line">		&#x2F;&#x2F; ObjectOutputStream 对象输出流</span><br><span class="line">		ObjectOutputStream oo &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;D:&#x2F;User.txt&quot;)));</span><br><span class="line">		&#x2F;&#x2F; 序列化输出User对象</span><br><span class="line">		oo.writeObject(user);</span><br><span class="line">		System.out.println(&quot;序列化成功!&quot;);</span><br><span class="line">        oo.flush();</span><br><span class="line">        oo.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DeserialTest &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F; ObjectInputStream 对象读取流</span><br><span class="line">		ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;D:&#x2F;User.txt&quot;)));</span><br><span class="line">		&#x2F;&#x2F; 反序列化User对象</span><br><span class="line">		User user &#x3D; (User) ois.readObject();</span><br><span class="line">		System.out.println(&quot;反序列化成功!&quot;);</span><br><span class="line">		ois.close();</span><br><span class="line">		return user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h3><p><font color="red">说明：反序列化前 表示 在序列化操作完成之后到反序列化开始之前这段时间,更改User类的字段</font><br>a. 不实现Serializable接口<br>b. 实现Serializable接口<br>c. 未自定义serialVersionUID字段<br>d. 自定义serialVersionUID字段<br>e. 反序列化前增加字段<br>f. 反序列化前减少字段<br>g. 反序列化前修改字段的类型</p>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>1.只要有a(不实现Serializable接口)出现,就会导致java.io.NotSerializableException异常,即无法完成序列化。<br>2.当条件为 b(实现Serializable接口)+c(未自定义serialVersionUID字段) 或者 b(实现Serializable接口)+d(自定义serialVersionUID字段) 时,序列化和反序列化均正常执行。<br>3.当条件为 b(实现Serializable接口)+c(未自定义serialVersionUID字段) +e(反序列化前增加字段) 或者 b(实现Serializable接口)+c(未自定义serialVersionUID字段) +f(反序列化前减少字段) 时,反序列化时将抛出InvalidClassException异常。<br>4.当条件为 b(实现Serializable接口)+d(自定义serialVersionUID字段)+e(反序列化前增加字段) 或者 b(实现Serializable接口)+d(自定义serialVersionUID字段)+f(反序列化前减少字段) 时,序列化和反序列一切正常,若增加字段时,反序列化出来该字段为缺省值;若减少字段时,反序列化出来也将没有此字段。<br>5.当条件包含 g(反序列化前修改字段的类型) 时,反序列化也将抛出InvalidClassException异常。</p>
<ul>
<li>总结<br>启动服务后,将D盘user文件生成为user.class;若有外部请求接受到流后,根据流的信息要寻找对流的对象类存放数据(user.class),寻找已经存储的user.class后进行反序列化,其中需要对比serialVersionUID是否一致;因为 Java 的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时,JVM 会把传来的字节流中的serialVersionUID与本地相应实体(类)的serialVersionUID进行比较,如果相同就认为是一致的,可以进行反序列化,否则就会出现序列化版本不一致的异常</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Serializable</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2020/09/12/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Java的三大特性"><a href="#Java的三大特性" class="headerlink" title="Java的三大特性"></a>Java的三大特性</h2><ul>
<li>封装(类对象):是指隐藏对象的属性和实现细节,仅对外提供公共访问方式。</li>
<li>继承(类):继承是面向对象最显著的一个特性。 继承是从已有的类中派生出新的类, 新的类能吸收已有类的数据属性和行为,并能扩展新的能力。<br>在JAVA中, 被继承的类叫父类(parent class)或超类(superclass), 继承父类的类叫子类(subclass)或派生类(derivedclass)。 因此, 子类是父类的一个专门用途的版本, 它继承了父类中定义的所有实例变量和方法, 并且增加了独特的元素 。</li>
<li>多态(接口):在面向对象语言中, 多态性是指一个方法可以有多种实现版本,即“一种定义, 多种实现”。 利用多态可以设计和实现可扩展的系统, 只要新类也在继承层次中。 新的类对程序的通用部分只需进行很少的修改, 或不做修改。 类的多态性表现为方法的多态性,方法的多态性主要有方法的重载和方法的覆盖。</li>
</ul>
<h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String/StringBuffer/StringBuilder"></a>String/StringBuffer/StringBuilder</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>　　String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，这样不仅效率低下，而且大量浪费有限的内存空间，所以经常改变内容的字符串最好不要用 String 。因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的</p>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>　　线程安全,所有公开方法都加synchronized.任何对它指向的字符串的操作都不会产生新的对象。 每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。</p>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><pre><code>线程不安全,不加synchronized.</code></pre><h2 id="spring-bean作用域有以下5个："><a href="#spring-bean作用域有以下5个：" class="headerlink" title="spring bean作用域有以下5个："></a>spring bean作用域有以下5个：</h2><p>singleton: 单例模式,当spring创建applicationContext容器的时候,spring会欲初始化所有的该作用域实例,加上lazy-init就可以避免预处理;<br>prototype:原型模式,每次通过getBean获取该bean就会新产生一个实例,创建后spring将不再对其管理；(下面是在web项目下才用到的)<br>request:搞web的大家都应该明白request的域了吧,就是每次请求都新产生一个实例,<font color='red'>和prototype不同就是创建后,spring依然在监听管理;</font><br>session:每次会话,同上<br>global session: 全局的web域,类似于servlet中的application</p>
<h3 id="Spring的Controller是单例还是多例？怎么保证并发的安全"><a href="#Spring的Controller是单例还是多例？怎么保证并发的安全" class="headerlink" title="Spring的Controller是单例还是多例？怎么保证并发的安全"></a>Spring的Controller是单例还是多例？怎么保证并发的安全</h3><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>不要在controller中定义成员变量。</li>
<li>万一必须要定义一个非静态成员变量时候,则通过注解@Scope(“prototype”),将其设置为多例模式。</li>
<li>在Controller中使用ThreadLocal存放变量</li>
</ul>
<h3 id="Spring-Bean循环依赖"><a href="#Spring-Bean循环依赖" class="headerlink" title="Spring Bean循环依赖"></a>Spring Bean循环依赖</h3><p><a href="https://www.cnblogs.com/changemax/p/12311518.html" target="_blank" rel="noopener">bean循环依赖</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>Beans</tag>
        <tag>Controller</tag>
      </tags>
  </entry>
  <entry>
    <title>控制流量宽带</title>
    <url>/2020/09/12/Java-%E6%8E%A7%E5%88%B6%E6%B5%81%E9%87%8F%E5%AE%BD%E5%B8%A6/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq447995687/article/details/84873717" target="_blank" rel="noopener">java实现流量控制</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>文件加解密</title>
    <url>/2020/12/12/Java-%E6%96%87%E4%BB%B6%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h2 id="文件与字串"><a href="#文件与字串" class="headerlink" title="文件与字串"></a>文件与字串</h2><ul>
<li>文件的操作流程一般为:打开–&gt;读取–&gt;对内容进行变换–&gt;写入–&gt;关闭</li>
<li>常规性文件操作会用到的类有五个:File,InputStream,OutputStream,FileInoutStream,FileOutputStream,均包含在java.io下面。注意,在使用前必须对类文件进行导入,方法为import java.io.File(实现时需要分号结尾)</li>
<li>创建InputStream类和OutputStream类的对象时,new关键字后边的类分别是FileInputStream和FileOutputStream(而不是其自身),如InputStream fin = new FileInputStream(File objectFile)。可以看出构造参数是File类型对象,其创建方式为File file = new File(String fileName)</li>
<li>当String类对象作为函数参数时,可以直接传入常量字符串,如“D:\source.jpg”。String类对象构造方法中比较简单也是最常用的一种是String string = “string content”,当然,最终执行的是String string = new String(“string content”)。其实String是非常重要的类(可以说无处不在),提供了一套完善、高效操作字串的方法,使得开发者受益匪浅</li>
<li>常规性文件操作涉及到的方法有五个:exist(),read(),write(),flush(),close()。exist()判断文件是否存在,调用者为File类对象；read()读取输入流中的内容,调用者为InputStream类对象；write()、flush()、close()的作用分别为向输出流中写内容、强制发送缓冲区中数据、保存并关闭文件,调用者为OutputStream类对象,不过InputStream类对象在操作完成后也需要close()</li>
</ul>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><ul>
<li>MD5:以512位分组来处理输入的信息,且每一分组又被划分为16个32位子分组,经过了一系列的处理后,输出由四个32位分组组成,将这四个32位分组级联后将生成一个128位散列值</li>
<li>SHA:接收一段明文,然后以一种不可逆的方式将它转换成一段(通常更小)密文,也可以简单的理解为取一串输入码(称为预映射或信息),并把它们转化为长度较短、位数固定的输出序列即散列值(也称为信息摘要或信息认证代码)的过程</li>
<li>DES:把64位的明文输入块变为64位的密文输出块,它所使用的密钥也是64位,主要分为两步:<ul>
<li>1.初始置换,把输入的64位数据块按位重新组合,并把输出分为L0、R0两部分,每部分各长32位,其置换规则为将输入的第58位换到第一位,第50位换到第2位…依此类推,最后一位是原来的第7位。L0、R0则是换位输出后的两部分,L0是输出的左32位,R0是右32位。</li>
<li>2.逆置换,经过16次迭代运算后,得到L16、R16,将此作为输入,进行逆置换,逆置换正好是初始置换的逆运算,由此即得到密文输出。</li>
</ul>
</li>
<li>3-DES:使用3条56位的密钥对数据进行三次加密,是DES向AES过渡的加密算法(1999年,NIST将3-DES指定为过渡的加密标准)</li>
<li>AES:使用128、192、和256位密钥,并且用128位分组加密和解密数据</li>
<li>异或:与其说这是一种加密算法,倒不如称其为文件信息的简单变换,将每一个数据与某给定数据进行异或操作即可完成加密或解密,如dataEncrypt = dataSource^dataSecret</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>给定的加密秘钥（异或数据，可以在合法范围内随便定义）为十六进制数0x99<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final int numOfEncAndDec &#x3D; 0x99; &#x2F;&#x2F;加密解密秘钥</span><br><span class="line">   private static int dataOfFile &#x3D; 0; &#x2F;&#x2F;文件字节内容</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">       File srcFile &#x3D; new File(&quot;D:\\abv.txt&quot;); &#x2F;&#x2F;初始文件</span><br><span class="line">       File encFile &#x3D; new File(&quot;D:\\haha.txt&quot;); &#x2F;&#x2F;加密文件</span><br><span class="line">       File decFile &#x3D; new File(&quot;D:\\123.txt&quot;); &#x2F;&#x2F;解密文件</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           EncFile(srcFile, encFile); &#x2F;&#x2F;加密操作</span><br><span class="line">           DecFile(encFile,decFile);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void EncFile(File srcFile, File encFile) throws Exception &#123;</span><br><span class="line">           if(!srcFile.exists())&#123;</span><br><span class="line">               System.out.println(&quot;source file not exixt&quot;);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if(!encFile.exists())&#123;</span><br><span class="line">               System.out.println(&quot;encrypt file created&quot;);</span><br><span class="line">               encFile.createNewFile();</span><br><span class="line">           &#125;</span><br><span class="line">           InputStream fis  &#x3D; new FileInputStream(srcFile);</span><br><span class="line">           OutputStream fos &#x3D; new FileOutputStream(encFile);</span><br><span class="line"></span><br><span class="line">           while ((dataOfFile &#x3D; fis.read()) &gt; -1) &#123;</span><br><span class="line">               fos.write(dataOfFile^numOfEncAndDec);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       fis.close();</span><br><span class="line">       fos.flush();</span><br><span class="line">       fos.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void DecFile(File encFile, File decFile) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">       if(!encFile.exists())&#123;</span><br><span class="line">           System.out.println(&quot;encrypt file not exixt&quot;);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(!decFile.exists())&#123;</span><br><span class="line">           System.out.println(&quot;decrypt file created&quot;);</span><br><span class="line">           decFile.createNewFile();</span><br><span class="line">       &#125;</span><br><span class="line">       InputStream fis  &#x3D; new FileInputStream(encFile);</span><br><span class="line">       OutputStream fos &#x3D; new FileOutputStream(decFile);</span><br><span class="line"></span><br><span class="line">       while ((dataOfFile &#x3D; fis.read()) &gt; -1) &#123;</span><br><span class="line">           fos.write(dataOfFile^numOfEncAndDec);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       fis.close();</span><br><span class="line">       fos.flush();</span><br><span class="line">       fos.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="上传和下载文件-加密和解密"><a href="#上传和下载文件-加密和解密" class="headerlink" title="上传和下载文件(加密和解密)"></a>上传和下载文件(加密和解密)</h2><p>使用 Jersey 服务器实现上传，使用 HTTP 请求实现下载<br>在 pom.xml 中添加 Jersey 相关依赖</p>
<dependency>
    <groupId>com.sun.jersey</groupId>
    <artifactId>jersey-client</artifactId>
    <version>1.18.1</version>
</dependency>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.sun.jersey.api.client.Client;</span><br><span class="line">import com.sun.jersey.api.client.ClientHandlerException;</span><br><span class="line">import com.sun.jersey.api.client.UniformInterfaceException;</span><br><span class="line">import com.sun.jersey.api.client.WebResource;</span><br><span class="line">import org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line">import org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.HttpURLConnection;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">public class FileUtils &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 加密&#x2F;解密文件的密钥</span><br><span class="line">    public static final int CRYPTO_SECRET_KEY &#x3D; 0x99;</span><br><span class="line"></span><br><span class="line">    public static int FILE_DATA &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 加密&#x2F;解密 文件</span><br><span class="line">     * @param srcFile 原文件</span><br><span class="line">     * @param encFile 加密&#x2F;解密后的文件</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void cryptoFile(File srcFile, File encFile) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        InputStream inputStream &#x3D; new FileInputStream(srcFile);</span><br><span class="line">        OutputStream outputStream &#x3D; new FileOutputStream(encFile);</span><br><span class="line">        while ((FILE_DATA &#x3D; inputStream.read()) &gt; -1) &#123;</span><br><span class="line">            outputStream.write(FILE_DATA ^ CRYPTO_SECRET_KEY);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * MultipartFile 生成临时文件</span><br><span class="line">     * @param multipartFile</span><br><span class="line">     * @param tempFilePath 临时文件路径</span><br><span class="line">     * @return File 临时文件</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static File multipartFileToFile(MultipartFile multipartFile, String tempFilePath) &#123;</span><br><span class="line"></span><br><span class="line">        File file &#x3D; new File(tempFilePath);</span><br><span class="line">        &#x2F;&#x2F; 获取文件原名</span><br><span class="line">        String originalFilename &#x3D; multipartFile.getOriginalFilename();</span><br><span class="line">        &#x2F;&#x2F; 获取文件后缀</span><br><span class="line">        String suffix &#x3D; originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span><br><span class="line">        if (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 创建临时文件</span><br><span class="line">        File tempFile &#x3D; new File(tempFilePath + &quot;\\&quot; + UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + suffix);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!tempFile.exists()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 写入临时文件</span><br><span class="line">                multipartFile.transferTo(tempFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return tempFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 上传文件</span><br><span class="line">     * @param fileServerPath    文件服务器地址</span><br><span class="line">     * @param folderPath    存放的文件夹路径（比如存放在文件服务器的 upload 文件夹下，即 ”&#x2F;upload“）</span><br><span class="line">     * @param uploadFile    需要上传的文件</span><br><span class="line">     * @param isCrypto    是否加密</span><br><span class="line">     * @return String    文件上传后的全路径</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String uploadByJersey(String fileServerPath, String folderPath, File uploadFile, boolean isCrypto) &#123;</span><br><span class="line"></span><br><span class="line">        String suffix &#x3D; uploadFile.getName().substring(uploadFile.getName().lastIndexOf(&quot;.&quot;));</span><br><span class="line">        String randomFileName &#x3D; UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + suffix;</span><br><span class="line">        String fullPath &#x3D; fileServerPath + folderPath + &quot;&#x2F;&quot; + randomFileName;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isCrypto) &#123;</span><br><span class="line">                &#x2F;&#x2F; 创建加密文件</span><br><span class="line">                File cryptoFile &#x3D; new File(uploadFile.getPath().substring(0, uploadFile.getPath().lastIndexOf(&quot;.&quot;)) + &quot;crypto&quot; + uploadFile.getPath().substring(uploadFile.getPath().lastIndexOf(&quot;.&quot;)));</span><br><span class="line">                &#x2F;&#x2F; 执行加密</span><br><span class="line">                cryptoFile(uploadFile, cryptoFile);</span><br><span class="line">                &#x2F;&#x2F; 保存加密后的文件</span><br><span class="line">                uploadFile &#x3D; cryptoFile;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 创建 Jersey 服务器</span><br><span class="line">            Client client &#x3D; Client.create();</span><br><span class="line">            WebResource wr &#x3D; client.resource(fullPath);</span><br><span class="line">            &#x2F;&#x2F; 上传文件</span><br><span class="line">            wr.put(String.class, fileToByte(uploadFile));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return fullPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 下载文件</span><br><span class="line">     * @param url   文件路径</span><br><span class="line">     * @param filePath  文件保存路径</span><br><span class="line">     * @param fileName    文件名称（包含文件后缀）</span><br><span class="line">     * @param isCrypto  是否解密</span><br><span class="line">     * @return File</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static File downloadByURL(String url, String filePath, String fileName, boolean isCrypto) &#123;</span><br><span class="line"></span><br><span class="line">        File file &#x3D; new File(filePath);</span><br><span class="line">        if (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fileOut;</span><br><span class="line">        HttpURLConnection httpURLConnection;</span><br><span class="line">        InputStream inputStream;</span><br><span class="line">        try &#123;</span><br><span class="line">            URL httpUrl &#x3D; new URL(url);</span><br><span class="line">            httpURLConnection &#x3D; (HttpURLConnection) httpUrl.openConnection();</span><br><span class="line">            httpURLConnection.setDoInput(true);</span><br><span class="line">            httpURLConnection.setDoOutput(true);</span><br><span class="line">            httpURLConnection.setUseCaches(false);</span><br><span class="line">            httpURLConnection.connect();</span><br><span class="line">            inputStream &#x3D; httpURLConnection.getInputStream();</span><br><span class="line">            BufferedInputStream bufferedInputStream &#x3D; new BufferedInputStream(inputStream);</span><br><span class="line">            if (!filePath.endsWith(&quot;\\&quot;)) &#123;</span><br><span class="line">                filePath +&#x3D; &quot;\\&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            file &#x3D; new File(filePath + fileName);</span><br><span class="line">            fileOut &#x3D; new FileOutputStream(file);</span><br><span class="line">            BufferedOutputStream bufferedOutputStream &#x3D; new BufferedOutputStream(fileOut);</span><br><span class="line">            byte[] bytes &#x3D; new byte[4096];</span><br><span class="line">            int length &#x3D; bufferedInputStream.read(bytes);</span><br><span class="line">            &#x2F;&#x2F;保存文件</span><br><span class="line">            while (length !&#x3D; -1) &#123;</span><br><span class="line">                bufferedOutputStream.write(bytes, 0, length);</span><br><span class="line">                length &#x3D; bufferedInputStream.read(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedOutputStream.close();</span><br><span class="line">            bufferedInputStream.close();</span><br><span class="line">            httpURLConnection.disconnect();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isCrypto) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 创建解密文件</span><br><span class="line">                File cryptoFile &#x3D; new File(((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest().getServletContext().getRealPath(&quot;&#x2F;&quot;) +  &quot;\\temp\\&quot; + UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + file.getName().substring(file.getName().lastIndexOf(&quot;.&quot;)));</span><br><span class="line">                &#x2F;&#x2F; 执行解密</span><br><span class="line">                cryptoFile(file, cryptoFile);</span><br><span class="line">                &#x2F;&#x2F; 删除下载的原文件</span><br><span class="line">                file.delete();</span><br><span class="line">                &#x2F;&#x2F; 保存解密后的文件</span><br><span class="line">                file &#x3D; cryptoFile;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除文件服务器上的文件</span><br><span class="line">     * @param url 文件路径</span><br><span class="line">     * @return boolean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean deleteByJersey(String url) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Client client &#x3D; new Client();</span><br><span class="line">            WebResource webResource &#x3D; client.resource(url);</span><br><span class="line">            webResource.delete();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (UniformInterfaceException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClientHandlerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * File转Bytes</span><br><span class="line">     * @param file</span><br><span class="line">     * @return byte[]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static byte[] fileToByte(File file) &#123;</span><br><span class="line"></span><br><span class="line">        byte[] buffer &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileInputStream fileInputStream &#x3D; new FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">            byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">            int n;</span><br><span class="line">            while ((n &#x3D; fileInputStream.read(bytes)) !&#x3D; -1) &#123;</span><br><span class="line">                byteArrayOutputStream.write(bytes, 0, n);</span><br><span class="line">            &#125;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            byteArrayOutputStream.close();</span><br><span class="line">            buffer &#x3D; byteArrayOutputStream.toByteArray();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试上传"><a href="#测试上传" class="headerlink" title="测试上传"></a>测试上传</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param multipartFile 上传文件</span><br><span class="line"> * @param isCrypto 是否加密文件</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public String upload(MultipartFile multipartFile, boolean isCrypto) &#123;</span><br><span class="line"></span><br><span class="line">    HttpServletRequest request &#x3D; ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">    &#x2F;&#x2F; 生成临时文件</span><br><span class="line">    File tempFile &#x3D; FileUtil.multipartFileToFile(multipartFile, request.getServletContext().getRealPath(&quot;&#x2F;&quot;) + &quot;\\static\\temp&quot;);</span><br><span class="line">    &#x2F;&#x2F; 上传文件并返回文件路径</span><br><span class="line">    String uploadFilePath &#x3D; FileUtil.uploadByJersey(&quot;http:&#x2F;&#x2F;localhost:8080&quot;, &quot;&#x2F;upload&quot;, tempFile, isCrypto);</span><br><span class="line">    if (uploadFilePath !&#x3D; null) &#123;</span><br><span class="line">        return &quot;上传成功&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return &quot;上传失败&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>encrypt</tag>
        <tag>decrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解校验枚举值</title>
    <url>/2022/05/16/Java-%E6%B3%A8%E8%A7%A3%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="hibernate的两种校验校验模式"><a href="#hibernate的两种校验校验模式" class="headerlink" title="hibernate的两种校验校验模式"></a>hibernate的两种校验校验模式</h2><p>细心的读者肯定发现了：上面例子中一次性返回了所有验证不通过的集合，通常按顺序验证到第一个字段不符合验证要求时，就可以直接拒绝请求了。Hibernate Validator有以下两种验证模式：</p>
<ol>
<li>普通模式（默认模式）<br>　　普通模式(会校验完所有的属性，然后返回所有的验证失败信息)</li>
<li>failFast(快速失败返回)模式<br>　　快速失败返回模式(只要有一个验证失败，则返回)</li>
</ol>
<p>两种验证模式配置方式：<a href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-provider-specific-settings" target="_blank" rel="noopener">参考官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;failFast取值：true  快速失败返回模式    false 普通模式 </span><br><span class="line">ValidatorFactory validatorFactory &#x3D; Validation.byProvider( HibernateValidator.class )</span><br><span class="line">        .configure()</span><br><span class="line">        .failFast( true )</span><br><span class="line">        .buildValidatorFactory();</span><br><span class="line">Validator validator &#x3D; validatorFactory.getValidator();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;hibernate.validator.fail_fast：true  快速失败返回模式    false 普通模式</span><br><span class="line">ValidatorFactory validatorFactory &#x3D; Validation.byProvider( HibernateValidator.class )</span><br><span class="line">        .configure()</span><br><span class="line">        .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )</span><br><span class="line">        .buildValidatorFactory();</span><br><span class="line">Validator validator &#x3D; validatorFactory.getValidator();</span><br></pre></td></tr></table></figure>
<h3 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h3><p>配置hibernate Validator为快速失败返回模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ValidatorConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Validator validator()&#123;</span><br><span class="line">        ValidatorFactory validatorFactory &#x3D; Validation.byProvider( HibernateValidator.class )</span><br><span class="line">                .configure()</span><br><span class="line">                .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )</span><br><span class="line">                .buildValidatorFactory();</span><br><span class="line">        Validator validator &#x3D; validatorFactory.getValidator();</span><br><span class="line"></span><br><span class="line">        return validator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3种使用校验方式"><a href="#3种使用校验方式" class="headerlink" title="3种使用校验方式"></a>3种使用校验方式</h2><h3 id="请求参数校验-RequestBody-Valid"><a href="#请求参数校验-RequestBody-Valid" class="headerlink" title="请求参数校验@RequestBody @Valid"></a>请求参数校验@RequestBody @Valid</h3><p>如demo里示例的，验证请求参数时，在@RequestBody DemoModel demo之间加注解 @Valid，然后后面加BindindResult即可；多个参数的，可以加多个@Valid和BindingResult，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test()(@RequestBody @Valid DemoModel demo, BindingResult result)</span><br><span class="line">public void test()(@RequestBody @Valid DemoModel demo, BindingResult result,@RequestBody @Valid DemoModel demo2, BindingResult result2)</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;demo2&quot;)</span><br><span class="line">public void demo2(@RequestBody @Valid DemoModel demo, BindingResult result)&#123;</span><br><span class="line">    if(result.hasErrors())&#123;</span><br><span class="line">        for (ObjectError error : result.getAllErrors()) &#123;</span><br><span class="line">            System.out.println(error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求参数校验-RequestParam-Validated"><a href="#请求参数校验-RequestParam-Validated" class="headerlink" title="请求参数校验@RequestParam @Validated"></a>请求参数校验@RequestParam @Validated</h3><p><font color = 'red'>使用校验bean的方式，没有办法校验RequestParam的内容，一般在处理Get请求(或参数比较少)的时候</font><br><font color = 'red'>使用@Valid注解，对RequestParam对应的参数进行注解，是无效的，需要使用@Validated注解来使得验证生效。</font></p>
<ol>
<li><p>此时需要使用MethodValidationPostProcessor 的Bean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public MethodValidationPostProcessor methodValidationPostProcessor() &#123;</span><br><span class="line">　　　　  &#x2F;**默认是普通模式，会返回所有的验证不通过信息集合*&#x2F;</span><br><span class="line">        return new MethodValidationPostProcessor();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>或 可对MethodValidationPostProcessor 进行设置Validator（因为此时不是用的Validator进行验证，Validator的配置不起作用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MethodValidationPostProcessor methodValidationPostProcessor() &#123;</span><br><span class="line">    MethodValidationPostProcessor postProcessor &#x3D; new MethodValidationPostProcessor();</span><br><span class="line">　　　　　&#x2F;**设置validator模式为快速失败返回*&#x2F;</span><br><span class="line">    postProcessor.setValidator(validator());</span><br><span class="line">    return postProcessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Validator validator()&#123;</span><br><span class="line">    ValidatorFactory validatorFactory &#x3D; Validation.byProvider( HibernateValidator.class )</span><br><span class="line">            .configure()</span><br><span class="line">            .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )</span><br><span class="line">            .buildValidatorFactory();</span><br><span class="line">    Validator validator &#x3D; validatorFactory.getValidator();</span><br><span class="line"></span><br><span class="line">    return validator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法所在的Controller上加注解@Validated</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;validation&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@Validated</span><br><span class="line">public class ValidationController &#123;</span><br><span class="line">    &#x2F;**如果只有少数对象，直接把参数写到Controller层，然后在Controller层进行验证就可以了。*&#x2F;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;demo3&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public void demo3(@Range(min &#x3D; 1, max &#x3D; 9, message &#x3D; &quot;年级只能从1-9&quot;)</span><br><span class="line">                      @RequestParam(name &#x3D; &quot;grade&quot;, required &#x3D; true)</span><br><span class="line">                      int grade,</span><br><span class="line">                      @Min(value &#x3D; 1, message &#x3D; &quot;班级最小只能1&quot;)</span><br><span class="line">                      @Max(value &#x3D; 99, message &#x3D; &quot;班级最大只能99&quot;)</span><br><span class="line">                      @RequestParam(name &#x3D; &quot;classroom&quot;, required &#x3D; true)</span><br><span class="line">                      int classroom) &#123;</span><br><span class="line">        System.out.println(grade + &quot;,&quot; + classroom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回验证信息提示<br>可以看到：验证不通过时，抛出了ConstraintViolationException异常，使用同一捕获异常处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">@Component</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public String handle(ValidationException exception) &#123;</span><br><span class="line">        if(exception instanceof ConstraintViolationException)&#123;</span><br><span class="line">            ConstraintViolationException exs &#x3D; (ConstraintViolationException) exception;</span><br><span class="line"></span><br><span class="line">            Set&lt;ConstraintViolation&lt;?&gt;&gt; violations &#x3D; exs.getConstraintViolations();</span><br><span class="line">            for (ConstraintViolation&lt;?&gt; item : violations) &#123;</span><br><span class="line">　　　　　　　　　　&#x2F;**打印验证不通过的信息*&#x2F;</span><br><span class="line">                System.out.println(item.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;bad request, &quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>验证<br>浏览器服务请求地址：<a href="http://localhost:8080/validation/demo3?grade=18&amp;classroom=888" target="_blank" rel="noopener">http://localhost:8080/validation/demo3?grade=18&amp;classroom=888</a><br>没有配置快速失败返回的MethodValidationPostProcessor 时输出信息如下：<br>年级只能从1-9<br>班级最大只能99</p>
</li>
</ol>
<p>配置了快速失败返回的MethodValidationPostProcessor 时输出信息如下：<br>年级只能从1-9</p>
<h3 id="model校验"><a href="#model校验" class="headerlink" title="model校验"></a>model校验</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    @Length(min &#x3D; 5, max &#x3D; 17, message &#x3D; &quot;length长度在[5,17]之间&quot;)</span><br><span class="line">    private String length;</span><br><span class="line"></span><br><span class="line">    &#x2F;**@Size不能验证Integer，适用于String, Collection, Map and arrays*&#x2F;</span><br><span class="line">    @Size(min &#x3D; 1, max &#x3D; 3, message &#x3D; &quot;size在[1,3]之间&quot;)</span><br><span class="line">    private String age;</span><br><span class="line"></span><br><span class="line">    @Range(min &#x3D; 150, max &#x3D; 250, message &#x3D; &quot;range在[150,250]之间&quot;)</span><br><span class="line">    private int high;</span><br><span class="line"></span><br><span class="line">    @Size(min &#x3D; 3,max &#x3D; 5,message &#x3D; &quot;list的Size在[3,5]&quot;)</span><br><span class="line">    private List&lt;String&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证model，以下全部验证通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   private Validator validator;</span><br><span class="line">   </span><br><span class="line">   @RequestMapping(&quot;&#x2F;demo3&quot;)</span><br><span class="line">   public void demo3()&#123;</span><br><span class="line">       Demo2 demo2 &#x3D; new Demo2();</span><br><span class="line">       demo2.setAge(&quot;111&quot;);</span><br><span class="line">       demo2.setHigh(150);</span><br><span class="line">       demo2.setLength(&quot;ABCDE&quot;);</span><br><span class="line">       demo2.setList(new ArrayList&lt;String&gt;()&#123;&#123;add(&quot;111&quot;);add(&quot;222&quot;);add(&quot;333&quot;);&#125;&#125;);</span><br><span class="line">       Set&lt;ConstraintViolation&lt;Demo2&gt;&gt; violationSet &#x3D; validator.validate(demo2);</span><br><span class="line">       for (ConstraintViolation&lt;Demo2&gt; model : violationSet) &#123;</span><br><span class="line">           System.out.println(model.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象级联校验"><a href="#对象级联校验" class="headerlink" title="对象级联校验"></a>对象级联校验</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    @Size(min &#x3D; 3,max &#x3D; 5,message &#x3D; &quot;list的Size在[3,5]&quot;)</span><br><span class="line">    private List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    @Valid</span><br><span class="line">    private Demo3 demo3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    @Length(min &#x3D; 5, max &#x3D; 17, message &#x3D; &quot;length长度在[5,17]之间&quot;)</span><br><span class="line">    private String extField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>级联校验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**前面配置了快速失败返回的Bean*&#x2F;</span><br><span class="line">@Autowired</span><br><span class="line">private Validator validator;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;demo3&quot;)</span><br><span class="line">public void demo3()&#123;</span><br><span class="line">    Demo2 demo2 &#x3D; new Demo2();</span><br><span class="line">    demo2.setList(new ArrayList&lt;String&gt;()&#123;&#123;add(&quot;111&quot;);add(&quot;222&quot;);add(&quot;333&quot;);&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    Demo3 demo3 &#x3D; new Demo3();</span><br><span class="line">    &#x2F;&#x2F;可以校验Demo3的extField字段。</span><br><span class="line">    demo3.setExtField(&quot;22&quot;);</span><br><span class="line">    demo2.setDemo3(demo3);</span><br><span class="line">    Set&lt;ConstraintViolation&lt;Demo2&gt;&gt; violationSet &#x3D; validator.validate(demo2);</span><br><span class="line">    for (ConstraintViolation&lt;Demo2&gt; model : violationSet) &#123;</span><br><span class="line">        System.out.println(model.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p><font color ='red'>结论：分组顺序校验时，按指定的分组先后顺序进行验证，前面的验证不通过，后面的分组就不行验证。</font><br>有这样一种场景，新增用户信息的时候，不需要验证userId（因为系统生成）；修改的时候需要验证userId，这时候可用用户到validator的分组验证功能。<br>设置validator为普通验证模式（”hibernate.validator.fail_fast”, “false”），用到的验证GroupA、GroupB和model：</p>
<ol>
<li><p>校验接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface GroupA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface GroupB &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验请求对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person &#123;</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Range(min &#x3D; 1,max &#x3D; Integer.MAX_VALUE,message &#x3D; &quot;必须大于0&quot;,groups &#x3D; &#123;GroupA.class&#125;)</span><br><span class="line">    &#x2F;**用户id*&#x2F;</span><br><span class="line">    private Integer userId;</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(min &#x3D; 4,max &#x3D; 20,message &#x3D; &quot;必须在[4,20]&quot;,groups &#x3D; &#123;GroupB.class&#125;)</span><br><span class="line">    &#x2F;**用户名*&#x2F;</span><br><span class="line">    private String userName;</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Range(min &#x3D; 0,max &#x3D; 100,message &#x3D; &quot;年龄必须在[0,100]&quot;,groups&#x3D;&#123;Default.class&#125;)</span><br><span class="line">    &#x2F;**年龄*&#x2F;</span><br><span class="line">    private Integer age;</span><br><span class="line">    @Range(min &#x3D; 0,max &#x3D; 2,message &#x3D; &quot;性别必须在[0,2]&quot;,groups &#x3D; &#123;GroupB.class&#125;)</span><br><span class="line">    &#x2F;**性别 0：未知；1：男；2：女*&#x2F;</span><br><span class="line">    private Integer sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上Person所示，3个分组分别验证字段如下：</p>
</li>
</ol>
<ul>
<li>GroupA校验字段userId</li>
<li>GroupB校验字段userName、sex</li>
<li>Default校验字段age(Default使Validator自带的默认分组)</li>
</ul>
<ol start="3">
<li>校验<br>只验证GroupA和GroupB的分组，以下示例代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;demo5&quot;)</span><br><span class="line">public void demo5()&#123;</span><br><span class="line">    Person p &#x3D; new Person();</span><br><span class="line">    &#x2F;**GroupA验证不通过*&#x2F;</span><br><span class="line">    p.setUserId(-12);</span><br><span class="line">    &#x2F;**GroupA验证通过*&#x2F;</span><br><span class="line">    &#x2F;&#x2F;p.setUserId(12);</span><br><span class="line">    p.setUserName(&quot;a&quot;);</span><br><span class="line">    p.setAge(110);</span><br><span class="line">    p.setSex(5);</span><br><span class="line">    Set&lt;ConstraintViolation&lt;Person&gt;&gt; validate &#x3D; validator.validate(p, GroupA.class, GroupB.class);</span><br><span class="line">    for (ConstraintViolation&lt;Person&gt; item : validate) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;demo6&quot;)</span><br><span class="line">public void demo6(@Validated(&#123;GroupA.class, GroupB.class&#125;) Person p, BindingResult result)&#123;</span><br><span class="line">    if(result.hasErrors())&#123;</span><br><span class="line">        List&lt;ObjectError&gt; allErrors &#x3D; result.getAllErrors();</span><br><span class="line">        for (ObjectError error : allErrors) &#123;</span><br><span class="line">            System.out.println(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>GroupA、GroupB、Default都验证不通过的情况：<br>验证信息如下所示：</p>
<p>ConstraintViolationImpl{interpolatedMessage=’必须在[4,20]’, propertyPath=userName, rootBeanClass=class validator.demo.project.model.Person, messageTemplate=’必须在[4,20]’}<br>ConstraintViolationImpl{interpolatedMessage=’必须大于0’, propertyPath=userId, rootBeanClass=class validator.demo.project.model.Person, messageTemplate=’必须大于0’}<br>ConstraintViolationImpl{interpolatedMessage=’性别必须在[0,2]’, propertyPath=sex, rootBeanClass=class validator.demo.project.model.Person, messageTemplate=’性别必须在[0,2]’}</p>
<p>GroupA验证通过、GroupB、Default验证不通过的情况：<br>验证信息如下所示：</p>
<p>ConstraintViolationImpl{interpolatedMessage=’必须在[4,20]’, propertyPath=userName, rootBeanClass=class validator.demo.project.model.Person, messageTemplate=’必须在[4,20]’}<br>ConstraintViolationImpl{interpolatedMessage=’性别必须在[0,2]’, propertyPath=sex, rootBeanClass=class validator.demo.project.model.Person, messageTemplate=’性别必须在[0,2]’}</p>
<ol>
<li>组序列<br>指定组的验证顺序，前面组验证不通过，后面组不验证<br>// GroupA &gt; GroupB &gt; Default<br>@GroupSequence({GroupA.class, GroupB.class, Default.class})<br>public interface GroupOrder {<br>}</li>
</ol>
<p>测试demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;demo7&quot;)</span><br><span class="line">public void demo7()&#123;</span><br><span class="line">    Person p &#x3D; new Person();</span><br><span class="line">    &#x2F;**GroupA验证不通过*&#x2F;</span><br><span class="line">    &#x2F;&#x2F;p.setUserId(-12);</span><br><span class="line">    &#x2F;**GroupA验证通过*&#x2F;</span><br><span class="line">    p.setUserId(12);</span><br><span class="line">    p.setUserName(&quot;a&quot;);</span><br><span class="line">    p.setAge(110);</span><br><span class="line">    p.setSex(5);</span><br><span class="line">    Set&lt;ConstraintViolation&lt;Person&gt;&gt; validate &#x3D; validator.validate(p, GroupOrder.class);</span><br><span class="line">    for (ConstraintViolation&lt;Person&gt; item : validate) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;demo8&quot;)</span><br><span class="line">public void demo8(@Validated(&#123;GroupOrder.class&#125;) Person p, BindingResult result)&#123;</span><br><span class="line">    if(result.hasErrors())&#123;</span><br><span class="line">        List&lt;ObjectError&gt; allErrors &#x3D; result.getAllErrors();</span><br><span class="line">        for (ObjectError error : allErrors) &#123;</span><br><span class="line">            System.out.println(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GroupA、GroupB、Default都验证不通过的情况：<br>验证信息如下所示：</p>
<p>ConstraintViolationImpl{interpolatedMessage=’必须大于0’, propertyPath=userId, rootBeanClass=class validator.demo.project.model.Person, messageTemplate=’必须大于0’}</p>
<p>GroupA验证通过、GroupB、Default验证不通过的情况：<br>验证信息如下所示：</p>
<p>ConstraintViolationImpl{interpolatedMessage=’必须在[4,20]’, propertyPath=userName, rootBeanClass=class validator.demo.project.model.Person, messageTemplate=’必须在[4,20]’}<br>ConstraintViolationImpl{interpolatedMessage=’性别必须在[0,2]’, propertyPath=sex, rootBeanClass=class validator.demo.project.model.Person, messageTemplate=’性别必须在[0,2]’}</p>
<p><font color ='red'>结论：分组顺序校验时，按指定的分组先后顺序进行验证，前面的验证不通过，后面的分组就不行验证</font></p>
<h3 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h3><p>一般情况，自定义验证可以解决很多问题。但也有无法满足情况的时候，此时，我们可以实现validator的接口，自定义自己需要的验证器。</p>
<p>如下所示，实现了一个自定义的大小写验证器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Constraint(validatedBy&#x3D;SpecialFieldValidator.class)</span><br><span class="line">public @interface SpecialField &#123;</span><br><span class="line"></span><br><span class="line">    String message() default &quot;不能包含特殊字符&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SpecialFieldValidator implements ConstraintValidator&lt;SpecialField, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 特殊字符的正则表达式</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String reg &#x3D; &quot;[ _&#96;~!@#$%^&amp;*()+&#x3D;|&#123;&#125;&#39;:;&#39;,\\\\[\\\\].&lt;&gt;&#x2F;?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。，、？]|\\n|\\r|\\t&quot;;</span><br><span class="line">    private Pattern pt &#x3D; Pattern.compile(reg);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(SpecialField specialField) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isValid(String value, ConstraintValidatorContext arg1) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Matcher m &#x3D; pt.matcher(value);</span><br><span class="line">        if (m.find()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum CaseMode &#123;</span><br><span class="line">    UPPER,</span><br><span class="line">    LOWER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Target( &#123; ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE &#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Constraint(validatedBy &#x3D; CheckCaseValidator.class)</span><br><span class="line">@Documented</span><br><span class="line">public @interface CheckCase &#123;</span><br><span class="line">    String message() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    CaseMode value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; &#123;</span><br><span class="line">    private CaseMode caseMode;</span><br><span class="line">    public void initialize(CheckCase checkCase) &#123;</span><br><span class="line">        this.caseMode &#x3D; checkCase.value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) &#123;</span><br><span class="line">        if (s &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (caseMode &#x3D;&#x3D; CaseMode.UPPER) &#123;</span><br><span class="line">            return s.equals(s.toUpperCase());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return s.equals(s.toLowerCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public class Demo&#123;</span><br><span class="line">        @CheckCase(value &#x3D; CaseMode.LOWER,message &#x3D; &quot;userName必须是小写&quot;)</span><br><span class="line">        private String userName;</span><br><span class="line"></span><br><span class="line">        public String getUserName() &#123;</span><br><span class="line">            return userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setUserName(String userName) &#123;</span><br><span class="line">            this.userName &#x3D; userName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Validator validator()&#123;</span><br><span class="line">        ValidatorFactory validatorFactory &#x3D; Validation.byProvider( HibernateValidator.class )</span><br><span class="line">                .configure()</span><br><span class="line">                .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )</span><br><span class="line">                .buildValidatorFactory();</span><br><span class="line">        Validator validator &#x3D; validatorFactory.getValidator();</span><br><span class="line"></span><br><span class="line">        return validator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;demo4&quot;)</span><br><span class="line">    public void demo4()&#123;</span><br><span class="line">        Demo demo &#x3D; new Demo();</span><br><span class="line">        demo.setUserName(&quot;userName&quot;);</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Demo&gt;&gt; validate &#x3D; validator.validate(demo);</span><br><span class="line">        for (ConstraintViolation&lt;Demo&gt; dem : validate) &#123;</span><br><span class="line">            System.out.println(dem.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：userName必须是小写</p>
<h2 id="常见的注解"><a href="#常见的注解" class="headerlink" title="常见的注解"></a>常见的注解</h2><p>  Bean Validation 中内置的 constraint<br>@Null   被注释的元素必须为 null<br>@NotNull    被注释的元素必须不为 null<br>@AssertTrue     被注释的元素必须为 true<br>@AssertFalse    被注释的元素必须为 false<br>@Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@Size(max=, min=)   被注释的元素的大小必须在指定的范围内<br>@Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内<br>@Past   被注释的元素必须是一个过去的日期<br>@Future     被注释的元素必须是一个将来的日期<br>@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式<br>Hibernate Validator 附加的 constraint<br>@NotBlank(message =)   验证字符串非null，且长度必须大于0<br>@Email  被注释的元素必须是电子邮箱地址<br>@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内<br>@NotEmpty   被注释的字符串的必须非空<br>@Range(min=,max=,message=)  被注释的元素必须在合适的范围内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;大于0.01，不包含0.01</span><br><span class="line">@NotNull</span><br><span class="line">@DecimalMin(value &#x3D; &quot;0.01&quot;, inclusive &#x3D; false)</span><br><span class="line">private Integer greaterThan;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;大于等于0.01</span><br><span class="line">@NotNull</span><br><span class="line">@DecimalMin(value &#x3D; &quot;0.01&quot;, inclusive &#x3D; true)</span><br><span class="line">private BigDecimal greatOrEqualThan;</span><br><span class="line"></span><br><span class="line">@Length(min &#x3D; 1, max &#x3D; 20, message &#x3D; &quot;message不能为空&quot;)</span><br><span class="line">&#x2F;&#x2F;不能将Length错用成Range</span><br><span class="line">&#x2F;&#x2F;@Range(min &#x3D; 1, max &#x3D; 20, message &#x3D; &quot;message不能为空&quot;)</span><br><span class="line">private String message;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解校验</tag>
        <tag>Hibernate Validator</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 注解原理</title>
    <url>/2021/05/01/Java-%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><ul>
<li>日常开发中新建Java类，我们使用class、interface比较多，而注解和它们一样，也是一种类的类型，他是用的修饰符为 @interface<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;格式</span><br><span class="line">@元注解或其他自定义注解</span><br><span class="line">public @interface 注解名 &#123;</span><br><span class="line">    &#x2F;&#x2F;以属性理解</span><br><span class="line">   修饰符(public或default) 属性值类型  属性名()  default 默认值;</span><br><span class="line">   &#x2F;&#x2F;以方法理解</span><br><span class="line">   修饰符(public或default) 返回值类型  方法名()  default 默认返回值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public @interface MyTestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MyTestAnnotation</span><br><span class="line">public class test &#123;</span><br><span class="line">   @MyTestAnnotation</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上我们只是了解了注解的写法，但是我们定义的注解中还没写任何代码，现在这个注解毫无意义，要如何使注解工作呢？接下来我们接着了解元注解。</li>
</ul>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解顾名思义我们可以理解为注解的注解，它是作用在注解中，方便我们使用注解实现想要的功能。元注解分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyTestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retention英文意思有保留、保持的意思，它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）。在@Retention注解中使用枚举RetentionPolicy来表示注解保留时期</p>
<ul>
<li>@Retention(RetentionPolicy.SOURCE)，注解仅存在于源码中，在class字节码文件中不包含</li>
<li>@Retention(RetentionPolicy.CLASS)， 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得</li>
<li>@Retention(RetentionPolicy.RUNTIME)， 注解会在class字节码文件中存在，在运行时可以通过反射获取到<br>如果我们是自定义注解，则通过前面分析，我们自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 @Retention(RetentionPolicy.RUNTIME)</li>
</ul>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface MyTestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Target的英文意思是目标，这也很容易理解，使用@Target元注解表示我们的注解作用的范围就比较具体了，可以是类，方法，方法参数变量等，同样也是通过枚举类ElementType表达作用类型</p>
<ul>
<li>@Target(ElementType.TYPE) 作用接口、类、枚举、注解</li>
<li>@Target(ElementType.FIELD) 作用属性字段、枚举的常量</li>
<li>@Target(ElementType.METHOD) 作用方法</li>
<li>@Target(ElementType.PARAMETER) 作用方法参数</li>
<li>@Target(ElementType.CONSTRUCTOR) 作用构造函数</li>
<li>@Target(ElementType.LOCAL_VARIABLE)作用局部变量</li>
<li>@Target(ElementType.ANNOTATION_TYPE)作用于注解（@Retention注解中就使用该属性）</li>
<li>@Target(ElementType.PACKAGE) 作用于包</li>
<li>@Target(ElementType.TYPE_PARAMETER) 作用于类型泛型，即泛型方法、泛型类、泛型接口 （jdk1.8加入）</li>
<li>@Target(ElementType.TYPE_USE) 类型使用.可以用于标注任意类型除了 class （jdk1.8加入）<br>一般比较常用的是ElementType.TYPE类型</li>
</ul>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>Document的英文意思是文档。它的作用是能够将注解中的元素包含到 Javadoc 中去</p>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>Inherited的英文意思是继承，但是这个继承和我们平时理解的继承大同小异，一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。<br>下面我们来看个@Inherited注解例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**自定义注解*&#x2F;</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface MyTestAnnotation &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**父类标注自定义注解*&#x2F;</span><br><span class="line">@MyTestAnnotation</span><br><span class="line">public class Father &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**子类*&#x2F;</span><br><span class="line">public class Son extends Father &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**测试子类获取父类自定义注解*&#x2F;</span><br><span class="line">public class test &#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;获取Son的class对象</span><br><span class="line">       Class&lt;Son&gt; sonClass &#x3D; Son.class;</span><br><span class="line">      &#x2F;&#x2F; 获取Son类上的注解MyTestAnnotation可以执行成功</span><br><span class="line">      MyTestAnnotation annotation &#x3D; sonClass.getAnnotation(MyTestAnnotation.class);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><p>Repeatable的英文意思是可重复的。顾名思义说明被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。<br>下面我们看一个人玩游戏的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**一个人喜欢玩游戏，他喜欢玩英雄联盟，绝地求生，极品飞车，尘埃4等，则我们需要定义一个人的注解，他属性代表喜欢玩游戏集合，一个游戏注解，游戏属性代表游戏名称*&#x2F;</span><br><span class="line">&#x2F;**玩家注解*&#x2F;</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface People &#123;</span><br><span class="line">    Game[] value() ;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**游戏注解*&#x2F;</span><br><span class="line">@Repeatable(People.class)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Game &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**玩游戏类:Game注解有repeatable,所以下面可以重复修饰PlayGame类,意味着每一个Game带值注解作用一个Playgame类,产生不同对象*&#x2F;</span><br><span class="line">@Game(value &#x3D; &quot;LOL&quot;)</span><br><span class="line">@Game(value &#x3D; &quot;PUBG&quot;)</span><br><span class="line">@Game(value &#x3D; &quot;NFS&quot;)</span><br><span class="line">@Game(value &#x3D; &quot;Dirt4&quot;)</span><br><span class="line">public class PlayGame &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等价于5个不同对象</span><br><span class="line">@Game(value &#x3D; &quot;LOL&quot;)</span><br><span class="line">public class PlayGame &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Game(value &#x3D; &quot;PUBG&quot;)</span><br><span class="line">public class PlayGame &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Game(value &#x3D; &quot;NFS&quot;)</span><br><span class="line">public class PlayGame &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Game(value &#x3D; &quot;Dirt4&quot;)</span><br><span class="line">public class PlayGame &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的例子，你可能会有一个疑问，游戏注解中括号的变量是啥，其实这和游戏注解中定义的属性对应。接下来我们继续学习注解的属性。</p>
<h2 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h2><p>注解的本质就是一个Annotation接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**Annotation接口源码*&#x2F;</span><br><span class="line">public interface Annotation &#123;</span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line">    int hashCode();</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上源码，我们知道注解本身就是Annotation接口的子接口，也就是说注解中其实是可以有属性和方法，但是接口中的属性都是static final的，对于注解来说没什么意义，而我们定义接口的方法就相当于注解的属性，也就对应了前面说的为什么注解只有属性成员变量，其实他就是接口的方法，这就是为什么成员变量会有括号，不同于接口我们可以在注解的括号中给成员变量赋值。</p>
<h2 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h2><p><font color='red'>通过上一小节@Repeatable注解的例子，我们说到注解的属性。注解的属性其实和类中定义的变量有异曲同工之处，只是注解中的变量都是成员变量（属性），并且注解中是没有方法的，只有成员变量，属性变量名就在括号前，返回值就是括号中对应参数类型。相信这会你应该会对上面的例子有一个更深的认识。而@Repeatable注解中的变量则类型则是对应Annotation（接口）的泛型Class。</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**注解Repeatable源码*&#x2F;</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Repeatable &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Indicates the &lt;em&gt;containing annotation type&lt;&#x2F;em&gt; for the</span><br><span class="line">     * repeatable annotation type.</span><br><span class="line">     * @return the containing annotation type</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解属性类型"><a href="#注解属性类型" class="headerlink" title="注解属性类型"></a>注解属性类型</h3><p>注解属性类型可以有以下列出的类型<br>1.基本数据类型<br>2.String<br>3.枚举类型<br>4.注解类型<br>5.Class类型<br>6.以上类型的一维数组类型</p>
<h3 id="注解成员变量赋值"><a href="#注解成员变量赋值" class="headerlink" title="注解成员变量赋值"></a>注解成员变量赋值</h3><p>如果注解又多个属性，则可以在注解括号中用“，”号隔开分别给对应的属性赋值，如下例子，注解在父类中赋值属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface MyTestAnnotation &#123;</span><br><span class="line">    String name() default &quot;mao&quot;;</span><br><span class="line">    int age() default 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MyTestAnnotation(name &#x3D; &quot;father&quot;,age &#x3D; 50)</span><br><span class="line">public class Father &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取注解属性"><a href="#获取注解属性" class="headerlink" title="获取注解属性"></a>获取注解属性</h3><p>前面我们说了很多注解如何定义，放在哪，现在我们可以开始学习注解属性的提取了，这才是使用注解的关键，获取属性的值才是使用注解的目的。<br>如果获取注解属性，当然是反射啦，主要有三个基本的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**是否存在对应 Annotation 对象*&#x2F;</span><br><span class="line"> public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;</span><br><span class="line">       return GenericDeclaration.super.isAnnotationPresent(annotationClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**获取 Annotation 对象*&#x2F;</span><br><span class="line">   public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;</span><br><span class="line">       Objects.requireNonNull(annotationClass);</span><br><span class="line"></span><br><span class="line">       return (A) annotationData().annotations.get(annotationClass);</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;**获取所有 Annotation 对象数组*&#x2F;   </span><br><span class="line">public Annotation[] getAnnotations() &#123;</span><br><span class="line">       return AnnotationParser.toArray(annotationData().annotations);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面结合前面的例子，我们来获取一下注解属性，在获取之前我们自定义的注解必须使用元注解@Retention(RetentionPolicy.RUNTIME)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">   public static void main(String[] args) throws NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 获取类注解属性</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Class&lt;Father&gt; fatherClass &#x3D; Father.class;</span><br><span class="line">        boolean annotationPresent &#x3D; fatherClass.isAnnotationPresent(MyTestAnnotation.class);</span><br><span class="line">        if(annotationPresent)&#123;</span><br><span class="line">            MyTestAnnotation annotation &#x3D; fatherClass.getAnnotation(MyTestAnnotation.class);</span><br><span class="line">            System.out.println(annotation.name());</span><br><span class="line">            System.out.println(annotation.age());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 获取方法注解属性</span><br><span class="line">         *&#x2F;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field age &#x3D; fatherClass.getDeclaredField(&quot;age&quot;);</span><br><span class="line">            boolean annotationPresent1 &#x3D; age.isAnnotationPresent(Age.class);</span><br><span class="line">            if(annotationPresent1)&#123;</span><br><span class="line">                Age annotation &#x3D; age.getAnnotation(Age.class);</span><br><span class="line">                System.out.println(annotation.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Method play &#x3D; PlayGame.class.getDeclaredMethod(&quot;play&quot;);</span><br><span class="line">            if (play!&#x3D;null)&#123;</span><br><span class="line">                People annotation2 &#x3D; play.getAnnotation(People.class);</span><br><span class="line">                Game[] value &#x3D; annotation2.value();</span><br><span class="line">                for (Game game : value) &#123;</span><br><span class="line">                    System.out.println(game.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ul>
<li>提供信息给编译器： 编译器可以利用注解来检测出错误或者警告信息，打印出日志。</li>
<li>编译阶段时的处理： 软件工具可以用来利用注解信息来自动生成代码、文档或者做其它相应的自动处理。</li>
<li>运行时处理： 某些注解可以在程序运行的时候接受代码的提取，自动做相应的操作。</li>
<li>正如官方文档的那句话所说，注解能够提供元数据，转账例子中处理获取注解值的过程是我们开发者直接写的注解提取逻辑，处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。上面转账例子中的processAnnotationMoney方法就可以理解为APT工具类</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>注解原理</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解-Validator</title>
    <url>/2021/05/02/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%A0%A1%E9%AA%8C%E6%9E%9A%E4%B8%BE%E5%80%BC/</url>
    <content><![CDATA[<h2 id="校验框架"><a href="#校验框架" class="headerlink" title="校验框架"></a>校验框架</h2><p><a href="http://hibernate.org/validator/documentation/" target="_blank" rel="noopener">hibernate validator官方文档</a> 提供了一套比较完善、便捷的验证实现方式。<br>spring-boot-starter-web包里面有hibernate-validator包，不需要引用hibernate validator依赖</p>
<h2 id="自定义注解校验枚举值"><a href="#自定义注解校验枚举值" class="headerlink" title="自定义注解校验枚举值"></a>自定义注解校验枚举值</h2><h3 id="需求及方案"><a href="#需求及方案" class="headerlink" title="需求及方案"></a>需求及方案</h3><p>我们经常会有一个对象的属性值只能出现在一组常量中的校验需求，例如：用户性别字段gender只能等于MALE/FEMALE这两个其中一个值，用户账号的状态status只能等于：NORMAL/DISABLED/DELETED其中一个等等，那么我们怎么能更好的校验这个参数呢？</p>
<h3 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a>实现方案：</h3><p>上面提到的一组常量值，我们第一反应应该是定义一个枚举类，尽量不要放在一个统一的constants类下，这样当系统一旦庞大起来，常量是很难维护和查找的，所以前期代码也应该有一些规范性约束，这里我们约定一组常量值时使用枚举，并把该枚举类放在对应的类对象里(以上述所说的用户功能为例，我们应该把GenerEnum、UserStatusEnum枚举放在User.java下，方便查找),这里我们定义一个叫EnumValue.java的注解类，其下有两个主要参数一个是enumClass用于指定枚举类，enumMethod指定要校验的方法，下面我们看代码实现。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE &#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Constraint(validatedBy &#x3D; EnumValue.Validator.class)</span><br><span class="line">public @interface EnumValue &#123;</span><br><span class="line"> </span><br><span class="line">    String message() default &quot;&#123;custom.value.invalid&#125;&quot;;</span><br><span class="line">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Enum&lt;?&gt;&gt; enumClass();</span><br><span class="line">    String enumMethod();</span><br><span class="line"></span><br><span class="line">    class Validator implements ConstraintValidator&lt;EnumValue, Object&gt; &#123;</span><br><span class="line">        private Class&lt;? extends Enum&lt;?&gt;&gt; enumClass;</span><br><span class="line">        private String enumMethod;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void initialize(EnumValue enumValue) &#123;</span><br><span class="line">            enumMethod &#x3D; enumValue.enumMethod();</span><br><span class="line">            enumClass &#x3D; enumValue.enumClass();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean isValid(Object value, ConstraintValidatorContext constraintValidatorContext) &#123;</span><br><span class="line">            if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return Boolean.TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            if (enumClass &#x3D;&#x3D; null || enumMethod &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return Boolean.TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; valueClass &#x3D; value.getClass();</span><br><span class="line">            try &#123;</span><br><span class="line">                Method method &#x3D; enumClass.getMethod(enumMethod, valueClass);</span><br><span class="line">                if (!Boolean.TYPE.equals(method.getReturnType()) &amp;&amp; !Boolean.class.equals(method.getReturnType())) &#123;</span><br><span class="line">                    throw new RuntimeException(Strings.formatIfArgs(&quot;%s method return is not boolean type in the %s class&quot;, enumMethod, enumClass));</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                if(!Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                    throw new RuntimeException(Strings.formatIfArgs(&quot;%s method is not static method in the %s class&quot;, enumMethod, enumClass));</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                Boolean result &#x3D; (Boolean)method.invoke(null, value);</span><br><span class="line">                return result &#x3D;&#x3D; null ? false : result;</span><br><span class="line">            &#125; catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; catch (NoSuchMethodException | SecurityException e) &#123;</span><br><span class="line">                throw new RuntimeException(Strings.formatIfArgs(&quot;This %s(%s) method does not exist in the %s&quot;, enumMethod, valueClass, enumClass), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：自定义注解需要实现ConstraintValidator校验类，这里我们定义一个叫Validator的类来实现它，同时实现它下面的两个方法initialize、isValid，一个是初始化参数的方法，另一个就是校验逻辑的方法，本例子中我们将校验类定义在该注解内，用@Constraint(validatedBy = EnumValue.Validator.class)注解指定校验类，内部逻辑实现比较简单就是使用了静态类反射调用验证方法的方式。对于被校验的方法(EnumValue 的 enumMethod方法)我们要求，它必须是返回值类型为Boolean或boolean，并且必须是一个静态的方法，返回返回值为null时我们认为是校验不通过的，按false逻辑走。</p>
<h3 id="校验的目标对象类"><a href="#校验的目标对象类" class="headerlink" title="校验的目标对象类"></a>校验的目标对象类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    private static final long serialVersionUID &#x3D; 2594274431751408585L;</span><br><span class="line"> </span><br><span class="line">    private Long id;</span><br><span class="line"> </span><br><span class="line">    @NotBlank</span><br><span class="line">    private String pwd;</span><br><span class="line"> </span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(min&#x3D;1, max&#x3D;64)</span><br><span class="line">    private String nickname;</span><br><span class="line"> </span><br><span class="line">    private String img;</span><br><span class="line"> </span><br><span class="line">    @Pattern(regexp &#x3D; &quot;^1[3-9]\\d&#123;9&#125;$&quot;)</span><br><span class="line">    private String phone;</span><br><span class="line"> </span><br><span class="line">     @EnumValue(enumClass&#x3D;UserStatusEnum.class, enumMethod&#x3D;&quot;isValidName&quot;)</span><br><span class="line">    private String status;</span><br><span class="line"> </span><br><span class="line">    private Date latestLoginTime;</span><br><span class="line"> </span><br><span class="line">    private String latestLoginIp;</span><br><span class="line"> </span><br><span class="line">    private Date createTime;</span><br><span class="line">    private Date updateTime;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用户状态枚举</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public enum UserStatusEnum &#123;</span><br><span class="line">        &#x2F;**正常的*&#x2F;</span><br><span class="line">        NORMAL,</span><br><span class="line">        &#x2F;**禁用的*&#x2F;</span><br><span class="line">        DISABLED,</span><br><span class="line">        &#x2F;**已删除的*&#x2F;</span><br><span class="line">        DELETED;</span><br><span class="line"> </span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 判断参数合法性</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static boolean isValidName(String name) &#123;</span><br><span class="line">            for (UserStatusEnum userStatusEnum : UserStatusEnum.values()) &#123;</span><br><span class="line">                if (userStatusEnum.name().equals(name)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;省略getter、setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="controller类"><a href="#controller类" class="headerlink" title="controller类"></a>controller类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping</span><br><span class="line">    @ResponseStatus(HttpStatus.CREATED)</span><br><span class="line">    &#x2F;&#x2F;实际使用没有加 @Validated</span><br><span class="line">    public User addUser(@Validated @RequestBody User user) &#123;</span><br><span class="line">        user.setId(10000L);</span><br><span class="line">        user.setCreateTime(new Date());</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解校验</tag>
        <tag>HibernateValidator</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM基础知识</title>
    <url>/2020/09/12/Java-%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><a href="https://www.sohu.com/a/416098486_99908665" target="_blank" rel="noopener">13 张图解 Java 中的内存模型，快上车</a></p>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><h2 id="happen-before原则"><a href="#happen-before原则" class="headerlink" title="happen-before原则"></a>happen-before原则</h2><p><a href="https://blog.csdn.net/u010031673/article/details/48153797" target="_blank" rel="noopener">通俗易懂讲解happens-before原则</a></p>
<p><a href="https://blog.csdn.net/ma_chen_qq/article/details/82990603" target="_blank" rel="noopener">happen-before原则</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则与设计模式</title>
    <url>/2020/09/12/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h2><ul>
<li>封装</li>
<li>继承</li>
<li>多态<br>多态体现为父类引用变量可以指向子类对象<br>前提条件：必须有子父类关系。<h2 id="设计模式6大原则"><a href="#设计模式6大原则" class="headerlink" title="设计模式6大原则"></a>设计模式6大原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3>  对拓展开发,对修改关闭,高内聚低耦合:用抽象构建架构，用实现扩展原则；</li>
</ul>
<h3 id="迪米特原则-类"><a href="#迪米特原则-类" class="headerlink" title="迪米特原则(类)"></a>迪米特原则(类)</h3><pre><code>尽量降低类与类之间的耦合,使得一个类尽量对其他类最少了解:用抽象构建架构，用实现扩展原则；一个对象应该对其他对象有最少的了解</code></pre><h3 id="单一原则-类"><a href="#单一原则-类" class="headerlink" title="单一原则(类)"></a>单一原则(类)</h3><pre><code>尽量做到一个类只专注一件事,一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化；</code></pre><p>　　a、业务对象(BO business object)、业务逻辑(BL business logic)拆分；</p>
<h3 id="里氏替换原则-类继承"><a href="#里氏替换原则-类继承" class="headerlink" title="里氏替换原则(类继承)"></a>里氏替换原则(类继承)</h3><pre><code>子类可以扩展父类的功能,但是不能改变原有父类的功能;(本质其实就是c++的多态)</code></pre><p>　　(目的：增强程序的健壮性)实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。</p>
<h3 id="接口隔离原则-接口"><a href="#接口隔离原则-接口" class="headerlink" title="接口隔离原则(接口)"></a>接口隔离原则(接口)</h3><pre><code>使用多个专一的接口总比使用一个总接口要好,防止过度臃肿,接口设计粒度小,系统灵活,但是灵活同时结构复杂性提高,开发难度提高,维护性低;
建立单一接口；(扩展为类也是一种接口，一切皆接口)</code></pre><p>　　　定义：<br>　　　　a.客户端不应该依赖它不需要的接口；<br>　　　　b.类之间依赖关系应该建立在最小的接口上；</p>
<pre><code>简单理解：复杂的接口，根据业务拆分成多个简单接口；(对于有些业务的拆分多看看适配器的应用)
接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低　</code></pre><h3 id="依赖倒置原则-接口"><a href="#依赖倒置原则-接口" class="headerlink" title="依赖倒置原则(接口)"></a>依赖倒置原则(接口)</h3><pre><code>面向接口编程(通过接口作为参数实现应用场景),依赖抽象接口而不是依赖具体对象,就是不与具体类对象直接交互,而是与具体类上层接口交互</code></pre><p>　　抽象就是接口或者抽象类，细节就是实现类<br>　　含义：<br>　　　　上层模块不应该依赖下层模块，两者应依赖其抽象；<br>　　　　抽象不应该依赖细节，细节应该依赖抽象；<br>    通俗点就是说变量或者传参数，尽量使用抽象类，或者接口；<br>    接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑</p>
<h3 id="聚合复用原则-接口多态"><a href="#聚合复用原则-接口多态" class="headerlink" title="聚合复用原则(接口多态)"></a>聚合复用原则(接口多态)</h3><pre><code>要尽量使用对象组合,而不是继承关系达到软件复用的目的</code></pre><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><h3 id="创建模型模式-4种"><a href="#创建模型模式-4种" class="headerlink" title="创建模型模式(4种)"></a>创建模型模式(4种)</h3><p>定义:关注对象创建过程</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h3 id="组织模式-8种"><a href="#组织模式-8种" class="headerlink" title="组织模式(8种)"></a>组织模式(8种)</h3><p>定义:关注对象与类的组织</p>
<h3 id="行为模式-11种"><a href="#行为模式-11种" class="headerlink" title="行为模式(11种)"></a>行为模式(11种)</h3><p>定义:关注对象与对象之间相互交互,相互通信,协作</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>锁概念</title>
    <url>/2020/09/12/Java-%E9%94%81%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/jackyfei/p/12142840.html" target="_blank" rel="noopener">高并发场景下锁的使用技巧</a><a href="https://mp.weixin.qq.com/s/AhROJ1fHXOuANguy9MbyBQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AhROJ1fHXOuANguy9MbyBQ</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>Java</tag>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql优化1</title>
    <url>/2020/10/19/MySql-%E4%BC%98%E5%8C%961/</url>
    <content><![CDATA[<h2 id="Insert-into-select语句锁表"><a href="#Insert-into-select语句锁表" class="headerlink" title="Insert into select语句锁表"></a>Insert into select语句锁表</h2><h3 id="初始化建表"><a href="#初始化建表" class="headerlink" title="初始化建表"></a>初始化建表</h3><ul>
<li>订单表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;order_today&#96; (</span><br><span class="line">  &#96;id&#96; varchar(32) NOT NULL COMMENT &#39;主键&#39;,</span><br><span class="line">  &#96;merchant_id&#96; varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#39;商户编号&#39;,</span><br><span class="line">  &#96;amount&#96; decimal(15,2) NOT NULL COMMENT &#39;订单金额&#39;,</span><br><span class="line">  &#96;pay_success_time&#96; datetime NOT NULL COMMENT &#39;支付成功时间&#39;,</span><br><span class="line">  &#96;order_status&#96; varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#39;支付状态  S：支付成功、F：订单支付失败&#39;,</span><br><span class="line">  &#96;remark&#96; varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;备注&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间 -- 修改时自动更新&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE,</span><br><span class="line">  KEY &#96;idx_merchant_id&#96; (&#96;merchant_id&#96;) USING BTREE COMMENT &#39;商户编号&#39;</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>订单记录表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE order_record like order_today;</span><br></pre></td></tr></table></figure>
<h3 id="模拟生产环境"><a href="#模拟生产环境" class="headerlink" title="模拟生产环境"></a>模拟生产环境</h3><img src="/sql/%E4%BB%8A%E6%97%A5%E8%AE%A2%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE.png" alt="今日订单表数据" title="今日订单表数据"></li>
</ul>
<p>把8号之前的数据都迁移到order_record表中去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO order_record SELECT</span><br><span class="line">    * </span><br><span class="line">FROM</span><br><span class="line">    order_today </span><br><span class="line">WHERE</span><br><span class="line">    pay_success_time &lt; &#39;2020-03-08 00:00:00&#39;;</span><br></pre></td></tr></table></figure>
<p>在navicat中运行迁移的sql,同时开另个一个窗口插入数据，模拟下单。<br><img src="/sql/sql1.png" alt="sql1" title="sql1"><br><img src="/sql/sql2.png" alt="sql2" title="sql2"><br><img src="/sql/sql3.png" alt="sql3" title="sql3"></p>
<p>从上面可以发现一开始能正常插入，但是后面突然就卡住了，并且耗费了23s才成功，然后才能继续插入。这个时候已经迁移成功了，所以能正常插入了。</p>
<h3 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h3><p>在默认的事务隔离级别下：insert into order_record select * from order_today 加锁规则是：order_record表锁，order_today逐步锁（扫描一个锁一个）。<br>分析执行过程。<br><img src="/sql/sql4.png" alt="sql4" title="sql4"><br>通过观察迁移sql的执行情况你会发现order_today是全表扫描，也就意味着在执行insert into select from 语句时，mysql会从上到下扫描order_today内的记录并且加锁，这样一来不就和直接锁表是一样了。</p>
<p>这也就可以解释，为什么一开始只有少量用户出现支付失败，后续大量用户出现支付失败，初始化订单失败等情况，因为一开始只锁定了少部分数据，没有被锁定的数据还是可以正常被修改为正常状态。由于锁定的数据越来越多，就导致出现了大量支付失败。最后全部锁住，导致无法插入订单，而出现初始化订单失败。</p>
<ul>
<li>解决方案<br>由于查询条件会导致order_today全表扫描，什么能避免全表扫描呢，很简单嘛，给pay_success_time字段添加一个idx_pay_suc_time索引就可以了，由于走索引查询，就不会出现扫描全表的情况而锁表了，只会锁定符合条件的记录。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO order_record SELECT</span><br><span class="line">    * </span><br><span class="line">FROM</span><br><span class="line">    order_today FORCE INDEX (idx_pay_suc_time)</span><br><span class="line">WHERE</span><br><span class="line">    pay_success_time &lt;&#x3D; &#39;2020-03-08 00:00:00&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/sql/sql5.png" alt="sql5" title="sql5"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用insert into tablA select * from tableB语句时，一定要确保tableB后面的where，order或者其他条件，都需要有对应的索引，来避免出现tableB全部记录被锁定的情况</p>
<h2 id="深入分析总结"><a href="#深入分析总结" class="headerlink" title="深入分析总结"></a>深入分析总结</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>insert into … select 由于SELECT表引起的死锁情况分析<br>说法一：在RR隔离级别下 INSERT SELECT 会对 SELECT 表中符合条件的数据加上 LOCK_S 锁。<br>说法二：（主键自增锁模式应该为0或1）</p>
<p>情景一：insert into table1 …select * from table2：table1锁表，table2逐步锁（扫描一个锁一个）<br>情景二：insert into table1 …select * from table2 order by 主键：table1锁表，table2逐步锁（扫描一个锁一个）<br>情景三：insert into table1 …select * from table2 order by 非主键：table1锁表，table2一开始就锁全表</p>
<p>insert into … select容易造成死锁的原因，后面的select语句对后表会逐步加s锁，前面的insert数量不一定，导致锁住另一个表整表auto-inc锁。 锁越多越容易出现死锁问题</p>
<h3 id="模拟下面两个并发事务"><a href="#模拟下面两个并发事务" class="headerlink" title="模拟下面两个并发事务:"></a>模拟下面两个并发事务:</h3><p><img src="/sql/sql6.png" alt="sql6" title="sql6"></p>
<h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h4><p>TX1：执行update将表b主键id=2999的记录加上LOCK_X<br>TX2：执行insert…select语句b表上的记录(996,997,998,999,2995,2996,2997,2998,2999)会申请加上LOCK_S, 但是id=2999已经加上LOCK_X,显然不能获得只能等待.<br>TX1：执行update需要获得表b主键id=999的LOCK_X显然这个记录已经被TX2加锁LOCK_S，只能等待，触发死锁检测</p>
<p>如下图红色记录为不能获得锁的记录:<br><img src="/sql/sql7.png" alt="sql7" title="sql7"></p>
<h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><p>这种情况比较极端只能在高并发上出现<br>TX1：执行update将表b主键id=2999的记录加上LOCK_X<br>TX2：执行insert…select语句b表上的记录(996,997,998,999,2995,2996,2997,2998,2999)会申请加上LOCK_S，因为上锁是有一个逐步加锁的过程,假设此时加锁到2997前那么TX2并不会等待<br>TX1：执行update需要获得表b主键id=999的LOCK_X显然这个记录已经被TX2加锁LOCK_S，只能等待<br>TX2：继续加锁LOCK_S 2997、2998、2999 发现2999已经被TX1加锁LOCK_X，只能等待，触发死锁检测</p>
<p>如下图红色记录为不能获得锁的记录:<br><img src="/sql/sql8.png" alt="sql8" title="sql8"></p>
]]></content>
      <categories>
        <category>Database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>生产问题</tag>
        <tag>面试知识</tag>
        <tag>Mysql优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql优化知识</title>
    <url>/2021/06/07/MySql-%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Mysql优化基础"><a href="#Mysql优化基础" class="headerlink" title="Mysql优化基础"></a>Mysql优化基础</h2><p>优化逻辑: <font color='red'>选择存储引擎—-&gt;建表—-&gt;建索引—-&gt;优化sql—-&gt;硬件</font></p>
<h3 id="选择存储引擎"><a href="#选择存储引擎" class="headerlink" title="选择存储引擎"></a>选择存储引擎</h3><h4 id="引擎种类"><a href="#引擎种类" class="headerlink" title="引擎种类"></a>引擎种类</h4><p>InnoDby存储引擎,MyIsAm存储引擎,Memory存储引擎<br>InnoDb引擎:如果数据量比较大,这是需要通过升级架构来解决,比如分表分库,读写分离,而不是单纯地依赖存储引擎</p>
<h4 id="常用引擎比较"><a href="#常用引擎比较" class="headerlink" title="常用引擎比较"></a>常用引擎比较</h4><table>
<thead>
<tr>
<th>InnoDb引擎</th>
<th>MyIsAm引擎</th>
</tr>
</thead>
<tbody><tr>
<td>聚簇索引(主键索引和数据是在一起的)</td>
<td>非聚簇索引</td>
</tr>
<tr>
<td>支持事务(出错还可以回滚还原)</td>
<td>不支持事务</td>
</tr>
<tr>
<td>行级锁</td>
<td>全表锁</td>
</tr>
<tr>
<td>全表删除,行级删</td>
<td>全表删除,重建表</td>
</tr>
<tr>
<td>MVCC控制并发</td>
<td>不控制并发</td>
</tr>
<tr>
<td>适合读写改删操作</td>
<td>适合写入频繁操作</td>
</tr>
</tbody></table>
<p>聚簇索引:将数据存储与索引放到了一块,索引结构的叶子节点保存了行数据;如果表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 聚簇索引会使用DB_ROW_ID的值来作为主键; 如果表中有主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID了<br>非聚簇索引:将数据与索引分开存储,索引结构的叶子节点(指针)指向了保存在磁盘上数据对应的位置</p>
<p>聚集索引和非聚集索引的区别如下<br>1.聚簇索引只需要一次按Page加载数据到缓冲区(一次I/O),已经加载在缓冲区的数据后续不需要再一次(I/O);非聚簇索引结构原因导致数据每一次查找都需要从硬盘加载(I/O)</p>
<h4 id="为什么主键通常建议使用自增id"><a href="#为什么主键通常建议使用自增id" class="headerlink" title="为什么主键通常建议使用自增id"></a>为什么主键通常建议使用自增id</h4><p>如果主键不是自增id,B+树不断地调整数据的物理地址、分页.但如果是自增的,索引结构相对紧凑,磁盘碎片少,效率也高;</p>
<h3 id="为什么索引是int类型"><a href="#为什么索引是int类型" class="headerlink" title="为什么索引是int类型"></a>为什么索引是int类型</h3><p>建议使用int类型的自增,如果主键其他类型值占用的存储空间越大,也就节点会变多,增加B+树的高度,IO操作也会变多.</p>
<h4 id="为什么不适用UUid做聚簇索引"><a href="#为什么不适用UUid做聚簇索引" class="headerlink" title="为什么不适用UUid做聚簇索引"></a>为什么不适用UUid做聚簇索引</h4><p>当使用主键为聚簇索引时,主键最好不要使用uuid,因为uuid的值太过离散,不适合排序且可能出线新增加记录的uuid,会插入在索引树中间的位置,导致索引树调整复杂度变大,消耗更多的时间和资源.</p>
<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>使用三范式建表/反三范式适当冗余</p>
<h4 id="三范式建表"><a href="#三范式建表" class="headerlink" title="三范式建表"></a>三范式建表</h4><ul>
<li>保证表字段原子性</li>
<li>完全依赖主键(消除除主键外,表字段对其他字段的唯一依赖)<br>  字段ABC:主键A-&gt;C,B-&gt;C //C同时唯一依赖A/B,要消除B-&gt;C,让主键唯一依赖</li>
<li>消除存在传递性依赖,适当增加中间表<br>  字段ABC:主键A-&gt;B,B-&gt;C //可以由A推出B,B推出C,消除C</li>
</ul>
<h3 id="建索引"><a href="#建索引" class="headerlink" title="建索引"></a>建索引</h3><pre><code>建立主键,常用字段为索引,还有考虑联合索引</code></pre><h3 id="优化sql"><a href="#优化sql" class="headerlink" title="优化sql"></a>优化sql</h3><h4 id="使用索引注意"><a href="#使用索引注意" class="headerlink" title="使用索引注意"></a>使用索引注意</h4><ul>
<li>Select:尽可能不使用select* 问题,select之后只写必要字段,增加索引覆盖率</li>
<li>Where:使用满足最左匹配索引原则</li>
<li>and:过于频繁使用and查询,合理使用复合索引,但是尽量少用</li>
<li>or:防止一边无索引,导致全部查询</li>
<li>order By:若无索引,则数据将从硬盘分批读取到内存中排序,最后合并结果</li>
<li>join…in:条件中建立索引</li>
<li>like:防止“%XXX%”全表查询,但是“XXX%”可以使用索引</li>
</ul>
<p>注:复合索引原理(A and B)<br>    1.若AB都有索引树,先在A树找到再到B树找,取交集;<br>    2.若以A_B拼接成字符串后做成联合索引,则在索引结果中找A,然后二分法找B,但复合索引树高度I/O过多,导致性能效率问题</p>
<h4 id="看执行计划-查看索引使用情况"><a href="#看执行计划-查看索引使用情况" class="headerlink" title="看执行计划,查看索引使用情况"></a>看执行计划,查看索引使用情况</h4><p>MySQL 使用 explain + sql 语句查看 执行计划,该执行计划不一定完全正确但是可以参考</p>
<h2 id="MySQL查看执行计划"><a href="#MySQL查看执行计划" class="headerlink" title="MySQL查看执行计划"></a>MySQL查看执行计划</h2><p>MySQL 使用 explain + sql 语句查看 执行计划</p>
<ul>
<li>EXPLAIN SELECT * FROM user WHERE nid = 3;</li>
</ul>
<p><img src="/img/Mysql-Explain.png" alt="Mysql-Explain" title="Mysql-Explain"><br>其中最重要的字段为:id、type、key、rows、Extra</p>
<h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>select查询的序列号,包含一组数字,表示查询中执行select子句或操作表的顺序</p>
<ul>
<li><p>id相同:执行顺序由上至下<br><img src="/img/explain-id1.png" alt="explain-id1" title="id1"></p>
</li>
<li><p>id不同:如果是子查询,id的序号会递增,id值越大优先级越高,越先被执行<br><img src="/img/explain-id2.png" alt="explain-id2" title="id2"></p>
</li>
<li><p>id存在部分相同(两种情况同时存在):id如果相同,可以认为是一组,从上往下顺序执行；在所有组中,id值越大,优先级越高,越先执行<br><img src="/img/explain-id3.png" alt="explain-id3" title="id3"></p>
</li>
</ul>
<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><ul>
<li>SIMPLE:简单的select查询,查询中不包含子查询或者union</li>
<li>PRIMARY:查询中包含任何复杂的子部分,最外层查询则被标记为primary</li>
<li>SUBQUERY:在select 或 where列表中包含了子查询</li>
<li>DERIVED:在from列表中包含的子查询被标记为derived(衍生),mysql或递归执行这些子查询,把结果放在零时表里 </li>
<li>UNION:若第二个select出现在union之后,则被标记为union；若union包含在from子句的子查询中,外层select将被标记为derived </li>
<li>UNION RESULT:使用union查询后的结果<br><img src="/img/explain-union-result.png" alt="explain-union-result" title="union-result"></li>
</ul>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>&emsp;&emsp;system:表仅有一行(系统表).这是const联接类型的一个特例<br>&emsp;&emsp;const:常量,表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次<br>&emsp;&emsp;eq_ref:搜索时使用primary key 或 unique类型<br>&emsp;&emsp;ref:根据索引查找一个或多个值<br>&emsp;&emsp;index_merge:合并索引,使用多个单列索引搜索<br>&emsp;&emsp;range:对索引列进行范围查找<br>&emsp;&emsp;index:全索引表扫描<br>&emsp;&emsp;ALL:全数据表扫描</p>
<p>访问类型,sql查询优化中一个很重要的指标,结果值从好到坏的性能依次是</p>
<ul>
<li><p><font color='red'>system/const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; range &gt; index &gt; all,性能在 range 之下基本都可以进行调优</font></p>
</li>
<li><p>1.system:表只有一行记录(等于系统表),这是const类型的特例,平时不会出现,可以忽略不计</p>
</li>
<li><p>2.const:表示通过索引一次就找到了,const用于比较primary key 或者 unique索引.因为只需匹配一行数据,所有很快.如果将主键置于where列表中,mysql就能将该查询转换为一个const<br><img src="/img/explain-system-const.png" alt="explain-system-const" title="explain-system-const"></p>
</li>
<li><p>3.eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配.常见于主键 或 唯一索引扫描.<br><img src="/img/explain-eq_ref.png" alt="explain-eq_ref" title="explain-eq_ref"><br>注意:ALL全表扫描的表记录最少的表如t1表</p>
</li>
<li><p>4.ref:非唯一性索引扫描，返回匹配某个单独值的所有行.本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体<br><img src="/img/explain-ref.png" alt="explain-ref" title="explain-ref"></p>
</li>
<li><p>5.range:只检索给定范围的行，使用一个索引来选择行.key列显示使用了那个索引.一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询.这种索引列上的范围扫描比全索引扫描要好.只需要开始于某个点，结束于另一个点，不用扫描全部索引<br><img src="/img/explain-range.png" alt="explain-range" title="explain-range"></p>
</li>
<li><p>6.index:Full Index Scan，index与ALL区别为index类型只遍历索引树.这通常为ALL块，应为索引文件通常比数据文件小.(Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取)<br><img src="/img/explain-index.png" alt="explain-index" title="explain-index"></p>
</li>
<li><p>7.ALL:Full Table Scan，遍历全表以找到匹配的行<br><img src="/img/explain-all.png" alt="explain-all" title="explain-all"></p>
</li>
</ul>
<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>ref:显示索引的那一列被使用了，如果可能，是一个常量const.</p>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>rows:根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>table:正在访问的表名</p>
<h4 id="possible-keys-amp-amp-Key"><a href="#possible-keys-amp-amp-Key" class="headerlink" title="possible_keys &amp;&amp; Key"></a>possible_keys &amp;&amp; Key</h4><p>possible_keys:查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用<br>key:实际使用的索引,如果为NULL,则没有使用索引.查询中如果使用了覆盖索引，则该索引仅出现在key列表中<br><img src="/img/explain-key.png" alt="explain-key" title="explain-key"></p>
<h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>key_len:表示索引中使用的字节数，查询中使用的索引的长度(最大可能长度)，并非实际使用长度，理论上长度越短越好.key_len是根据表定义计算而得的，不是通过表内检索出的</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit:匹配后就不会继续进行扫描</p>
<h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><p>extra:不适合在其他字段中显示，但是十分重要的额外信息</p>
<ul>
<li><p>Using filesort:mysql会对结果使用一个外部索引排序,而不是按索引次序从表里读取行,也就是说mysql无法利用索引完成的排序操作成为“文件排序” .mysql有两种文件排序算法,这两种排序方式都可以在内存或者磁盘上完成,explain不会告诉你mysql将使用哪一种文件排序,也不会告诉你排序会在内存里还是磁盘上完成.<br><img src="/img/explain-Using-filesort.png" alt="explain-Using-filesort" title="explain-Using-filesort"><br>由于索引是先按email排序、再按address排序，所以查询时如果直接按address排序，索引就不能满足要求了，mysql内部必须再实现一次“文件排序”</p>
</li>
<li><p>Using temporary:mysql 对查询结果排序时会使用临时表.<br>使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 和 group by<br><img src="/img/explain-Using-temporary.png" alt="explain-Using-temporary" title="Using-temporary"></p>
</li>
<li><p>Using index:此值表示mysql将使用覆盖索引,以避免访问表.表示相应的select操作中使用了覆盖索引(Covering Index)，避免了访问表的数据行，效率高<br>如果同时出现Using where，表明索引被用来执行索引键值的查找(参考上图);如果没用同时出现Using where，表明索引用来读取数据而非执行查找动作<br><img src="/img/explain-Using-index.png" alt="explain-Using-index" title="Using-index"></p>
</li>
</ul>
<p>Covering Index:覆盖索引,也叫索引覆盖.就是select列表中的字段，只用从索引中就能获取，不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖.<br>注意:<br>a、如需使用覆盖索引，select列表中的字段只取出需要的列，不要使用select *<br>b、如果将所有字段都建索引会导致索引文件过大，反而降低crud性能</p>
<ul>
<li><p>Range checked for each record(index map: N):没有好用的索引,新的索引将在联接的每一行上重新估算,N是显示在possible_keys列中索引的位图,并且是冗余的</p>
</li>
<li><p>Impossible WHERE:where子句的值总是false，不能用来获取任何元祖<br><img src="/img/explain-Impossible-where.png" alt="explain-Impossible-where" title="explain-Impossible-where"></p>
</li>
<li><p>Using where :mysql 将在存储引擎检索行后再进行过滤,许多where条件里涉及索引中的列,当(并且如果)它读取索引时,就能被存储引擎检验,因此不是所有带where子句的查询都会显示“Using where”.有时“Using where”的出现就是一个暗示:查询可受益于不同的索引.</p>
</li>
<li><p>Using join buffer :使用了链接缓存</p>
</li>
<li><p>select tables optimized away :在没有group by子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段在进行计算，查询执行计划生成的阶段即可完成优化</p>
</li>
<li><p>distinct :优化distinct操作，在找到第一个匹配的元祖后即停止找同样值得动作</p>
</li>
</ul>
<h4 id="综合Case"><a href="#综合Case" class="headerlink" title="综合Case"></a>综合Case</h4><p><img src="/img/explain-%E7%BB%BC%E5%90%88Case.png" alt="explain-综合Case" title="explain-综合Case"><br>执行顺序 </p>
<ul>
<li>1.(id = 4)[select id, name from t2]:select_type 为union，说明id=4的select是union里面的第二个select.</li>
<li>2.(id = 3)、[select id, name from t1 where address = ‘11’]:因为是在from语句中包含的子查询所以被标记为DERIVED(衍生)，where address = ‘11’ 通过复合索引idx_name_email_address就能检索到，所以type为index.</li>
<li>3.(id = 2)、[select id from t3]:因为是在select中包含的子查询所以被标记为SUBQUERY.</li>
<li>4.(id = 1)、[select d1.name, … d2 from … d1]:select_type为PRIMARY表示该查询为最外层查询，table列被标记为 “derived3”表示查询结果来自于一个衍生表(id = 3 的select结果).</li>
<li>5.(id = NULL)、[ … union … ]:代表从union的临时表中读取行的阶段，table列的 “union 1, 4”表示用id=1 和 id=4 的select结果进行union操作.</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>Mysql优化</tag>
      </tags>
  </entry>
  <entry>
    <title>workbench工具</title>
    <url>/2021/06/07/Mysql-workbench/</url>
    <content><![CDATA[<h2 id="使用-Workbench-操作数据库"><a href="#使用-Workbench-操作数据库" class="headerlink" title="使用 Workbench 操作数据库"></a>使用 Workbench 操作数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>打开 MySQL Workbench 软件，如下图所示，方框标识的部分就是当前数据库服务器中已经创建的数据库列表。<br><img src="/workbench/B1.png" alt="图B1" title="图B1"></p>
<p>在 SCHEMAS 列表的空白处右击，选择“Create Schema…”，则可创建一个数据库，如下图所示。<br><img src="/workbench/B2.png" alt="图B2" title="图B2"></p>
<p>在创建数据库的对话框中，在 Name 框中输入数据库的名称，在 Collation 下拉列表中选择数据库指定的字符集(指定字符集默认为UTF-8。<br>)。单击 Apply 按钮，即可创建成功，如下图所示<br><img src="/workbench/B3.png" alt="图B3" title="图B3"></p>
<p>在创建数据库的对话框中设置完成之后，可以预览当前操作的 SQL 脚本，即 CREATE DATABASE test_db，然后单击 Apply 按钮，最后在下一个弹出的对话框中直接单击 Finish 按钮，即可完成数据库 test_db 的创建，如下图所示。<br><img src="/workbench/B4.png" alt="图B4" title="图B4"></p>
<h3 id="用户创建与权限设置"><a href="#用户创建与权限设置" class="headerlink" title="用户创建与权限设置"></a>用户创建与权限设置</h3><p><img src="/workbench/1.png" alt="图1" title="图1"><br><img src="/workbench/2.png" alt="图2" title="图2"><br><img src="/workbench/3.png" alt="图3" title="图3"><br><img src="/workbench/4.png" alt="图4" title="图4"><br><img src="/workbench/5.png" alt="图5" title="图5"><br><img src="/workbench/6.png" alt="图6" title="图6"><br><img src="/workbench/7.png" alt="图7" title="图7"></p>
]]></content>
      <categories>
        <category>Database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Workbench</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务实现原理之Redo Log底层分析</title>
    <url>/2020/12/02/Mysql-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="MySQL事务实现原理之Redo-Log"><a href="#MySQL事务实现原理之Redo-Log" class="headerlink" title="MySQL事务实现原理之Redo Log"></a>MySQL事务实现原理之Redo Log</h2><p>Redo Log是一个重要的话题，它主要实现了事务的持久化属性；<br><a href="https://blog.csdn.net/qq_41999455/article/details/106161484" target="_blank" rel="noopener">MySQL事务实现原理之Redo Log</a><br><a href="https://www.zhihu.com/question/368847138" target="_blank" rel="noopener">InnoDB如何保证redolog的完整性？</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础知识2</title>
    <url>/2020/12/02/Mysql-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</url>
    <content><![CDATA[<h2 id="MySQL的基本架构"><a href="#MySQL的基本架构" class="headerlink" title="MySQL的基本架构"></a>MySQL的基本架构</h2><p><font color='red'>在 MySQL 5.5 以后,默认的存储引擎为 InnoDB,且只有 InnoDB 引擎支持事务和数据崩溃恢复,因此所有内容均是基于 InnoDB 存储引擎为前提</font><br><img src="/img/MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png" alt="MySQL的基本架构" title="MySQL的基本架构"></p>
<p>思考一下下面两个问题:</p>
<ul>
<li>1.MySQL 有四大特性:ACID,其中 D 指的是持久性(Durability),它的含义是 MySQL 的事务一旦提交,它对数据库的改变是永久性的,即数据不会丢失,那么 MySQL 究竟是如何实现的呢？</li>
<li>2.MySQL 数据库所在服务器宕机或者断电后,会出现数据丢失的问题吗？如果不丢失,它又是如何来实现数据不丢失的呢？</li>
</ul>
<h3 id="Redo-Log-重做日志"><a href="#Redo-Log-重做日志" class="headerlink" title="Redo Log(重做日志)"></a>Redo Log(重做日志)</h3><h4 id="Redo-Log定义"><a href="#Redo-Log定义" class="headerlink" title="Redo Log定义"></a>Redo Log定义</h4><p>redo log是InnoDB存储引擎层的日志,又称重做日志文件,用于记录事务操作的变化,记录的是数据页的物理修改(数据修改之后的值),不管事务是否提交都会记录下来.在实例和介质失败(media failure)时,redo log文件就能派上用场,如数据库掉电,InnoDB存储引擎会使用redo log恢复提交后的物理数据页(恢复数据页,且只能恢复到最后一次提交的位置),以此来保证数据的完整性.redo log日志的大小是固定的,即记录满了以后就从头循环写</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>确保事务的持久性.防止在发生故障的时间点,尚有脏页未写入磁盘,在重启mysql服务的时候,根据redo log进行重做,从而达到事务的持久性这一特性.</p>
<h4 id="Redo-Log-Buffer"><a href="#Redo-Log-Buffer" class="headerlink" title="Redo Log Buffer"></a>Redo Log Buffer</h4><p>　　　当一条SQL更新完Data Buffer的缓存页后,就会记录一条 redo log 日志,前面提到了redo log日志是存储在磁盘上的,那么此时是不是立马就将 redo log 日志写入磁盘呢？显然不是的,而是先写入一个叫做 redo log buffer 的缓存中,<font color='red'>redo log buffer 是一块不同于Data Buffer的内存缓存区,在 MySQL 启动的时候,向内存中申请的一块redo log内存区域(在电脑cpu中的内存,与Mysql实例内存同级,而data buffer 是处于申请Mysql实例内存后,在实例里的内存区域),它是 redo log 日志缓冲区,默认大小是 16MB,由参数 innodb_log_buffer_size 控制(前面的截图中可以看到)</font><br>　　　redo log buffer内部又可以划分为许多 redo log block,每个 redo log block 大小为 512 字节.我们写入的 redo log 日志,最终实际上是先写入在 redo log buffer 的 redo log block 中,然后在某一个合适的时间点,将这条 redo log 所在的 redo log block 刷入到磁盘中.<font color='red'>这个合适的时间点究竟是什么时候呢？</font>查看下面Redo Log CheckPoint</p>
<h4 id="WAL技术-Write-Ahead-logging"><a href="#WAL技术-Write-Ahead-logging" class="headerlink" title="WAL技术(Write Ahead logging)"></a>WAL技术(Write Ahead logging)</h4><p>&emsp;&emsp;具体到InnoDB中,Write-Ahead Log是Redo Log.在InnoDB中,不 光事务修改的数据库表数据是异步刷盘的,连Redo Log的写入本身也是 异步的.如图6-7所示,在事务提交之后, Redo Log先写入到内存中的 Redo Log Buffer中,然后异步地刷到磁盘上的Redo Log.<br><img src="/img/RedoLog%E5%88%B7%E7%9B%98.png" alt="RedoLog刷盘" title="RedoLog刷盘"><br>&emsp;&emsp;MySQL 在更新数据时,为了减少磁盘的随机 IO,因此并不会直接更新磁盘上的数据,而是先更新 Data Buffer 中缓存页的数据,等到合适的时间点,再将这个缓存页持久化到磁盘.而 Data Buffer 中所有缓存页都是处于内存当中的,当 MySQL 宕机或者机器断电,内存中的数据就会丢失,因此 MySQL 为了防止缓存页中的数据在更新后出现数据丢失的现象,引入了redo log 机制.<br>&emsp;&emsp;当进行增删改操作时,MySQL 会在更新 Data Buffer 中的缓存页数据时,会记录一条对应操作的 redo log 日志,这样如果出现 MySQL 宕机或者断电时,如果有缓存页的数据还没来得及刷入磁盘,那么当 MySQL 重新启动时,可以根据 redo log 日志文件,进行数据重做,将数据恢复到宕机或者断电前的状态,保证了更新的数据不丢失,因此redo log又叫做重做日志.它的本质是保证事务提交后,更新的数据不丢失.<br>&emsp;&emsp;redo log日志文件是持久化在磁盘上的,磁盘上可以有多个redo log文件,MySQL 默认有 2 个 redo log 文件,每个文件大小为 48MB,这两个文件默认存放在 MySQL 数据目录的文件夹下,这两个文件分别为 ib_logfile0 和 ib_logfile1.(本人电脑上安装的 MySQL 时,指定存放数据的目录是:/usr/local/mysql/data,因此这两个 redo log 文件所在的磁盘路径分别是:/usr/local/mysql/data/ib_logfile0 和/usr/local/mysql/data/ib_logfile1).可以通过如下命令来查看 redo log 文件相关的配置.</p>
<ul>
<li><font color='red'>查询命令:show variables like ‘innodb_log%’</font><br><img src="/img/redo_log%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0.png" alt="redo_log设置参数" title="redo_log设置参数"></li>
<li>innodb_log_files_in_group 表示的是有几个 redo log 日志文件.</li>
<li>innodb_log_file_size 表示的是每个 redo log 日志文件的大小为多大.</li>
<li>innodb_log_group_home_dir 表示的是 redo log 文件存放的目录,在这里./表示的是相对于 MySQL 存放数据的目录,这些参数可以根据实际需要自定义修改.</li>
</ul>
<h3 id="Undo-Log-回滚日志"><a href="#Undo-Log-回滚日志" class="headerlink" title="Undo Log(回滚日志)"></a>Undo Log(回滚日志)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>逻辑格式的日志,在执行undo的时候,仅仅是将数据从逻辑上恢复至事务之前的状态,而不是从物理页面上操作实现的,这一点是不同于redo log的.</p>
<ul>
<li>什么时候产生:事务开始之前,将当前是的版本生成undo log,undo 也会产生 redo 来保证undo log的可靠性</li>
<li>什么时候释放:当事务提交之后,undo log并不能立马被删除,而是放入待清理的链表,由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息,决定是否可以清理undo log的日志空间.<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4>保存了事务发生之前的数据的一个版本,可以用于回滚,同时可以提供多版本并发控制下的读(MVCC),也即非锁定读<h4 id="不同版本物理文件"><a href="#不同版本物理文件" class="headerlink" title="不同版本物理文件"></a>不同版本物理文件</h4></li>
<li>MySQL5.6之前,undo表空间位于共享表空间的回滚段中,共享表空间的默认的名称是ibdata,位于数据文件目录中.</li>
<li>MySQL5.6之后,undo表空间可以配置成独立的文件,但是提前需要在配置文件中配置,完成数据库初始化后生效且不可改变undo log文件的个数<br>如果初始化数据库之前没有进行相关配置,那么就无法配置成独立的表空间了.</li>
<li>关于MySQL5.7之后的独立undo 表空间配置参数如下:<br>&emsp;&emsp;innodb_undo_directory = /data/undospace/ –undo独立表空间的存放目录<br>&emsp;&emsp;innodb_undo_logs = 128 –回滚段为128KB<br>&emsp;&emsp;innodb_undo_tablespaces = 4 –指定有4个undo log文件<br>如果undo使用的共享表空间,这个共享表空间中又不仅仅是存储了undo的信息,共享表空间的默认为与MySQL的数据在相同目录下面,其属性由参数innodb_data_file_path配置.</li>
</ul>
<p>undo是在事务开始之前保存的被修改数据的一个版本,产生undo日志的时候,同样会伴随类似于保护事务持久化机制的redolog的产生.默认情况下undo文件是保持在共享表空间的,也即ibdatafile文件中,当数据库中发生一些大的事务性操作的时候,要生成大量的undo信息,全部保存在共享表空间中的.因此共享表空间可能会变的很大,默认情况下,也就是undo 日志使用共享表空间的时候,被“撑大”的共享表空间是不会也不能自动收缩的.因此,mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了</p>
<h3 id="Bin-Log-备份日志"><a href="#Bin-Log-备份日志" class="headerlink" title="Bin Log(备份日志)"></a>Bin Log(备份日志)</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>逻辑格式的日志,可以简单认为就是执行过的事务中的sql语句.但又不完全是sql语句这么简单,而是包括了执行的sql语句(增删改)反向的信息,也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息.<br>在使用mysqlbinlog解析binlog之后一些都会真相大白.因此可以基于binlog做到类似于oracle的闪回功能,其实都是依赖于binlog中的日志记录.</p>
<ul>
<li>格式1:statement格式,记原始的SQL语句, insert/delete/update.</li>
<li>格式2:RAW格式,记录每张表的每条记录的修 改前的值、修改后的值,类似(表,行,修改前的值,修改后的值).</li>
<li>什么时候产生:事务提交的时候,一次性将事务中的sql语句(一个事物可能对应多个sql语句)按照一定的格式记录到binlog中.这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘,redo log是在事务开始之后就开始逐步写入磁盘.因此对于事务的提交,即便是较大的事务,提交(commit)都是很快的,但是在开启了bin_log的情况下,对于较大事务的提交,可能会变得比较慢一些.这是因为binlog是在事务提交的时候一次性写入的造成的,这些可以通过测试验证.</li>
<li>什么时候释放:binlog的默认是保持时间由参数expire_logs_days配置,也就是说对于非活动的日志文件,在生成时间超过expire_logs_days配置的天数之后,会被自动删除.<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4></li>
</ul>
<p>1.用于复制,在主从复制中,从库利用主库上的binlog进行重播,实现主从同步.<br>2.用于数据库的基于时间点的还原.</p>
<h4 id="物理文件"><a href="#物理文件" class="headerlink" title="物理文件"></a>物理文件</h4><p>配置文件的路径为:show variables like  “log_bin_basename”;<br>binlog日志文件按照指定大小,当日志文件达到指定的最大的大小之后,进行滚动更新,生成新的日志文件.对于每个binlog日志文件,通过一个统一的index文件来组织</p>
<h3 id="Redo-Log-amp-amp-Bin-Log区别"><a href="#Redo-Log-amp-amp-Bin-Log区别" class="headerlink" title="Redo Log &amp;&amp; Bin Log区别"></a>Redo Log &amp;&amp; Bin Log区别</h3><ul>
<li>日志层级不同:binlog 记录的是逻辑日志,是 MySQL 的 Server 层记录的;redo log 中记录的是物理日志,是 InnoDB 引擎记录的.</li>
<li>记录内容不同:binlog 中记录的是 SQL 语句(实际上并不一定为 SQL 语句,这与 binlog 的格式有关,如果指定的是 STATEMENT 格式,那么 binlog 中记录的就是 SQL 语句),也就是逻辑日志;redo log 中则记录的是对磁盘上的某个表空间的某个数据页的某一行数据的某个字段做了修改,修改后的值为多少,它记录的是对物理磁盘上数据的修改,因此称之为物理日志.</li>
<li>清理机制不同:两者日志产生的时间,可以释放的时间,在可释放的情况下清理机制,都是完全不同的</li>
<li>效率不同:恢复数据时候的效率,基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</li>
<li>大小不同:redo log是循环写,日志空间大小固定；binlog是追加写,是指一份写到一定大小的时候会更换下一个文件,不会覆盖.</li>
<li>作用意义:binlog可以作为恢复数据使用,主从复制搭建,redo log作为异常宕机或者介质故障后的数据恢复使用.</li>
</ul>
<h3 id="CheckPoint-同步-归档-磁盘时间点"><a href="#CheckPoint-同步-归档-磁盘时间点" class="headerlink" title="CheckPoint(同步/归档)磁盘时间点"></a>CheckPoint(同步/归档)磁盘时间点</h3><h4 id="Redo-Log-Buffer-Log-Buffer"><a href="#Redo-Log-Buffer-Log-Buffer" class="headerlink" title="Redo Log Buffer(Log Buffer)"></a>Redo Log Buffer(Log Buffer)</h4><p>1.MySQL 正常关闭的时候;<br>2.MySQL 的后台线程每隔一段时间定时的讲 redo log buffer 刷入到磁盘,默认是每隔 1s 刷一次;<br>3.当 redo log buffer 中的日志写入量超过 redo log buffer 内存的一半时,即超过 8MB 时,会触发 redo log buffer 的刷盘;<br>4.当事务提交时,Redo log根据配置的参数 innodb_flush_log_at_trx_commit 来决定是否刷盘.</p>
<ul>
<li>show variables like “innodb_flush_log_at_trx_commit”;<ul>
<li>I.参数配置为 0:跟事务提交无关,由mysql的main_thread每秒将 存储引擎log buffer中的redo日志写入到log file,并调用文件系统的fsync()刷新操作,将日志刷新到磁盘;<font color ='red'>存在一秒停顿才更新,如果断电可能存在丢失一秒的事务数据</font></li>
<li>II.参数配置为 1:每次事务提交时,将存储引擎log buffer中的redo日志写入到log file,并调用文件系统的fsync()刷新操作,将日志刷新到磁盘;(这个最安全)</li>
<li>III.参数配置为 2:每次事务提交时,将存储引擎log buffer中的redo日志写入到log file,并由存储引擎的main_thread 每秒将调用文件系统的fsync()刷新操作,将日志刷新到磁盘.由于日志只是写进缓存里,每秒才fsync()刷新,宕机存在丢失一秒内缓存数据的<br><font color='red'>(进程在向磁盘写入数据时,是先将数据写入到操作系统的缓存中:os cache,再调用 fsync()刷新操作,才会将数据从 os cache 中刷新到磁盘上)</font></li>
</ul>
</li>
</ul>
<p><img src="/img/Redo-log-checkpoint.jpg" alt="Redo-log-checkpoint" title="Redo-log-checkpoint"><br>这是一组4个文件的redo log日志,checkpoint之前表示擦除完了的,即可以进行写的,擦除之前会更新到磁盘中,write pos是指写的位置,当write pos和checkpoint相遇的时候表明redo log已经满了,这个时候数据库停止进行数据库更新语句的执行,转而进行redo log日志同步到磁盘中log file.</p>
<h5 id="Data-Buffer"><a href="#Data-Buffer" class="headerlink" title="Data Buffer"></a>Data Buffer</h5><p>checkpoint是为了定期将db buffer的内容刷新到data file.当遇到内存不足、db buffer已满等情况时,需要将db buffer中的内容/部分内容(特别是脏数据)转储到data file中.在转储时,会记录checkpoint发生的‘时刻’.在故障回复时候,只需要redo/undo最近的一次checkpoint之后的操作.</p>
<h4 id="Bin-Log-Buffer-Log-Buffer"><a href="#Bin-Log-Buffer-Log-Buffer" class="headerlink" title="Bin Log Buffer(Log Buffer)"></a>Bin Log Buffer(Log Buffer)</h4><p>sync_binlog参数来控制数据库的binlog刷到磁盘上去<br>show variables like “sync_binlog”;</p>
<ul>
<li>I.设置为0,事务提交后,将二进制日志从缓冲写入磁盘,但是不进行刷新操作(fsync()),<font color ='red'>若操作系统宕机则会丢失部分二进制日志.</font></li>
<li>II.设置为1,每提交一次事务,存储引擎调用文件系统的fsync()刷新操作进行一次缓存的刷新,这种方式最安全,但性能较低.</li>
<li>III.设置为N时,每写N次操作,存储引擎调用文件系统的fsync()刷新操作进行一次缓存的刷新.</li>
</ul>
<p>默认,sync_binlog=0,表示MySQL不控制binlog的刷新,由文件系统自己控制它的缓存的刷新.这时候的性能是最好的,但是风险也是最大的.因为一旦系统Crash,在binlog_cache中的所有binlog信息都会被丢失.</p>
<p>如果sync_binlog&gt;0,表示每sync_binlog次事务提交,MySQL调用文件系统的刷新操作将缓存刷下去.最安全的就是sync_binlog=1了,表示每次事务提交,MySQL都会把binlog刷下去,是最安全但是性能损耗最大的设置.这样的话,在数据库所在的主机操作系统损坏或者突然掉电的情况下,系统才有可能丢失1个事务的数据.但是binlog虽然是顺序IO,但是设置sync_binlog=1,多个事务同时提交,同样很大的影响MySQL和IO性能.虽然可以通过group commit的补丁缓解,但是刷新的频率过高对IO的影响也非常大.对于高并发事务的系统来说,“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多.所以很多MySQL DBA设置的sync_binlog并不是最安全的1,而是100或者是0.这样牺牲一定的一致性,可以获得更高的并发和性能.</p>
<h3 id="数据库执行过程Log工作机制"><a href="#数据库执行过程Log工作机制" class="headerlink" title="数据库执行过程Log工作机制"></a>数据库执行过程Log工作机制</h3><p>1.MySQL Server 层的执行器调用 InnoDB 存储引擎的数据更新接口;<br>2.存储引擎更新 Data Buffer中的缓存页,<br>3.同时存储引擎记录一条 redo log 到 redo log buffer 中,并将该条 redo log 的状态标记为 prepare 状态;<br>4.接着存储引擎告诉执行器,可以提交事务了.执行器接到通知后,会写 binlog 日志,然后提交事务;<br>5.存储引擎接到提交事务的通知后,将 redo log 的日志状态标记为 commit 状态;<br>6.接着根据 innodb_flush_log_at_commit 参数的配置,决定是否将 redo log buffer 中的日志刷入到磁盘.</p>
<ul>
<li><font color='red'>为什么没有写data file,事务就提交了？</font><br>&emsp;&emsp;在数据库的世界里,数据从来都不重要,日志才是最重要的,有了日志就有了一切.因为data buffer中的数据会在合适的时间 由存储引擎写入到data file,如果在写入之前,数据库宕机了,根据落盘的redo日志,完全可以将事务更改的数据恢复.好了,看出日志的重要性了吧.先持久化日志的策略叫做Write Ahead Log,即预写日志.<br>&emsp;&emsp;关于事务提交时,redo log和binlog的写入顺序,为了保证主从复制时候的主从一致(当然也包括使用binlog进行基于时间点还原的情况),是要严格一致的,MySQL通过两阶段提交过程来完成事务的一致性的,也即redo log和binlog的一致性的,理论上是先写redo log,再写binlog,两个日志都提交成功(刷入磁盘),事务才算真正的完成.</li>
</ul>
<h4 id="如何保证数据不丢失"><a href="#如何保证数据不丢失" class="headerlink" title="如何保证数据不丢失"></a>如何保证数据不丢失</h4><p>　　将 redo log 日志标记为 prepare 状态和 commit 状态,这种做法称之为两阶段事务提交,它能保证事务在提交后,数据不丢失.为什么呢？redo log 在进行数据重做时,只有读到了 commit 标识,才会认为这条 redo log 日志是完整的,才会进行数据重做,否则会认为这个 redo log 日志不完整,不会进行数据重做.<br>　　例如,如果在 redo log 处于 prepare 状态后,Data Buffer中的缓存页(脏页)也还没来得及刷入到磁盘,写完 biglog 后就出现了宕机或者断电,此时提交的事务是失败的,那么在 MySQL 重启后,进行数据重做时,在 redo log 日志中由于该事务的 redo log 日志没有 commit 标识,那么就不会进行数据重做,磁盘上数据还是原来的数据,也就是事务没有提交,这符合我们的逻辑.<br>    <font color='red'>实际上要严格保证数据不丢失,必须得保证 innodb_flush_log_at_trx_commit 配置为 1</font><br>　　从效率上来说,0 的效率最高,因为不涉及到磁盘 IO,但是会丢失数据;而 1 的效率最低,但是最安全,不会丢失数据.2 的效率居中,会丢失数据.在实际的生产环境中,通常要求是的是“双 1 配置”,即将 innodb_flush_log_at_trx_commit 设置为 1,另外一个 1 指的是写 binlog 时,将 sync_binlog 设置为 1,这样 binlog 的数据就不会丢失.<font color='red'>在mysqld 服务崩溃或者服务器主机crash的情况下,binary log 只有可能丢失最多一个语句或者一个事务.但是鱼与熊掌不可兼得,双1,1 会导致频繁的io操作,因此该模式也是最慢的一种方式.</font>实际使用时,要考虑业务方对性能和安全性的需求,综合考量设置,两个参数.上图中是我们线上机器的参数.</p>
<h4 id="为什么引入Redo-Log这一机制"><a href="#为什么引入Redo-Log这一机制" class="headerlink" title="为什么引入Redo Log这一机制?"></a>为什么引入Redo Log这一机制?</h4><p>　　有人可能会想,既然生产环境一般建议将 innodb_flush_log_at_trx_commit 设置为 1,也就是说每次更新数据时,最终还是要将 redo log 写入到磁盘,也就是还是会发生一次磁盘 IO,而我为什么不直接停止使用 redo log,而在每次更新数据时,也不要直接更新内存了,直接将数据更新到磁盘,这样也是发生了一次磁盘 IO,何必引入 redo log 这一机制呢？<br>　　首先引入 redo log 机制是十分必要的.因为写 redo log 时,我们将 redo log 日志追加到文件末尾,虽然也是一次磁盘 IO,但是这是顺序写操作(不需要移动磁头);而对于直接将数据更新到磁盘,涉及到的操作是将 buffer pool 中缓存页写入到磁盘上的数据页上,由于涉及到寻找数据页在磁盘的哪个地方,这个操作发生的是随机写操作(需要移动磁头),相比于顺序写操作,磁盘的随机写操作性能消耗更大,花费的时间更长,因此 redo log 机制更优,能提升 MySQL 的性能.<br>　　从另一方面来讲,通常一次更新操作,我们往往只会涉及到修改几个字节的数据,而如果因为仅仅修改几个字节的数据,就将整个数据页写入到磁盘(无论是磁盘还是 buffer pool,他们管理数据的单位都是以页为单位),这个代价未免也太了(每个数据页默认是 16KB),而一条 redo log 日志的大小可能就只有几个字节,因此每次磁盘 IO 写入的数据量更小,那么耗时也会更短.综合来看,redo log 机制的引入,在提高 MySQL 性能的同时,也保证了数据的可靠性.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.MySQL 有四大特性:ACID,其中 D 指的是持久性(Durability),它的含义是 MySQL 的事务一旦提交,它对数据库的改变是持久性的,即数据不会丢失,那么 MySQL 究竟是如何实现的呢？</span><br><span class="line">  MySQL 通过 redo log 机制,以及两阶段事务提交(prepare 和 commit)来保证了事务的持久性.</span><br><span class="line">2.MySQL 数据库所在服务器宕机或者断电后,会出现数据丢失的问题吗？</span><br><span class="line">  如果不丢失,它又是如何来实现数据不丢失的呢？MySQL 中,只有当 innodb_flush_log_at_trx_commit 参数设置为 1 时,才不会出现数据丢失情况,当设置为 0 或者 2 时,可能会出现数据丢失.</span><br></pre></td></tr></table></figure>

<h2 id="Mysql数据存储原理计算"><a href="#Mysql数据存储原理计算" class="headerlink" title="Mysql数据存储原理计算"></a>Mysql数据存储原理计算</h2><p>存储单位: 磁盘以扇区为单位=512字节  系统文件文件=4K   Mysql以页为单位=16k</p>
<h3 id="计算B-树容量"><a href="#计算B-树容量" class="headerlink" title="计算B+树容量"></a>计算B+树容量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">求高度为H&#x3D;2时,计算B+树容量?</span><br><span class="line">1.设:存储一条数据大小&#x3D;1k,索引键值(默认int类型)&#x3D;8字节,指针(*P)&#x3D;6字节</span><br><span class="line">2.非叶子节点存储索引与指针数&#x3D;16*1024&#x2F;(8+6)&#x3D;1170   &#x2F;&#x2F;一页为单位可以包含指针数,指针向下指可以是指针,可以是数据</span><br><span class="line">3.叶子节点包含数据数量&#x3D;16K&#x2F;1K&#x3D;16     &#x2F;&#x2F;一页为单位可以存储16条数据</span><br><span class="line">4.H&#x3D;2时,可以包含数据&#x3D;1170(非叶子节点) * 16(叶子节点)&#x3D;18000;</span><br><span class="line">    H&#x3D;3时,可以包含数据&#x3D;1170(非叶子节点) * 1170(非叶子节点) * 16(叶子节点)&#x3D;2100w</span><br></pre></td></tr></table></figure>

<h3 id="索引结构-算法"><a href="#索引结构-算法" class="headerlink" title="索引结构(算法)"></a>索引结构(算法)</h3><h4 id="为什么选B-树做索引"><a href="#为什么选B-树做索引" class="headerlink" title="为什么选B+树做索引?"></a>为什么选B+树做索引?</h4><p><font color='red'>提高效率核心是减少访问I/O次数</font></p>
<ul>
<li>B+树:索引(O(log(n)))</li>
<li>B树:每个节点存储结构(真实数据+key(索引)+指针(<em>P)),相比B+树(key+(</em>p))存储结构,B树节点跟多导致树会更高,I/O次数也更多,效率更低;</li>
<li>二叉树(二叉查找树):每个节点下面只有两个字节点,时间复杂度为O(log2n),只有左右子树,相同数据量,二叉树高度比B+树高,I/0次数也就更多;</li>
<li>红黑叔:每一次写入数据都可能需要反转,变色,还可能要迭代会上一级节点向下遍历,来回操作访问I/O次数变多,效率降低;</li>
<li>hash索引: 仅仅能满足”=”,”IN”和”&lt;=&gt;”查询,不能使用范围查询(只有Memory存储引擎支持hash索引)</li>
</ul>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>普通索引是最基本的索引,它没有任何限制,值可以为空;仅加速查询;可以通过以下几种方式来创建或删除:<br>    CREATE INDEX index_name ON table(column(length))<br>    ALTER TABLE table_name ADD INDEX index_name ON (column(length))<br>    DROP INDEX index_name ON table</p>
<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一索引与普通索引类似,不同的就是:索引列的值必须唯一,但允许有空值;如果是组合索引,则列值的组合必须唯一;简单来说:唯一索引是加速查询 + 列值唯一(可以有null);以通过以下几种方式来创建:<br>    CREATE UNIQUE INDEX indexName ON table(column(length))<br>    ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引是一种特殊的唯一索引,一个表只能有一个主键,不允许有空值;简单来说:主键索引是加速查询 + 列值唯一(不可以有null)+ 表中只有一个<br>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );</p>
<h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><p>组合索引指在多个字段上创建的索引,只有在查询条件中使用了创建索引时的第一个字段,索引才会被使用;使用组合索引时遵循最左前缀集合;组合索引是多列值组成的一个索引,专门用于组合搜索,其效率大于索引合并<br>    ALTER TABLE <code>table</code> ADD INDEX name_city_age (name,city,age);</p>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引主要用来查找文本中的关键字,而不是直接与索引中的值相比较;fulltext索引跟其它索引大不相同,它更像是一个搜索引擎,而不是简单的where语句的参数匹配;fulltext索引配合match against操作使用,而不是一般的where语句加like;它可以在create table,alter table ,create index使用,不过目前只有char、varchar,text 列上可以创建全文索引;值得一提的是,在数据量较大时候,现将数据放入一个没有全局索引的表中,然后再用CREATE index创建fulltext索引,要比先为一张表建立fulltext然后再将数据写入的速度快很多;<br>    CREATE TABLE <code>table</code> (<code>id</code> int(11) NOT NULL AUTO_INCREMENT ,FULLTEXT (content));<br>    ALTER TABLE article ADD FULLTEXT index_content(content)<br>    CREATE FULLTEXT INDEX index_content ON article(content)</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础知识1</title>
    <url>/2020/12/02/Mysql-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/</url>
    <content><![CDATA[<h2 id="数据库事务四大特性"><a href="#数据库事务四大特性" class="headerlink" title="数据库事务四大特性"></a>数据库事务四大特性</h2><ul>
<li>原子性(Atomicity):一个事务执行过程中包含的各操作要么都成功,要么都不成功</li>
<li>隔离性(Isolation):一个事务的执行不能其它事务干扰;即一个事务内部的操作及使用的数据对其它并发事务是隔离的,并发执行的各个事务之间不能互相干扰</li>
<li>一致性(Durability):事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态;因此当数据库只包含成功事务提交的结果时,就说数据库处于一致性状态;如果数据库系统运行中发生故障,有些事务尚未完成就被迫中断,这些未完成事务对数据库所做的修改有一部分已写入物理数据库,这时数据库就处于一种不正确的状态,或者说是不一致的状态</li>
<li>持久性(Consistency):指一个事务一旦提交,它对数据库中的数据的改变就应该是永久性的;接下来的其它操作或故障不应该对其执行结果有任何影响</li>
</ul>
<h2 id="数据库事务传播机制"><a href="#数据库事务传播机制" class="headerlink" title="数据库事务传播机制"></a>数据库事务传播机制</h2><h3 id="事务传播机制-7种"><a href="#事务传播机制-7种" class="headerlink" title="事务传播机制(7种)"></a>事务传播机制(7种)</h3><h4 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED"></a>REQUIRED</h4><pre><code>@Transactional(propagation=Propagation.REQUIRED)
如果外层调用方法,本身有事务,那就加入该事务,没有就新建一个事务</code></pre><h4 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a>REQUIRES_NEW</h4><pre><code>@Transactional(propagation=Propagation.REQUIRES_NEW)
不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务</code></pre><h4 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a>SUPPORTS</h4><pre><code>@Transactional(propagation=Propagation.SUPPORTS)
如果外层调用方法存在事务,则加入该事务;如果外层调用方法没有事务,则以非事务运行</code></pre><h4 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a>NOT_SUPPORTED</h4><pre><code>@Transactional(propagation=Propagation.NOT_SUPPORTED)
以非事务运行,如果外层调用方法存在事务,则事务就挂起;</code></pre><h4 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a>MANDATORY</h4><pre><code>@Transactional(propagation=Propagation.MANDATORY)
必须以事务运行执行,否则抛出异常</code></pre><h4 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a>NEVER</h4><pre><code>@Transactional(propagation=Propagation.NEVER)
不支持事务,如果存在事务,则抛出异常(与Propagation.MANDATORY相反)</code></pre><h4 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a>NESTED</h4><pre><code>@Transactional(propagation=Propagation.NESTED)
如果当前存在事务,则在嵌套事务内执行,类似数据库事务保存点;如果当前没有事务,则执行与PROPAGATION_REQUIRED类似的操作;</code></pre><h3 id="传播机制嵌套事务回滚-3种-情况"><a href="#传播机制嵌套事务回滚-3种-情况" class="headerlink" title="传播机制嵌套事务回滚(3种)情况"></a>传播机制嵌套事务回滚(3种)情况</h3><p>假设一个在事A方法,A方法内部套着一个存在事务B方法</p>
<h4 id="A-B方法在同一个类"><a href="#A-B方法在同一个类" class="headerlink" title="A/B方法在同一个类"></a>A/B方法在同一个类</h4><pre><code>同一类内的调用,方法存在事务存在问题</code></pre><h4 id="A-B方法不在同一个类影响-如下3种"><a href="#A-B方法不在同一个类影响-如下3种" class="headerlink" title="A/B方法不在同一个类影响(如下3种)"></a>A/B方法不在同一个类影响(如下3种)</h4><pre><code>不同类内的方法事务调用存在问题:关键分析被调用事务使用与主动调用方式</code></pre><h5 id="REQUIRED-1"><a href="#REQUIRED-1" class="headerlink" title="REQUIRED"></a>REQUIRED</h5><pre><code>外层调用方法和内层调用方法,有异常一起回滚,没问题一起提交</code></pre><h5 id="REQUIRES-NEW-1"><a href="#REQUIRES-NEW-1" class="headerlink" title="REQUIRES_NEW"></a>REQUIRES_NEW</h5><pre><code>两个事务相互独立,互不干扰:外层的异常不会干扰内层,内层的异常不会干扰外层</code></pre><h5 id="NESTED-1"><a href="#NESTED-1" class="headerlink" title="NESTED"></a>NESTED</h5><pre><code>外层异常可以干扰内存回滚,内层异常不会干扰外层</code></pre><h2 id="事务隔离级别-4种"><a href="#事务隔离级别-4种" class="headerlink" title="事务隔离级别(4种)"></a>事务隔离级别(4种)</h2><h3 id="隔离级别解决的问题"><a href="#隔离级别解决的问题" class="headerlink" title="隔离级别解决的问题"></a>隔离级别解决的问题</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Read Committed</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>Serializable</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<h3 id="Read-Uncommitted-未提交读"><a href="#Read-Uncommitted-未提交读" class="headerlink" title="Read Uncommitted(未提交读)"></a>Read Uncommitted(未提交读)</h3><p>set session transaction isolation level read uncommitted;<br>查看隔离级别是否设置成功<br>select @@transaction_isolation (mysql版本 8.0 以后)<br>select @@tx_isolation (mysql版本 8.0 之前)</p>
<table>
<thead>
<tr>
<th>加锁表达</th>
<th>ReadUncommitted(未提交读)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/img/ReadUncommitted.png" alt="未提交读" title="未提交读"></td>
<td><font color='red'> A:启动事务,此时数据为初始状态<br>B:启动事务,更新数据,但不提交<br>A:再次读取数据,发现数据已经被修改了,这就是所谓的“脏读”<br>B:回滚事务<br>A:再次读数据,发现数据变回初始状态</font></td>
</tr>
</tbody></table>
<h3 id="Read-Committed-已提交读"><a href="#Read-Committed-已提交读" class="headerlink" title="Read Committed(已提交读)"></a>Read Committed(已提交读)</h3><p>set session transaction isolation level read committed;</p>
<table>
<thead>
<tr>
<th>加锁表达</th>
<th>ReadUncommitted(未提交读)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/img/ReadCommitted.png" alt="读取已提交" title="读取已提交"></td>
<td><font color='red'> A:启动事务,此时数据为初始状态<br>B:启动事务,更新数据,但不提交<br>A:再次读数据,发现数据未被修改<br>B:提交事务<br>A:再次读取数据,发现数据已发生变化,说明B提交的修改被事务中的A读到了,这就是所谓的“不可重复读”</font></td>
</tr>
</tbody></table>
<p>已提交读隔离级别解决了脏读的问题,但是出现了不可重复读的问题,即事务A在两次查询的数据不一致,因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录,但不要求可重复读。</p>
<h3 id="Repeatable-Read-可重复读"><a href="#Repeatable-Read-可重复读" class="headerlink" title="Repeatable Read(可重复读)"></a>Repeatable Read(可重复读)</h3><table>
<thead>
<tr>
<th>加锁表达</th>
<th>RepeatableRead(可重复读)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/img/RepeatableRead.png" alt="可重复读" title="可重复读"></td>
<td><font color='red'> A:启动事务,此时数据为初始状态<br>B:启动事务,更新数据,但不提交<br>A:再次读数据,发现数据未被修改<br>B:提交事务<br>A:再次读取数据,发现数据依然未发生变化,这说明这次可以重复读了<br>B:插入一条新的数据,并提交<br>A:再次读取数据,发现数据依然未发生变化,虽然可以重复读了,但是却发现读的不是最新数据,这就是所谓的“幻读”<br>A:提交本次事务,再次读取数据,发现读取正常了<br></font></td>
</tr>
</tbody></table>
<p>“幻读”指在一次事务里面,多次查询之后,结果集的个数不一致的情况叫做幻读。而多或者少的那一行被叫做幻行</p>
<ul>
<li>为什么要解决幻读？在高并发数据库系统中,需要保证事务与事务之间的隔离性,还有事务本身的一致性。</li>
</ul>
<h3 id="Serializable-可串行化"><a href="#Serializable-可串行化" class="headerlink" title="Serializable(可串行化)"></a>Serializable(可串行化)</h3><table>
<thead>
<tr>
<th>加锁表达</th>
<th>ReadUncommitted(未提交读)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/img/Serializable.png" alt="可串行化" title="可串行化"></td>
<td><font color='red'> A:启动事务,此时数据为初始状态<br>B:发现B此时进入了等待状态,原因是因为A的事务尚未提交,只能等待(此时,B可能会发生等待超时)<br>A:提交事务<br>B:发现插入成功</font></td>
</tr>
</tbody></table>
<p>serializable完全锁定字段,若一个事务来查询同一份数据就必须等待,直到前一个事务完成并解除锁定为止。是完整的隔离级别,会锁定对应的数据表格,因而会有效率的问题。</p>
<h2 id="MCVV-简化分析"><a href="#MCVV-简化分析" class="headerlink" title="MCVV(简化分析)"></a>MCVV(简化分析)</h2><p>MVCC即Multi-Version Concurrency Control(多版本并发控制), MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑,它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL,包括Oracle、PostgreSQL等其他数据库系统也都实现了MVCC,但各自的实现机制不尽相同,因为MVCC没有一个统一的实现标准。可以认为MVCC是行级锁的一个变种,但是它在很多情况下避免了加锁操作,因此开销更低。虽然实现机制有所不同,但大都实现了非阻塞的读操作,写操作也只锁定必要的行。Mysql只在READ COMMITTED和READ COMMITTED两个隔离级别下工作。其他两个隔离级别和MVCC不兼容, 因为READ UNCOMMITTED总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE则会对所有读取的行都加锁。Serializable(可串行化)隔离级别,虽然不会出错,但是效率实在太低了,不能并发;在MYSQL中,MyISAM使用的是表锁,InnoDB使用的是行锁.而InnoDB的事务分为四个隔离级别,<font color='red'>其中默认的隔离级别REPEATABLE READ需要两个不同的事务相互之间不能影响,而且还能支持并发,这点悲观锁是达不到的,所以REPEATABLE READ采用的就是乐观锁,而乐观锁的实现采用的就是MVCC控制并发(认为是行级锁一个变种);正是因为有了MVCC,才造就InnoDB强大的事务处理能力(注:MVCC实现非堵塞读操作,写操作也只锁定必要行数据,防止写-写冲突)</font></p>
<h3 id="Mysql的MVCC是解决了什么问题"><a href="#Mysql的MVCC是解决了什么问题" class="headerlink" title="Mysql的MVCC是解决了什么问题?"></a>Mysql的MVCC是解决了什么问题?</h3><p>MVCC解决了在REPEATABLE READ和READ COMMITTED两个隔离级别下读同一行和写同一行的多个事务的并发读数据问题,并没解决重复读与幻读,幻读;</p>
<h2 id="MVCC原理分析-入门简化版本"><a href="#MVCC原理分析-入门简化版本" class="headerlink" title="MVCC原理分析(入门简化版本)"></a>MVCC原理分析(入门简化版本)</h2><p><font color='red'>InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列分别是保存了行的创建时间(系统版本号)和行的删除时间(系统版本号)</font>这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID),每开始一个新的事务,系统版本号就会自动递增,事务开始时刻的系统版本号会作为事务的ID.下面看一下在REPEATABLE READ/READ COMMITTED隔离级别下,MVCC具体是如何操作的。</p>
<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><ul>
<li>insert操作:将新插入的行保存当前版本号为行版本号</li>
</ul>
<table>
<thead>
<tr>
<th>执行事务ID=1</th>
<th>执行事务ID=1结果</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction; <br>insert into yang values(NULL,’yang’);<br>insert into yang values(NULL,’long’);<br>insert into yang values(NULL,’fei’);<br>commit;</td>
<td><img src="/img/insert-Mvcc.png" alt="insert-Mvcc" title="insert-Mvcc"></td>
</tr>
</tbody></table>
<h3 id="SELECT操作"><a href="#SELECT操作" class="headerlink" title="SELECT操作"></a>SELECT操作</h3><ul>
<li>SELECT操作:InnoDB会根据以下两个条件检查每行记录:<br><font color='red'>1.InnoDB只会查找版本(DB_TRX_ID)早于当前事务版本的数据行(也就是,当前事务的系统版本号&gt;=记录里数据行的创建系统版本号),这样可以确保事务读取的行,要么是在事务开始前已经存在的,要么是事务自身插入或者修改过的.</li>
<li>2.当前事务版本号 &lt; 行的删除版本(DB_ROLL_PTR)或未定义(未更新过)(这可以确保事务读取到的行,在事务开始之前未被删除)<br>只有条件1、2同时满足的记录:记录里数据行的创建系统版本号 &lt;= 当前事务的系统版本号 &lt; 行的删除版本(DB_ROLL_PTR),才能返回作为查询结果</font></li>
</ul>
<p>假设在执行这个事务ID=2的第一行,这时有另一个事务ID=3往这个表里插入了一条数据; 第三个事务ID为3</p>
<table>
<thead>
<tr>
<th>执行事务ID=2</th>
<th>执行事务ID=3</th>
<th>执行事务ID=3结果</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction; <br>select * from yang; <br>select * from yang; <br>commit;</td>
<td>start transaction;<br>insert into yang values(NULL,’tian’);<br>commit;</td>
<td><img src="/img/select-mvcc1.png" alt="select-mvcc1" title="select-mvcc1"></td>
</tr>
</tbody></table>
<p>然后接着执行事务ID=2中的第二行,由于id=4的数据的创建时间(事务ID为3),执行当前事务的ID=2,而InnoDB只会查找事务ID小于等于当前事务ID的数据行,所以数据id=4行并不会在执行事务ID=2中的第二行时被检索出来,在事务ID=2中的两条select 语句检索出来的数据如下:</p>
<table>
<thead>
<tr>
<th>执行事务ID=2结果</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/img/select-mvcc2.png" alt="select-mvcc2" title="select-mvcc2"></td>
</tr>
</tbody></table>
<h3 id="DELETE操作"><a href="#DELETE操作" class="headerlink" title="DELETE操作"></a>DELETE操作</h3><ul>
<li>delete操作:将删除的行保存当前版本号为删除标识</li>
</ul>
<p>假设在执行这个事务ID=2的第一行,假设事务执行完事务ID=3后,接着又执行了事务ID=4; </p>
<table>
<thead>
<tr>
<th>执行事务ID=4</th>
<th>执行事务ID=4结果</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction; <br>delete from yang where id=1;<br>commit;</td>
<td><img src="/img/deleted-mvcc1.png" alt="deleted-mvcc1" title="deleted-mvcc1"></td>
</tr>
</tbody></table>
<p>接着执行事务ID=2的事务第二行,根据SELECT 检索条件可以知道,它会检索创建时间(创建事务的ID)小于当前事务ID的行和删除时间(删除事务的ID)大于当前事务的行,而id=4的行上面已经说过,而id=1的行由于删除时间(删除事务的ID)大于当前事务的ID,所以事务ID=2的第二行select * from yang也会把id=1的数据检索出来.所以,事务ID=2中的两条select 语句检索出来的数据都如下:</p>
<table>
<thead>
<tr>
<th>执行事务ID=2结果</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/img/deleted-mvcc2.png" alt="deleted-mvcc2" title="deleted-mvcc2"></td>
</tr>
</tbody></table>
<h3 id="UPDATE操作"><a href="#UPDATE操作" class="headerlink" title="UPDATE操作"></a>UPDATE操作</h3><ul>
<li>update操作:变为insert和delete操作的组合,insert的行保存当前版本号为行版本号,delete则保存当前版本号到原来的行作为删除标识</li>
</ul>
<p>假设在执行完事务ID=2的第一行时,其它用户执行了事务ID=3,ID=4,这时,又有一个用户对这张表执行了ID=5,UPDATE事务后,继续执行事务ID=2,根据select 语句的检索条件</p>
<table>
<thead>
<tr>
<th>执行事务ID=5</th>
<th>执行事务ID=5结果</th>
<th>执行事务ID=2结果</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction; <br>update yang set name=’Long’ where id=2;<br>commit;</td>
<td><img src="/img/update-mvcc1.png" alt="update-mvcc1" title="update-mvcc1"></td>
<td><img src="/img/update-mvcc2.png" alt="update-mvcc2" title="update-mvcc2"></td>
</tr>
</tbody></table>
<p>注:<font color='red'>由于旧数据并不真正的删除,所以必须对这些数据进行清理,innodb会开启一个后台purge线程执行清理工作,具体的规则是将删除版本号小于当前系统版本的行删除</font></p>
<h2 id="MCVV深入分析"><a href="#MCVV深入分析" class="headerlink" title="MCVV深入分析"></a>MCVV深入分析</h2><h3 id="Innodb中的隐藏列"><a href="#Innodb中的隐藏列" class="headerlink" title="Innodb中的隐藏列"></a>Innodb中的隐藏列</h3><p>InnoDB的内部实现中为每一行数据增加了三个隐藏列用于实现MVCC<br><img src="/img/innodb%E9%9A%90%E8%97%8F%E5%88%97.png" alt="innodb隐藏列" title="innodb隐藏列"></p>
<ul>
<li>DB_TRX_ID: 事务id(6byte),每处理一个事务,值自动加一;InnoDB中每个事务有一个唯一的事务ID叫做 transaction id。在事务开始时向InnoDB事务系统申请得到,是按申请顺序严格递增的.每行数据是有多个版本的,每次事务更新数据时都会生成一个新的数据版本,并且把transaction id赋值给这个数据行的DB_TRX_ID.</li>
<li>DB_ROLL_PT: 回滚指针(7byte),指向当前记录的ROLLBACK SEGMENT 的undolog记录,通过这个指针获得之前版本的数据。该行记录上所有旧版本在 undolog 中都通过链表的形式组织．</li>
<li>DB_ROW_ID:(隐含id,6byte,由innodb自动产生),我们可能听说过InnoDB下聚簇索引B+Tree的构造规则:如果声明了主键,InnoDB以用户指定的主键构建B+Tree,如果未声明主键,InnoDB 会自动生成一个隐藏主键,说的就是DB_ROW_ID。另外,每条记录的头信息(record header)里都有一个专门的bit(deleted_flag)来表示当前记录是否已经被删除</li>
</ul>
<h3 id="redo-log与undo-log"><a href="#redo-log与undo-log" class="headerlink" title="redo log与undo log"></a>redo log与undo log</h3><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log就是保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo log记录的SQL操作即可。当客户端执行每条SQL（更新语句）时，redo log会被首先写入log buffer；当客户端执行COMMIT命令时，log buffer中的内容会被视情况刷新到磁盘。redo log在磁盘上作为一个独立的文件存在，即Innodb的log文件。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>与redo log相反，undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。</p>
<h3 id="Undo-log工作过程"><a href="#Undo-log工作过程" class="headerlink" title="Undo log工作过程"></a>Undo log工作过程</h3><p>在不考虑redo log 的情况下利用undo log工作的简化过程为:<br><img src="/img/undolog.png" alt="undolog" title="undolog"><br>注:<font color='red'>undo log的持久化必须在在数据持久化之前,这样才能保证系统崩溃时,可以用undo log来回滚事务</font></p>
<h3 id="Undo-log链分析"><a href="#Undo-log链分析" class="headerlink" title="Undo log链分析"></a>Undo log链分析</h3><p><img src="/img/transaction_MVCC.png" alt="transaction_MVCC" title="transaction_MVCC"><br>图的UPDATE(即操作2)来举例Undo log链的构建(假设第一行数据DB_ROW_ID=1)：</p>
<ul>
<li>事务A对DB_ROW_ID=1这一行加排它锁</li>
<li>将修改行原本的值拷贝到Undo log中</li>
<li>修改目标值产生一个新版本,将DB_TRX_ID设为当前事务ID即100,将DB_ROLL_PT指向拷贝到Undo log中的旧版本记录</li>
<li>记录redo log, binlog</li>
</ul>
<p>最终生成的Undo log链如下图所示:<br><img src="/img/undo_log%E9%93%BE.png" alt="undo_log链" title="undo_log链"><br>相比与UPDATE,INSERT和DELETE都比较简单:</p>
<ul>
<li>INSERT: 产生一条新的记录,该记录的DB_TRX_ID为当前事务ID</li>
<li>DELETE: 特殊的UPDATE,在DB_TRX_ID上记录下当前事务的ID,同时将delete_flag设为true,在执行commit时才进行删除操作</li>
</ul>
<h3 id="ReadView-一致性视图-判断当前版本数据项是否可见"><a href="#ReadView-一致性视图-判断当前版本数据项是否可见" class="headerlink" title="ReadView(一致性视图)判断当前版本数据项是否可见"></a>ReadView(一致性视图)判断当前版本数据项是否可见</h3><p><img src="/img/MVCC%E7%AE%97%E6%B3%95.png" alt="判断当前版本数据项是否可见" title="判断当前版本数据项是否可见"><br>在innodb中,创建一个新事务的时候,innodb会将当前系统中的活跃事务列表(trx_sys-&gt;trx_list)创建一个副本(read view),副本中保存的是系统当前不应该被本事务看到的其他事务id列表。当用户在这个事务中要读取该行记录的时候,innodb会将该行当前的版本号与该read view进行比较。<br>具体的算法如下:</p>
<p>1.设该行的当前事务id为trx_id_0,read view中最早的事务id为trx_id_1, 最迟的事务id为trx_id_2。<br>2.如果trx_id_0&lt; trx_id_1的话,那么表明该行记录所在的事务已经在本次新事务创建之前就提交了,所以该行记录的当前值是可见的。跳到步骤6.<br>3.如果trx_id_0&gt;trx_id_2的话,那么表明该行记录所在的事务在本次新事务创建之后才开启,所以该行记录的当前值不可见.跳到步骤5。<br>4.如果trx_id_1&lt;=trx_id_0&lt;=trx_id_2, 那么表明该行记录所在事务在本次新事务创建的时候处于活动状态,从trx_id_1到trx_id_2进行遍历,如果trx_id_0等于他们之中的某个事务id的话,那么不可见。跳到步骤5.<br>5.从该行记录的DB_ROLL_PTR指针所指向的回滚段中取出最新的undo-log的版本号,将它赋值该trx_id_0,然后跳到步骤2.<br>6.将该可见行的值返回</p>
<h4 id="ReadView-一致性视图"><a href="#ReadView-一致性视图" class="headerlink" title="ReadView(一致性视图)"></a>ReadView(一致性视图)</h4><p>InnoDB为每一个事务构造了一个数组m_ids用于保存快照读生成瞬间当前所有活跃事务(开始但未提交事务)的ID,将数组中事务ID最小值记为低水位m_up_limit_id,当前系统中已创建事务ID最大值+1记为高水位m_low_limit_id,构成如图所示:<br><img src="/img/ReadView.png" alt="ReadView" title="ReadView"></p>
<p>一致性视图的流程如下:</p>
<ul>
<li>当查询发生时根据以上条件生成ReadView,该查询操作遍历Undo log链,根据当前被访问版本(可以理解为Undo log链中每一个记录即一个版本,遍历都是从最新版本向老版本遍历)的DB_TRX_ID,如果DB_TRX_ID小于m_up_limit_id,则该版本在ReadView生成前就已经完成提交,该版本可以被当前事务访问。DB_TRX_ID在绿色范围内的可以被访问</li>
<li>若被访问版本的DB_TRX_ID大于m_up_limit_id,说明该版本在ReadView生成之后才生成,因此该版本不能被访问,根据当前版本指向上一版本的指针DB_ROLL_PT访问上一个版本,继续判断。DB_TRX_ID在蓝色范围内的都不允许被访问</li>
<li>若被访问版本的DB_TRX_ID在[m_up_limit_id, m_low_limit_id)区间内,则判断DB_TRX_ID是否等于当前事务ID,等于则证明是当前事务做的修改,可以被访问,否则不可被访问, 继续向上寻找。只有DB_TRX_ID等于当前事务ID才允许访问橙色范围内的版本</li>
<li>最后,还要确保满足以上要求的可访问版本的数据的delete_flag不为true,否则查询到的就会是删除的数据。<br>以上总结就是只有当前事务修改的未commit版本和所有已提交事务版本允许被访问</li>
</ul>
<h4 id="Read-Committed与Repeatable-Read的一致性视图-ReadView-区别"><a href="#Read-Committed与Repeatable-Read的一致性视图-ReadView-区别" class="headerlink" title="Read Committed与Repeatable Read的一致性视图(ReadView)区别"></a>Read Committed与Repeatable Read的一致性视图(ReadView)区别</h4><p>READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是生成ReadView的时机不同</p>
<h4 id="Read-Committed的ReadView"><a href="#Read-Committed的ReadView" class="headerlink" title="Read Committed的ReadView"></a>Read Committed的ReadView</h4><p>在read committed级别下,readview会在事务中的<font color='red'>每一个SELECT语句查询发送前生成(也可以在声明事务时显式声明START TRANSACTION WITH CONSISTENT SNAPSHOT)。</font>因此每次SELECT都可以获取到当前已提交事务和自己修改的最新版本。</p>
<h4 id="Repeatable-Read的ReadView"><a href="#Repeatable-Read的ReadView" class="headerlink" title="Repeatable Read的ReadView"></a>Repeatable Read的ReadView</h4><p>在repeatable read级别下,<font color='red'>每个事务只会在第一个SELECT语句查询发送前或显式声明处生成,其他查询操作都会基于这个ReadView。</font>这样就保证了一个事务中的多次查询结果都是相同的,因为他们都是基于同一个ReadView下进行MVCC机制的查询操作。</p>
<h3 id="快照读-snapshot-read-与当前读-current-read"><a href="#快照读-snapshot-read-与当前读-current-read" class="headerlink" title="快照读(snapshot read)与当前读(current read)"></a>快照读(snapshot read)与当前读(current read)</h3><p>MySQL数据库支持两种读操作快照读(snapshot read)和当前读(current read)解决幻读</p>
<h4 id="快照读-snapshot-read"><a href="#快照读-snapshot-read" class="headerlink" title="快照读(snapshot read)"></a>快照读(snapshot read)</h4><ul>
<li><font color='red'>所有的快照读都依赖MVCC机制,读取特定的历史版本数据;<font color='red'>简单的select不加X锁/S锁操作,属于快照读(当然也有例外select加锁,如select … lock in share mode, select … for update)</font></li>
<li>作用:在快照读读情况下,mysql通过mvcc来避免幻读;innodb的默认事务隔离级别是rr(可重复读),它的实现技术是mvcc(MVCC只在读提交可重复读两种隔离级别下工作),基于版本的控制协议。快照读不仅可以保证innodb的可重复读,而且可以防止幻读。但是它防止的是快照读,也就是读取的数据虽然是一致的,但是数据是历史数据</font></li>
</ul>
<p><img src="/img/snapshot-read.png" alt="snapshot-read" title="snapshot-read"></p>
<h4 id="当前读-current-read"><a href="#当前读-current-read" class="headerlink" title="当前读(current read)"></a>当前读(current read)</h4><p>MySQL InnoDB的可重复读并不保证避免幻读,当前读情况下,需要使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。</p>
<ul>
<li><font color='red'>特殊的读操作(加锁读操作),读取当前最新的数据;insert/update/delete操作,需要加锁(X锁/S锁:select … lock in share mode, select … for update),属于当前读</li>
<li>作用:如何做到保证数据是一致的(也就是一个事务,其内部读取对应某一个数据的时候,数据都是一样的),同时读取的数据是最新的数据。mysql innodb提供了Next-Key Lock机制来避免幻读;这是由行锁和Gap锁组成,在使用范围条件检索并锁定记录时,InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入,这往往会造成严重的锁等待。Gap锁在InnoDB的唯一作用就是防止其它事务的插入操作,以此来达到防止幻读的发生,所以间隙锁不分什么共享锁与排它锁</font></li>
</ul>
<p><img src="/img/current-read.png" alt="current-read" title="current-read"></p>
<h4 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h4><p>比方说现在系统里有两个id分别为100、200的事务在执行:</p>
<table>
<thead>
<tr>
<th>Transaction 100</th>
<th>Transaction 200</th>
</tr>
</thead>
<tbody><tr>
<td>BEGIN;<br>UPDATE t SET c = ‘关羽’ WHERE id = 1;<br>UPDATE t SET c = ‘张飞’ WHERE id = 1;</td>
<td>BEGIN;<br>操作(更新了一些别的表的记录)<br>UPDATE t SET c = ‘赵云’ WHERE id = 1;<br>UPDATE t SET c = ‘诸葛亮’ WHERE id = 1;</td>
</tr>
</tbody></table>
<p><img src="/img/%E5%88%86%E6%9E%90undo_log1.png" alt="分析undo_log1" title="分析undo_log1"></p>
<h5 id="使用READ-COMMITTED隔离级别的事务"><a href="#使用READ-COMMITTED隔离级别的事务" class="headerlink" title="使用READ COMMITTED隔离级别的事务"></a>使用READ COMMITTED隔离级别的事务</h5><pre><code>BEGIN;
//SELECT1：Transaction 100、200未提交
SELECT * FROM t WHERE id = 1; # 得到的列c的值为&apos;刘备&apos;</code></pre><p>这个SELECT1的执行过程如下:</p>
<ul>
<li>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li>
<li>下一个版本的列c的内容是’关羽’，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列c的内容是’刘备’，该版本的trx_id值为80，小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’刘备’的记录。</li>
</ul>
<p>之后，我们把事务id为100的事务提交一下，就像这样：<br><img src="/img/%E5%88%86%E6%9E%90undo_log2.png" alt="分析undo_log2" title="分析undo_log2"></p>
<h5 id="REPEATABLE-READ隔离级别的事务"><a href="#REPEATABLE-READ隔离级别的事务" class="headerlink" title="REPEATABLE READ隔离级别的事务"></a>REPEATABLE READ隔离级别的事务</h5><pre><code>//使用REPEATABLE READ隔离级别的事务中继续查找这个id为1的记录:
BEGIN;
//SELECT1：Transaction 100、200均未提交
SELECT * FROM t WHERE id = 1; # 得到的列c的值为&apos;刘备&apos;
//SELECT2：Transaction 100提交，Transaction 200未提交
SELECT * FROM t WHERE id = 1; # 得到的列c的值仍为&apos;刘备&apos;</code></pre><p>这个SELECT2的执行过程如下：</p>
<ul>
<li>因为之前已经生成过ReadView了，所以此时直接复用之前的ReadView，之前的ReadView中的m_ids列表就是[100, 200]。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li>
<li>下一个版本的列c的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列c的内容是’张飞’，该版本的trx_id值为100，而m_ids列表中是包含值为100的事务id的，所以该版本也不符合要求，同理下一个列c的内容是’关羽’的版本也不符合要求。继续跳到下一个版本。</li>
<li>下一个版本的列c的内容是’刘备’，该版本的trx_id值为80，80小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’刘备’的记录。</li>
</ul>
<p>也就是说两次SELECT查询得到的结果是重复的，记录的列c值都是’刘备’，这就是可重复读的含义。如果我们之后再把事务id为200的记录提交了，之后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个id为1的记录，得到的结果还是’刘备’，具体执行过程自己分析一下。</p>
<h5 id="MySQL-InnoDB-引擎-RR-隔离级别是否解决了幻读"><a href="#MySQL-InnoDB-引擎-RR-隔离级别是否解决了幻读" class="headerlink" title="MySQL InnoDB 引擎 RR 隔离级别是否解决了幻读"></a>MySQL InnoDB 引擎 RR 隔离级别是否解决了幻读</h5><p>Mysql官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读。<br>a事务先select，b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意dml操作），a事务再select出来的结果在MVCC下还和第一次select一样，接着a事务不加条件地update，这个update会作用在所有行上（包括b事务新加的），a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了，实测在RR级别下确实如此。</p>
<ul>
<li>T1 select 之后 update，会将 T2 中 insert 的数据一起更新，那么认为多出来一行，所以防不住幻读。但是其实这种方式是一种 bad case<br><img src="/img/%E5%BF%AB%E7%85%A7%E8%AF%BB%E8%BD%AC%E5%BD%93%E5%89%8D%E8%AF%BB.png" alt="快照读转当前读" title="快照读转当前读"></li>
</ul>
<h3 id="Mysql的MVCC实现原理的深刻反思"><a href="#Mysql的MVCC实现原理的深刻反思" class="headerlink" title="Mysql的MVCC实现原理的深刻反思"></a>Mysql的MVCC实现原理的深刻反思</h3><h4 id="理想MVCC有下面几个特点"><a href="#理想MVCC有下面几个特点" class="headerlink" title="理想MVCC有下面几个特点"></a>理想MVCC有下面几个特点</h4><ul>
<li>每行数据都存在一个版本，每次数据更新时都更新该版本</li>
<li>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</li>
<li>保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)</li>
<li>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功</li>
</ul>
<h4 id="InnoDB实现MVCC的方式是"><a href="#InnoDB实现MVCC的方式是" class="headerlink" title="InnoDB实现MVCC的方式是:"></a>InnoDB实现MVCC的方式是:</h4><ul>
<li>事务以排他锁的形式修改原始数据</li>
<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>
<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>
</ul>
<h4 id="二者最本质的区别是-当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？"><a href="#二者最本质的区别是-当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？" class="headerlink" title="二者最本质的区别是: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？"></a>二者最本质的区别是: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？</h4><p>　　Innodb的实现真算不上MVCC,因为并没有实现核心的多版本共存,undo log中的内容只是串行化的结果,记录了多个事务的过程,不属于多版本共存。但理想的MVCC是难以实现的,当事务仅修改一行记录使用理想的MVCC模式是没有问题的,可以通过比较版本号进行回滚;但当事务影响到多行数据时,理想的MVCC据无能为力了。<br>　　比如,如果Transaciton1执行理想的MVCC,修改Row1成功,而修改Row2失败,此时需要回滚Row1,但因为Row1没有被锁定,其数据可能又被Transaction2所修改,如果此时回滚Row1的内容,则会破坏Transaction2的修改结果,导致Transaction2违反ACID。<br>    理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据,但为了保证其一致性,与修改两个分布式系统中的数据并无区别,<br>而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定,乐观锁的本质是消除锁定,二者矛盾,故理想的MVCC难以真正在实际中被应<br>用,Innodb只是借了MVCC这个名字,提供了读的非阻塞而已</p>
<p><img src="/img/mvcc%E6%80%BB%E7%BB%93.png" alt="mvcc总结" title="mvcc总结"></p>
<h2 id="数据库锁粒度"><a href="#数据库锁粒度" class="headerlink" title="数据库锁粒度"></a>数据库锁粒度</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>　　乐观锁大多是基于数据版本记录机制实现，一般是给数据库表增加一个”version”字段。读取数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。不需要对数据加锁也能取准确数据;如MVCC;</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><pre><code>悲观锁依靠数据库提供的锁机制实现。MySQL中的共享锁和排它锁都是悲观锁。数据库的增删改操作默认都会加排他锁，而查询不会加任何锁</code></pre><h3 id="X锁-写锁-排他锁-Exclusive-Lock"><a href="#X锁-写锁-排他锁-Exclusive-Lock" class="headerlink" title="X锁/写锁/排他锁(Exclusive Lock)"></a>X锁/写锁/排他锁(Exclusive Lock)</h3><p>　　….for update 是加写锁,一行数据上只能有一个写锁,读写互斥;排它锁指的就是对于多个不同的事务，对同一个资源只能有一把锁。对某一资源加排它锁，自身可以进行增删改查，其他人无法进行加锁操作，更无法进行增删改操作。</p>
<h3 id="S锁-读锁-共享锁-Share-lock"><a href="#S锁-读锁-共享锁-Share-lock" class="headerlink" title="S锁/读锁/共享锁(Share lock)"></a>S锁/读锁/共享锁(Share lock)</h3><p>　　….lock in share mode 是加读锁,一行数据上可以加多个读锁,读写互斥;共享锁指的就是对于多个不同的事务，对于一个资源共享同一个锁。对某一资源加共享锁，自身可可读该资源，其他人也可以读该资源(也可以再加共享锁，即共享锁共享多个内存)，但无法修改。要想修改就必须等所有共享锁都释放完之后。</p>
<h3 id="表级锁-锁变表"><a href="#表级锁-锁变表" class="headerlink" title="表级锁:锁变表"></a>表级锁:锁变表</h3><p>　　表锁就是对一张表进行加锁，操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。</p>
<h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><pre><code>行锁(Record Lock)与间隙锁(Gap Lock)组合起来用就叫做Next-Key Lock</code></pre><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>　　行锁就是给一行数据进行加锁，操作对象是数据表中的一行（共享锁和排他锁可能是行锁也可能是表锁，取决于对数据加锁的范围，是一行还是整个表）。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。</p>
<h4 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁(Gap Lock)"></a>间隙锁(Gap Lock)</h4><p> 　　在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题。锁加在不存在的空闲空间,可以是两个索引记录之间(1 &lt; X &lt; 3&gt;&gt;),也可能是第一个索引记录之前(X &lt; 1)或最后一个索引之后的空间(X &gt; 1)</p>
<pre><code>举例来说,假如user表中只有101条记录,其empid的值分别是 1,2,...,100,101,下面的SQL：
select * from  user where user_id &gt; 100 for update;
是一个范围条件的检索,InnoDB不仅会对符合条件的user_id值为101的记录加锁,也会对user_id大于101(这些记录并不存在)的“间隙”加锁。
产生幻读的原因是,行锁只能锁住行,但是新插入记录这个动作,要更新的是记录之间的“间隙”。因此,为了解决幻读问题,InnoDB 只好引入新的锁,也就是间隙锁</code></pre><h4 id="Record-lock"><a href="#Record-lock" class="headerlink" title="Record lock"></a>Record lock</h4><p>单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。</p>
<h4 id="Next-Key-Lock-1"><a href="#Next-Key-Lock-1" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>行锁和间隙锁组合起来就叫Next-Key Lock</p>
<p>当前读、快照读，record lock(记录锁)、gap lock(间隙锁)、next-key lock;<br>本来只有串读隔离级别才可以解决幻读问题，而实际上由于快照读的特性使可重复读也解决了幻读问题。<br>当前读是因为innodb默认为它加入了间隙锁，防止在事务期间对相关数据集插入记录，从而避免出现幻读。<br>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。如果需要实时显示数据，还是需要通过手动加锁来实现。这个时候会使用next-key技术来实现。<br>在mysql中，提供了两种事务隔离技术，第一个是mvcc，第二个是next-key技术。这个在使用不同的语句的时候可以动态选择。不加lock inshare mode之类的快照读就使用mvcc。否则 当前读使用next-key。mvcc的优势是不加锁，并发性高。缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Flyway</title>
    <url>/2022/01/06/PluginTool-Flyway/</url>
    <content><![CDATA[<h2 id="Flyway使用背景"><a href="#Flyway使用背景" class="headerlink" title="Flyway使用背景"></a>Flyway使用背景</h2><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p><img src="/flyway/1.png" alt="1.png" title="1.png"></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p><img src="/flyway/2.png" alt="2.png" title="2.png"></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/flyway/3.png" alt="3.png" title="3.png"></p>
<h3 id="迁移脚本的命名规则"><a href="#迁移脚本的命名规则" class="headerlink" title="迁移脚本的命名规则"></a>迁移脚本的命名规则</h3><p><img src="/flyway/4.png" alt="4.png" title="4.png"></p>
<h3 id="实现路径方式"><a href="#实现路径方式" class="headerlink" title="实现路径方式"></a>实现路径方式</h3><p><img src="/flyway/5.png" alt="5.png" title="5.png"></p>
<h4 id="API的方式"><a href="#API的方式" class="headerlink" title="API的方式"></a>API的方式</h4><p><img src="/flyway/6.png" alt="6.png" title="6.png"></p>
<p>Java API方式写迁移功能<br><img src="/flyway/7.png" alt="7.png" title="7.png"></p>
<h4 id="springboot方式"><a href="#springboot方式" class="headerlink" title="springboot方式"></a>springboot方式</h4><p><img src="/flyway/8.png" alt="8.png" title="8.png"></p>
<h2 id="SprintBoot-Flyway具体使用"><a href="#SprintBoot-Flyway具体使用" class="headerlink" title="SprintBoot Flyway具体使用"></a>SprintBoot Flyway具体使用</h2><h3 id="引入flyway的依赖："><a href="#引入flyway的依赖：" class="headerlink" title="引入flyway的依赖："></a>引入flyway的依赖：</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
    &lt;version&gt;5.0.3&lt;/version&gt;</code></pre><p>　　</dependency></p>
<h3 id="springboot-2-xx-使用5版本以后"><a href="#springboot-2-xx-使用5版本以后" class="headerlink" title="springboot 2.xx,使用5版本以后"></a>springboot 2.xx,使用5版本以后</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
    &lt;version&gt;5.2.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre><h3 id="在classpath下新建-db-migration文件夹，并创建sql脚本文件："><a href="#在classpath下新建-db-migration文件夹，并创建sql脚本文件：" class="headerlink" title="在classpath下新建/db/migration文件夹，并创建sql脚本文件："></a>在classpath下新建/db/migration文件夹，并创建sql脚本文件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person (</span><br><span class="line">    id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    first varchar(100) NOT NULL,</span><br><span class="line">    last varchar(100) NOT NULL,</span><br><span class="line">    dateofbirth DATE DEFAULT null,</span><br><span class="line">    placeofbirth varchar(100) not null,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<h3 id="Flyway配置"><a href="#Flyway配置" class="headerlink" title="Flyway配置"></a>Flyway配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设定需要flywary迁移的schema，大小写敏感，默认为连接默认的schema</span><br><span class="line">spring.flyway.schemas</span><br><span class="line">&#x2F;&#x2F;是否开启flywary，默认true</span><br><span class="line">spring.flyway.enabled</span><br><span class="line">&#x2F;&#x2F;设置迁移时的编码，默认UTF-8</span><br><span class="line">spring.flyway.encoding</span><br><span class="line">&#x2F;&#x2F;迁移脚本的位置，默认db&#x2F;migration</span><br><span class="line">spring.flyway.locations</span><br><span class="line">&#x2F;&#x2F;目标数据库的密码</span><br><span class="line">spring.flyway.password</span><br><span class="line">&#x2F;&#x2F;使用的元数据表名，默认为schema_version</span><br><span class="line">spring.flyway.tableflyway</span><br><span class="line">&#x2F;&#x2F;迁移时使用的JDBC URL，如果没有指定的话，将使用配置的主数据源</span><br><span class="line">spring.flyway.url</span><br><span class="line">&#x2F;&#x2F;迁移数据库的用户名</span><br><span class="line">spring.flyway.user</span><br><span class="line">&#x2F;&#x2F;对执行迁移时基准版本的描述</span><br><span class="line">spring.flyway.baseline-description</span><br><span class="line">&#x2F;&#x2F;当迁移时发现目标schema非空，而且带有没有元数据的表时，是否自动执行基准迁移，默认false</span><br><span class="line">spring.flyway.baseline-on-migrate</span><br><span class="line">&#x2F;&#x2F;开始执行基准迁移时对现有的schema的版本打标签，默认值为1</span><br><span class="line">spring.flyway.baseline-version</span><br><span class="line">&#x2F;&#x2F;检查迁移脚本的位置是否存在，默认false</span><br><span class="line">spring.flyway.check-location</span><br><span class="line">&#x2F;&#x2F;当发现校验错误时是否自动调用clean，默认false</span><br><span class="line">spring.flyway.clean-on-validation-error</span><br><span class="line">&#x2F;&#x2F;当读取元数据表时是否忽略错误的迁移，默认false</span><br><span class="line">spring.flyway.ignore-failed-future-migration</span><br><span class="line">&#x2F;&#x2F;当初始化好连接时要执行的SQL</span><br><span class="line">spring.flyway.init-sqls</span><br><span class="line">&#x2F;&#x2F;是否允许无序的迁移，默认false</span><br><span class="line">spring.flyway.out-of-order</span><br><span class="line">&#x2F;&#x2F;设置每个placeholder的前缀，默认$&#123;</span><br><span class="line">spring.flyway.placeholder-prefix</span><br><span class="line">&#x2F;&#x2F;是否要被替换，默认true</span><br><span class="line">spring.flyway.placeholder-replacementplaceholders</span><br><span class="line">&#x2F;&#x2F;设置每个placeholder的后缀，默认&#125;</span><br><span class="line">spring.flyway.placeholder-suffix</span><br><span class="line">&#x2F;&#x2F;设置placeholder的value</span><br><span class="line">spring.flyway.placeholders.[placeholder name]</span><br><span class="line">&#x2F;&#x2F;迁移文件的前缀，默认为V</span><br><span class="line">spring.flyway.sql-migration-prefix</span><br><span class="line">&#x2F;&#x2F;迁移脚本的文件名分隔符，默认__</span><br><span class="line">spring.flyway.sql-migration-separator</span><br><span class="line">&#x2F;&#x2F;迁移脚本的后缀，默认为.sql</span><br><span class="line">spring.flyway.sql-migration-suffix</span><br><span class="line">&#x2F;&#x2F;迁移时使用的目标版本，默认为latest version</span><br><span class="line">spring.flyway.target</span><br><span class="line">&#x2F;&#x2F;迁移时是否校验，默认为true</span><br><span class="line">spring.flyway.validate-on-migrate</span><br></pre></td></tr></table></figure>

<h3 id="mvn命令格式"><a href="#mvn命令格式" class="headerlink" title="mvn命令格式"></a>mvn命令格式</h3><p>mvn flyway:{flyway-command}</p>
<h4 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h4><p>mvn flyway:migrate<br>这个命令会搜索默认的脚本目录，检测并根据结果选择执行升级脚本。</p>
<h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><p>mvn flyway:clean<br>这个命令会清除指定schema下全部的对象，包括table、view、triggers…，让schema变成空的状态。</p>
<h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>mvn flyway:info<br>这个命令显示指定schema的升级状态，当前的数据库的版本信息。</p>
<h4 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h4><p>mvn flyway:validate<br>这个命令用于校验，范围包括已升级的脚本是否更名，已升级的脚本内容是否修改。全部针对已升级的脚本进行的改动都会致使校验失败。<br>执行migrate会自动进行校验，若是失败将不会作任何的migrate。<br>flyway但愿用户提供的脚本是稳定的，以避免形成额外的复杂性和混乱。</p>
<h4 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h4><p>mvn flyway:baseline<br>若是用户从一个已有的数据库导出脚本，做为flyway的升级脚本。已存在的数据库是不须要升级的。baseline用于将当前数据库标记为baseline，并记录version为1。这表示用户继续执行migrate命令时，会自动跳过V1版本对应的脚本。而对于空的数据库，由于没有执行baseline，因此能够正常的执行V1版本对应的脚本。</p>
<h4 id="Repair"><a href="#Repair" class="headerlink" title="Repair"></a>Repair</h4><p>mvn flyway:repair<br>修复命令尽量不要使用, 修复场景有: 1. 移除失败的 migration 记录. 2.已经应用的 SQL 脚本被修改, 我们想重新应用该 SQL 脚本.<br>它主要做了两件事，移除所有失败的迁移（升级），重置校验和。手动修改flyway自动生成的baseline记录，将版本号改成其余的版本号，将自动跳过该版本及更早的版本。</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Branch Guidelines</title>
    <url>/2021/01/13/PluginTool-Git%20Branch%20Guidelines/</url>
    <content><![CDATA[<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p><img src="/git/001.png" alt="001" title="001"></p>
<h3 id="Master-主分支"><a href="#Master-主分支" class="headerlink" title="Master(主分支)"></a>Master(主分支)</h3><ol>
<li>用于部署生产环境(PROD);</li>
<li>保护分支，禁止PUSH,只能merge;</li>
<li>输入分支：release、hotfix/yyyyMMdd;</li>
</ol>
<h3 id="Hotfix-yyyyMMdd-线上BUG修复分支"><a href="#Hotfix-yyyyMMdd-线上BUG修复分支" class="headerlink" title="Hotfix/yyyyMMdd(线上BUG修复分支)"></a>Hotfix/yyyyMMdd(线上BUG修复分支)</h3><ol>
<li>基于master分支新建;</li>
<li>修复上线后，合并回master和develop分支;</li>
<li>修复发布后删除;</li>
</ol>
<h3 id="Release-预发布分支"><a href="#Release-预发布分支" class="headerlink" title="Release(预发布分支)"></a>Release(预发布分支)</h3><ol>
<li>用于部署预发布环境(UAT);</li>
<li>保护分支，禁止PUSH,只能merge;</li>
<li>输入分支：Feature/sprintXX;</li>
</ol>
<h3 id="Develop-开发分支"><a href="#Develop-开发分支" class="headerlink" title="Develop(开发分支)"></a>Develop(开发分支)</h3><ol>
<li>包含最新的功能代码，新建feature/sprintXX 分支的基础;</li>
<li>保护分支，禁止PUSH,只能merge;</li>
<li>输入分支：hotfix/yyyyMMdd、test/sprintXX;</li>
</ol>
<h3 id="Feature-sprintXX-功能分支"><a href="#Feature-sprintXX-功能分支" class="headerlink" title="Feature/sprintXX(功能分支)"></a>Feature/sprintXX(功能分支)</h3><ol>
<li>用于版本迭代(没有拆分到各个feature，一个迭代一个feature/sprintXX)，部署开发环境联调(DEV);</li>
<li>基于develop新建;</li>
<li>功能发布后删除;</li>
</ol>
<h3 id="Test-SprintXX-功能测试分支"><a href="#Test-SprintXX-功能测试分支" class="headerlink" title="Test/SprintXX(功能测试分支)"></a>Test/SprintXX(功能测试分支)</h3><ol>
<li>用于功能迭代的测试，部署测试环境(FAT);</li>
<li>输入分支：feature/sprintXX;</li>
<li>功能发布后删除;</li>
</ol>
<h2 id="分支操作规范"><a href="#分支操作规范" class="headerlink" title="分支操作规范"></a>分支操作规范</h2><h3 id="Feature-SprintXX分支下使用rebase"><a href="#Feature-SprintXX分支下使用rebase" class="headerlink" title="Feature/SprintXX分支下使用rebase"></a>Feature/SprintXX分支下使用rebase</h3><p>解决提交路线图清晰问题，git pull默认是merge操作，可以使用如下命令进行rebase</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull --rebase</span><br><span class="line">&#x2F;&#x2F;也可以做全局配置</span><br><span class="line">git config --global pull.rebase true</span><br><span class="line">git config --global branch.autoSetupRebase always</span><br></pre></td></tr></table></figure>

<h3 id="Master-Release-Dev分支合并使用-no-ff"><a href="#Master-Release-Dev分支合并使用-no-ff" class="headerlink" title="Master/Release/Dev分支合并使用 no-ff"></a>Master/Release/Dev分支合并使用 no-ff</h3><p>在merge 到Master,Dev分支，解决fast-forward 合并的路线图问题，这种 merge 的结果就是一条直线，无法明确看到切出一个新的 feature 分支，但是使用 no-ff就可以明显看出新feature分支的合并路线图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;合并sprint01 到 develop 分支</span><br><span class="line">git merge --no-ff feature&#x2F;sprint01</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令总结</title>
    <url>/2021/06/07/PluginTool-Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Git-升级最新版本命令"><a href="#Git-升级最新版本命令" class="headerlink" title="Git 升级最新版本命令"></a>Git 升级最新版本命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看自己的git版本:  git –version</span><br><span class="line">2.17.1之前的版本：git update</span><br><span class="line">2.17.1之后的版本：git update-git-for-windows</span><br></pre></td></tr></table></figure>

<h2 id="Git-查看提交记录详情"><a href="#Git-查看提交记录详情" class="headerlink" title="Git 查看提交记录详情"></a>Git 查看提交记录详情</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看所有的commit提交记录：git log</span><br><span class="line">查看所有的commit提交树形结构记录:git log --oneline --decorate --color --graph</span><br><span class="line">查看最新的commit：git show</span><br><span class="line">查看指定commit hashID的所有修改：git show &lt;commitId&gt;</span><br><span class="line">查看某次commit中具体某个文件的修改：git show &lt;commitId&gt; &lt;filename&gt;</span><br><span class="line">查看命令历史，以便确定要回到未来的哪个版本: git reflog</span><br></pre></td></tr></table></figure>

<h2 id="merge操作命令"><a href="#merge操作命令" class="headerlink" title="merge操作命令"></a>merge操作命令</h2><ul>
<li>git merge –abort : 将会抛弃合并过程并且尝试重建合并前的状态<br>注:当合并开始时如果存在未commit的文件，git merge –abort在某些情况下将无法重现合并前的状态。(特别是这些未commit的文件在合并的过程中将会被修改时)</li>
<li>git config branch.master.mergeoptions “–no-ff” : 如果想对特定分支(如master)禁用fast forward</li>
<li>git config merge.ff false : 禁用所有分支(fast foward)</li>
<li>git config –global core.mergeoptions –no-edit : 如何关闭git pull产生的merge 信息</li>
<li>git config –global pull.rebase true :设置默认pull时从新定基</li>
<li>git config –global branch.<name>.rebase true : 设置某个分支pull时从新定基</li>
<li>git merge branch/commitId –on-ff –squash –no-edit -m “#12345” merge</li>
<li>git merge branch/commitId –on-ff –no-edit -m “#12345” merge</li>
</ul>
<h3 id="–log-和-–no-log"><a href="#–log-和-–no-log" class="headerlink" title="–log[=]和 –no-log"></a>–log[=<n>]和 –no-log</h3><p>–log[=<n>]将在合并提交时，除了含有分支名以外，还将含有最多n个被合并commit节点的日志信息。<br>–no-log并不会列出被合并分支得提交信息。</p>
<h3 id="–edit和-e以及–no-edit"><a href="#–edit和-e以及–no-edit" class="headerlink" title="–edit和-e以及–no-edit"></a>–edit和-e以及–no-edit</h3><p>–edit和-e用于在成功合并、提交前调用编辑器来进一步编辑自动生成的合并信息。因此使用者能够进一步解释和判断合并的结果。<br>–no-edit参数能够用于接受自动合并的信息（通常情况下并不鼓励这样做）。</p>
<h3 id="–ff命令"><a href="#–ff命令" class="headerlink" title="–ff命令"></a>–ff命令</h3><p>–ff是指fast-forward命令。当使用fast-forward模式进行合并时，将不会创造一个新的commit节点。默认情况下，git-merge采用fast-forward模式。<br>关于fast-forward模式的详细解释，请看我的另一篇文章：一个成功的Git分支模型的“关于fast forward”一节。</p>
<h3 id="–no-ff命令"><a href="#–no-ff命令" class="headerlink" title="–no-ff命令"></a>–no-ff命令</h3><p>即使可以使用fast-forward模式，也要创建一个新的合并节点。这是当git merge在合并一个tag时的默认行为。</p>
<h2 id="Git分支操作命令"><a href="#Git分支操作命令" class="headerlink" title="Git分支操作命令"></a>Git分支操作命令</h2><blockquote>
<p>1.删除本地分支：git branch -d branchName<br>2.合并本地某B分支到当前分支：git merge branchNameB<br>   然后需要git push 才能把merge内容推送到远程缓存分支上</p>
</blockquote>
<h3 id="本地创建新分支"><a href="#本地创建新分支" class="headerlink" title="本地创建新分支"></a>本地创建新分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看本地所有分支：git branch    	注:带*号得代表显示当前得分支</span><br><span class="line">创建本地分支：git branch &lt;name&gt;</span><br><span class="line">切换本地分支：git switch &lt;name&gt;   Git的switch命令是2.23版本发布的新命令</span><br><span class="line">创建本地：git checkout -b &lt;name&gt;</span><br><span class="line">设置新分支推送到远程缓存(创立远程缓存分支且设置远程缓存分支拉取分支)：</span><br><span class="line">git push --set-upstream origin &lt;name&gt;</span><br><span class="line">OR</span><br><span class="line">创建分支:git branch &lt;new_branch&gt;</span><br><span class="line">将远程分支拉到本地：git fetch origin dev（dev即分支名）</span><br><span class="line">检出代码并切换分支：git checkout -b dev origin&#x2F;RemoteDev (dev 为本地分支名，RemoteDev为远程分支名)</span><br></pre></td></tr></table></figure>

<h3 id="clone分支-浅克隆后的操作"><a href="#clone分支-浅克隆后的操作" class="headerlink" title="clone分支(浅克隆后的操作)"></a>clone分支(浅克隆后的操作)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拉取最近一次提交记录：git clone --depth&#x3D;1 -b dev  &lt;URL&gt;</span><br><span class="line">非浅层转换为完整的存储库,消除浅层存储库所施加的所有限制：</span><br><span class="line">git fetch --unshallow</span><br><span class="line">git pull  --unshallow </span><br><span class="line"></span><br><span class="line">由于仓库过大采用迂回方式clone：--depth&#x3D;1</span><br><span class="line">git clone --depth&#x3D;1 -b dev &lt;URL&gt;</span><br><span class="line">git branch dev</span><br><span class="line">git switch dev</span><br><span class="line">git pull –unshallow</span><br><span class="line">git fetch ogrigin dev</span><br><span class="line">git pull origin dev</span><br></pre></td></tr></table></figure>

<h3 id="创建空分支需要清理缓存"><a href="#创建空分支需要清理缓存" class="headerlink" title="创建空分支需要清理缓存"></a>创建空分支需要清理缓存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch &lt;new_branch&gt;</span><br><span class="line">git checkout &lt;new_branch&gt;</span><br><span class="line">git rm --cached -r . :注意-r后面还有跟着点+空格 </span><br><span class="line">git clean -f –d</span><br><span class="line">或者 </span><br><span class="line">git rm -rf . #清除所有git文件历史，为了空白分支</span><br><span class="line">git clean -d -fx #会清除所有git clone下的所有文件，只剩.git</span><br><span class="line">空分支推送:git commit --allow-empty -m &quot;[empty] initial commit&quot;</span><br><span class="line">git push origin  &lt;new_branch&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Git提交远程缓存流程命令"><a href="#Git提交远程缓存流程命令" class="headerlink" title="Git提交远程缓存流程命令"></a>Git提交远程缓存流程命令</h2><h3 id="与远程缓存分支对比："><a href="#与远程缓存分支对比：" class="headerlink" title="与远程缓存分支对比："></a>与远程缓存分支对比：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前本地分支得git状态： git status</span><br><span class="line">当前本地分支暂存代码： git stash</span><br><span class="line">获取远程缓存对比分支最新消息:  git fetch</span><br><span class="line">拉去远程缓存对比分支得最新消息：git pull</span><br><span class="line">取出暂存代码不删除暂存代码:  git stash apply stash@&#123;x&#125;    x&#x3D;0123456…..</span><br><span class="line">	Or取出暂存代码删除暂存代码:git apply</span><br><span class="line">最后查看状态： git status</span><br></pre></td></tr></table></figure>

<h3 id="提交远程缓存："><a href="#提交远程缓存：" class="headerlink" title="提交远程缓存："></a>提交远程缓存：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看分支状态：git status</span><br><span class="line">加入本地工作区：git add . or git add &lt;file&gt;</span><br><span class="line">加入本地缓存区：git commit –m  &lt;message&gt;</span><br><span class="line">推送远程缓存：git push</span><br></pre></td></tr></table></figure>

<h3 id="push操作命令"><a href="#push操作命令" class="headerlink" title="push操作命令"></a>push操作命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将本地分支推送到远程缓存(创立远程缓存分支)且设置远程缓存分支拉取分支：</span><br><span class="line">git push --set-upstream origin &lt;name&gt;</span><br><span class="line">删除远程分支：git push origin --delete dev</span><br></pre></td></tr></table></figure>

<h2 id="Git-stash备份-还原命令"><a href="#Git-stash备份-还原命令" class="headerlink" title="Git stash备份/还原命令"></a>Git stash备份/还原命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看备份区所有分支备份记录：git stash list</span><br><span class="line">备份时添加备注： git stash save &quot;message&quot;</span><br><span class="line">显示做了哪些改动：git stash show (默认使用第一个备份,即stash@&#123;0&#125;)</span><br><span class="line">  or git stash show  stash@&#123;X&#125;  X&#x3D;0123456789</span><br><span class="line">还原某个备份,但不会把备份记录列表中删除：git stash apply </span><br><span class="line">  or git stash apply stash@&#123;X&#125;  X&#x3D;0123456789</span><br><span class="line">还原某个备份,但会把备份记录列表中删除：git stash pop </span><br><span class="line">  or git stash pop stash@&#123;X&#125;  X&#x3D;0123456789</span><br><span class="line">从备份列表中删除这个记录：git stash drop  stash@&#123;X&#125;  X&#x3D;0123456789</span><br><span class="line">删除所有备份记录：git stash clear</span><br></pre></td></tr></table></figure>

<h2 id="Git-add命令"><a href="#Git-add命令" class="headerlink" title="Git add命令"></a>Git add命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .  ---加入工作区</span><br><span class="line">git add &lt;file&gt;  ---指定某个文件加入本地缓存标记</span><br><span class="line">git add .的作用相反：git restore文件名字   </span><br><span class="line">----进行清除工作区的改变（git chechout 文件名的作用是一样的）</span><br></pre></td></tr></table></figure>

<h2 id="撤销命令reset-revert"><a href="#撤销命令reset-revert" class="headerlink" title="撤销命令reset/revert"></a>撤销命令reset/revert</h2><h3 id="Git-reset-修改commit记录"><a href="#Git-reset-修改commit记录" class="headerlink" title="Git reset(修改commit记录)"></a>Git reset(修改commit记录)</h3><p>git reset hashId 重置改变分支”游标”指向,适用版本回退,都不保留回退版本之后的版本记录;hard,soft,miexd对回退版本之后已经提交的版本内容处理<br>git reset –hard hashId 回退到某一个版本，清空暂存区，将已提交的内容版本恢复到本地,本地内容被恢复覆盖<br>git reset –soft hashId 回退到某一个版本，不清空暂存区，将已提交的内容版本复制到本地,不影响本地内容<br>git reset –mixed hashId 回退到某一个版本，不清空暂存区，将已提交的内容版和本地已提交内容全部恢复到暂存区,不影响本地内容<br>注:如果reset后重新push,会记录在reset后hashId后面</p>
<h3 id="Git-revert-保持commit记录"><a href="#Git-revert-保持commit记录" class="headerlink" title="Git revert(保持commit记录)"></a>Git revert(保持commit记录)</h3><p>git revert commitId:<br>将在当前版本将指定commitId的版本提交删除(撤销),直接生成新的commitId提交,接在最新提交的版本后面</p>
<p>git revert 与 git reset 区别:<br>git reset:需要重新push,而且不保留恢复指定版本之后的记录,可以通过hard,soft,miexd对回退版本之后已经提交的版本内容处理<br>git rever:将某commitId版本删除,且保留此版本之后的提交的版本，</p>
<h2 id="Git-remote命令"><a href="#Git-remote命令" class="headerlink" title="Git remote命令"></a>Git remote命令</h2><p>git remote -v 显示远程库详细信息<br>git remote remove branchName 删除远程库</p>
<h2 id="Git的撤销和回滚命令"><a href="#Git的撤销和回滚命令" class="headerlink" title="Git的撤销和回滚命令"></a>Git的撤销和回滚命令</h2><h3 id="A-工作区"><a href="#A-工作区" class="headerlink" title="A.工作区"></a>A.工作区</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">撤销部分文件的修改： git checkout -- path&#x2F;to&#x2F;file1 path&#x2F;to&#x2F;file2</span><br><span class="line">	Or(git 2.23+) git restore --worktree path&#x2F;to&#x2F;file1 path&#x2F;to&#x2F;file2</span><br><span class="line">撤销工作区下所有文件的修改（不包括新增文件）： git checkout -- .</span><br><span class="line">	Or (git 2.23+) git restore --worktree .</span><br><span class="line">将一个或多个文件回滚到指定版本：</span><br><span class="line">git checkout HashID -- path&#x2F;to&#x2F;file1 path&#x2F;to&#x2F;file2</span><br><span class="line">将一个或多个文件回滚到指定版本的前2个版本：</span><br><span class="line">git checkout HashID ~2 -- path&#x2F;to&#x2F;file1 path&#x2F;to&#x2F;file2</span><br><span class="line">将一个或多个文件回滚到指定分支版本：</span><br><span class="line">git checkout develop -- path&#x2F;to&#x2F;file1 path&#x2F;to&#x2F;file2</span><br><span class="line">丢弃工作区中所有不受版本控制的文件或目录：git clean -fdx</span><br></pre></td></tr></table></figure>

<h3 id="B-暂存区"><a href="#B-暂存区" class="headerlink" title="B.暂存区"></a>B.暂存区</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">撤销add到暂存区的部分变更:</span><br><span class="line">git reset -- path&#x2F;to&#x2F;file1 path&#x2F;to&#x2F;file2</span><br><span class="line">	Or (git 2.23+) git restore --staged path&#x2F;to&#x2F;file1 path&#x2F;to&#x2F;file2</span><br><span class="line">撤销add到暂存区的所有变更: git reset -- .   Or (git 2.23+)git restore --staged .</span><br></pre></td></tr></table></figure>


<h3 id="C-本地仓库"><a href="#C-本地仓库" class="headerlink" title="C.本地仓库"></a>C.本地仓库</h3><blockquote>
<p>注意：本部分内容的前提是提交到本地仓库的commit还未push到remote。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修订最后一次提交的commit message：</span><br><span class="line">git commit --amend -m &quot;新的log信息&quot;</span><br><span class="line">回滚某次commit的变更（不修改历史），但会生成新的commit：</span><br><span class="line">git revert [HashID]</span><br><span class="line">抹去本地最新commit：</span><br><span class="line">git reset --hard HEAD~1  Or  git rebase -i HEAD~1（然后旋转drop命令）</span><br></pre></td></tr></table></figure>


<h3 id="D-远程仓库篇"><a href="#D-远程仓库篇" class="headerlink" title="D.远程仓库篇"></a>D.远程仓库篇</h3><blockquote>
<p>注意：<br>由于远程仓库历史属于团队公共历史，不能随意修改，所以一般不到万不得已，不能进行修改远程历史的操作。<br>如果一定要修改远程仓库历史，比如去除敏感信息，一定要提前做好团队沟通，使用reset或rebase进行回滚，然后使用git push -f强制推送。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">针对远程仓库的历史回滚，建议使用revert操作</span><br><span class="line">git revert [版本号]</span><br><span class="line">回滚多个commit，但只做一次提交</span><br><span class="line">git revert  [版本号]</span><br><span class="line">git commit -m &quot;revert commit1 commit2 commit3&quot;</span><br><span class="line"></span><br><span class="line">git修改远程仓库地址 </span><br><span class="line">方法有三种：</span><br><span class="line">1.修改命令</span><br><span class="line">git remote origin set-url [url]</span><br><span class="line">2.先删后加</span><br><span class="line">git remote rm origin</span><br><span class="line">git remote add origin [url]</span><br><span class="line">3.直接修改config文件</span><br></pre></td></tr></table></figure>

<h2 id="rebase-变基-命令"><a href="#rebase-变基-命令" class="headerlink" title="rebase(变基)命令"></a>rebase(变基)命令</h2><h3 id="改变产生分支起点位置"><a href="#改变产生分支起点位置" class="headerlink" title="改变产生分支起点位置"></a>改变产生分支起点位置</h3><p>dev:git rebase <branchA>//会将当前dev分支的提交复制到指定的branchA分支之上<br>git rebase –continue<br>git rebase –abort<br><img src="/img/git-rebase1.png" alt="git-rebase1" title="git-rebase1"><br><img src="/img/git-rebase2.png" alt="git-rebase2" title="git-rebase2"></p>
<p>上面这个例子展示了在 master 分支上的变基，提交创建新的hash时会修改项目的历史记录。但是，在更大型的项目中，你通常不需要这样的操作。</p>
<p>变基与合并区别：<br>　　有一个重大的区别：Git 不会尝试确定要保留或不保留哪些文件。我们执行rebase的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git 历史记录；git merge 需要解决冲突才能合并</p>
<p>注:因为dev分支 git rebase 只是改变了dev最初产生分支的指针,指针指向了master在最新提交后面形成直线,同样的会合并最新提交代码，冲突部分以dev分支为主,有覆盖的master分支的危险,因此要使用该命令时,先把最新更新分支pull到dev,解决冲突后再rebase.</p>
<h3 id="git-rebase-–onto-截取区间做新分支"><a href="#git-rebase-–onto-截取区间做新分支" class="headerlink" title="git rebase –onto(截取区间做新分支)"></a>git rebase –onto(截取区间做新分支)</h3><p>// branch:分支名称 , 截取区间为: (fromCommitedId,toCommitedId]<br>git rebase –onto branch fromCommitedId toCommitedId</p>
<p>步骤:<br>1.当前工作空间—分支A<br>2.从当前工作的分支新建一个分支,并且换到该分支—-git checkout -b newbranch<br>3.git rebase –onto B fromCommitedId toCommitedId<br>4.生成一个基于B分支和选择的提交区间(fromCommitedId,toCommitedId]的片段生成一个新的分支（detached Head）</p>
<h3 id="修改commit后提交记录"><a href="#修改commit后提交记录" class="headerlink" title="修改commit后提交记录"></a>修改commit后提交记录</h3><h4 id="Git修改最近后一次commit信息"><a href="#Git修改最近后一次commit信息" class="headerlink" title="Git修改最近后一次commit信息"></a>Git修改最近后一次commit信息</h4><p>1.git commit –amend : 然后就会进入vim模式<br>2.点击i编辑模式,按esc键退出编辑模式,:q退出，:wq保存退出</p>
<h4 id="修改更早提交信息"><a href="#修改更早提交信息" class="headerlink" title="修改更早提交信息"></a>修改更早提交信息</h4><p>1.git rebase -i commitId 或  git rebase -i HEAD~3<br>    选取commitId，需要比要修改版本commitId向前一版本(见备注);head后数字代表从head开始不包括head,向后退3个版本<br>2.点击i编辑模式,将需要修改commit行的pick 改为r或reword,按esc键退出编辑模式,:q退出，:wq保存退出<br>3.自动跳回到上一步修改为r的版本修改,如果修改多个版本，每一次wq后都会到一个修改的r版本<br>注:commitId选取规则如图:要修改2，则需要选比2更早一条commitId作为基版,因为是在3上面提交后才有2<br>    <img src="/img/Git%E6%9B%B4%E6%94%B9commit%E4%BF%A1%E6%81%AF.png" alt="Git更改commit信息" title="Git更改commit信息"></p>
<p>注: git rebase -i commitId 或  git rebase -i HEAD~3 后可以将进入vim模式,按i修改替换文件pick命令及作用有:<br>    reword:修改提交信息<br>    edit:修改此提交<br>    squash:将提交融合到前一个提交中<br>    fixup:将提交融合到前一个提交中，不保留该提交的日志消息<br>    exec:在每个提交上运行我们想要 rebase 的命令<br>    drop:移除该提交</p>
<h4 id="Cherry-picking-拣选"><a href="#Cherry-picking-拣选" class="headerlink" title="Cherry-picking(拣选)"></a>Cherry-picking(拣选)</h4><p>master:git Cherry-picking <dev-commitId> //将dev分支上的某个提交merge到master,而不是dev全部提交<br>注意与git merge commitId 区别</p>
<p>假设 dev 分支上的提交 76d12 为 index.js 文件添加了一项修改，而我们希望将其整合到 master 分支中。我们并不想要整个 dev 分支，而只需要这个提交<br><img src="/img/Cherry-picking1.png" alt="Cherry-picking1" title="Cherry-picking1"></p>
<h4 id="Reflog-还原"><a href="#Reflog-还原" class="headerlink" title="Reflog(还原)"></a>Reflog(还原)</h4><p>git reflog:是一个非常有用的命令,可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。.<br>根据 reflog 提供的对比分支信息通过重置 HEAD 来轻松地重做！<br>假设我们实际上并不需要合并原有分支。当我们执行 git reflog 命令时，我们可以看到这个 repo 的状态在合并前位于 HEAD@{1}。那我们就执行一次 git reset，将 HEAD 重新指向在 HEAD@{1} 的位置。<br><img src="/img/reflog1.png" alt="reflog1" title="reflog1"><br><img src="/img/reflog2.png" alt="reflog2" title="reflog2"></p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>Creating a new branch is quick &amp; simple<br>=======<br>Creating a new branch is quick AND simple</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>feature1</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>1.在&lt;&lt;&lt;&lt;&lt;&lt;&lt;  =======之间为自己的代码<br>2.在=======  &gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。<br>如果保留自己的代码，将别人的代码删掉即可。</p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git核心内容</title>
    <url>/2021/03/13/PluginTool-Git%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="Git-掌握命令要求"><a href="#Git-掌握命令要求" class="headerlink" title="Git 掌握命令要求"></a>Git 掌握命令要求</h2><p>日常工作需要掌握add,commit,status,fetch,push,rebase等，若要熟练掌握，还必须掌握rebase和merge的区别，fetch和pull的区别等，除此之外&gt;，还有cherry-pick，submodule，stash等功能</p>
<h2 id="Git-vs-SVN"><a href="#Git-vs-SVN" class="headerlink" title="Git vs SVN"></a>Git vs SVN</h2><p>在版本管理里，分支是很常使用的功能。在发布版本前，需要发布分支，进行大需求开发，需要 feature 分支，大团队还会有开发分支，稳定分支等。在大团队开发过程中，常常存在创建分支，切换分支的求。<br>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录。这个特性使 Git 的分支切换非常迅速，并且创建成本非常低。<br>而且 Git 有本地分支，SVN 无本地分支。在实际开发过程中，经常会遇到有些代码没写完，但是需紧急处理其他问题，若我们使用 Git，便可以创建本地分支存储没写完的代码，待问题处理完后，再回到本地分支继续完成代码。</p>
<h2 id="Git-核心概念"><a href="#Git-核心概念" class="headerlink" title="Git 核心概念"></a>Git 核心概念</h2><blockquote>
<p>Git 最核心的一个概念就是工作流。通常提交代码分为几步：<br>git add从工作区提交到暂存区<br>git commit从暂存区提交到本地仓库<br>git push或git svn dcommit从本地仓库提交到远程仓库</p>
</blockquote>
<p><img src="/img/GitFolw.png" alt="Git提交核心流程" title="Git提交核心流程"></p>
<h2 id="Git基本操作命令"><a href="#Git基本操作命令" class="headerlink" title="Git基本操作命令"></a>Git基本操作命令</h2><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><blockquote>
<p>Git 用户的配置文件位于 ~/.gitconfig<br>Git 单个仓库的配置文件位于 ~/$PROJECT_PATH/.git/config</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列举所有配置</span><br><span class="line">$ git config -l</span><br><span class="line"># 为命令配置别名</span><br><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"># 下载一个项目和它的整个代码历史 [Git only]</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>

<h3 id="增删文件"><a href="#增删文件" class="headerlink" title="增删文件"></a>增删文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add &lt;file1&gt; &lt;file2&gt; ...</span><br><span class="line"># 添加指定目录到暂存区，包括其子目录</span><br><span class="line">$ git add &lt;dir&gt;</span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br><span class="line">把文件名 file1 添加到 .gitignore 文件里，Git 会停止跟踪 file1 的状态。</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看工作区文件修改状态</span><br><span class="line">$ git status</span><br><span class="line"># 查看工作区文件修改具体内容</span><br><span class="line">$ git diff [file]</span><br><span class="line"># 查看暂存区文件修改内容</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"># 查看版本库修改记录</span><br><span class="line">$ git log</span><br><span class="line"># 查看某人提交记录</span><br><span class="line">$ git log --author&#x3D;someone</span><br><span class="line"># 查看某个文件的历史具体修改内容</span><br><span class="line">$ git log -p [file]</span><br><span class="line"># 查看某次提交具体修改内容</span><br><span class="line">$ git show [commit]</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [new_branch] [remote-branch]</span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"># 选择一个 commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"># 删除本地分支，-D 参数强制删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push [remote] :[remote-branch]</span><br></pre></td></tr></table></figure>

<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"># 提交工作区与暂存区的变化直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"># 提交时显示所有 diff 信息</span><br><span class="line">$ git commit -v</span><br><span class="line"># 提交暂存区修改到仓库区，合并到上次修改，并修改上次的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [remote-branch]</span><br></pre></td></tr></table></figure>

<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动 (Git only)</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"># 显示所有远程仓库 (Git only)</span><br><span class="line">$ git remote -v</span><br><span class="line"># 显示某个远程仓库的信息 (Git only)</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"># 增加一个新的远程仓库，并命名 (Git only)</span><br><span class="line">$ git remote add [remote-name] [url]</span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并，(Git only), 若使用 Git-SVN，请查看第三节</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"># 取回远程仓库的变化，并与本地分支变基合并，(Git only), 若使用 Git-SVN，请查看第三节</span><br><span class="line">$ git pull --rebase [remote] [branch]</span><br></pre></td></tr></table></figure>

<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"># 恢复暂存区当前目录的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"># 恢复工作区到指定 commit</span><br><span class="line">$ git checkout [commit]</span><br><span class="line"># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"># 重置暂存区与工作区，与上一次 commit 保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"># 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"># 新建一个 commit，用于撤销指定 commit</span><br><span class="line">$ git revert [commit]</span><br><span class="line"># 将未提交的变化放在储藏区</span><br><span class="line">$ git stash</span><br><span class="line"># 将储藏区的内容恢复到当前工作区</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA Windows版本快捷键</title>
    <url>/2021/10/08/PluginTool-IDEA%20Windows%E7%89%88%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="十大IDEA快捷键"><a href="#十大IDEA快捷键" class="headerlink" title="十大IDEA快捷键"></a>十大IDEA快捷键</h2><h3 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h3><ul>
<li>基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space:但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。</li>
<li>用F2/ Shift+F2移动到有错误的代码</li>
<li>Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。</li>
<li>当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。</li>
</ul>
<p>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。</p>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。</p>
<p>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。</p>
<p>此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。</p>
<p>后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。</p>
<p>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。</p>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。</p>
<p>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。</p>
<p>另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p>
<h3 id="查找打开"><a href="#查找打开" class="headerlink" title="查找打开"></a>查找打开</h3><p>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。</p>
<p>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。</p>
<p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。</p>
<p>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。关注Java技术栈微信公众号，在后台回复关键字：IDEA，可以获取一份栈长整理的 IDEA 最新技术干货。</p>
<h3 id="其他辅助"><a href="#其他辅助" class="headerlink" title="其他辅助"></a>其他辅助</h3><p>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p>
<ul>
<li>命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。</li>
<li>新建：Alt+Insert可以新建类、方法等任何东西。</li>
<li>格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。</li>
<li>切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。</li>
<li>单元测试：Ctrl+Alt+T创建单元测试用例。</li>
<li>运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。</li>
<li>调试：F7/F8/F9分别对应Step into，Step over，Continue。</li>
</ul>
<p>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</p>
<ul>
<li>切来切去：Ctrl+Tab</li>
<li>选你所想：Ctrl+W</li>
<li>代码生成：Template/Postfix +Tab</li>
<li>发号施令：Ctrl+Shift+A</li>
<li>无处藏身：Shift+Shift</li>
<li>自动完成：Ctrl+Shift+Enter</li>
<li>创造万物：Alt+Insert</li>
</ul>
<h3 id="太难割舍，前三名并列吧！"><a href="#太难割舍，前三名并列吧！" class="headerlink" title="太难割舍，前三名并列吧！"></a>太难割舍，前三名并列吧！</h3><ul>
<li>智能补全：Ctrl+Shift+Space</li>
<li>自我修复：Alt+Enter</li>
<li>重构一切：Ctrl+Shift+Alt+T</li>
</ul>
<p>CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>
<h3 id="自动补全代码"><a href="#自动补全代码" class="headerlink" title="自动补全代码"></a>自动补全代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。</p>
<p>例如要输入for(User user : users)只需输入user.for+Tab ；</p>
<p>再比如，要输入Date birthday = user.getBirthday()只需输入user.getBirthday().var+Tab即可。<br>代码标签输入完成后，按Tab，生成代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+O 优化导入的类和包</span><br><span class="line">Alt+Insert 生成代码(如get,set方法,构造函数等)   或者右键（Generate）</span><br><span class="line">fori&#x2F;sout&#x2F;psvm + Tab</span><br><span class="line">Ctrl+Alt+T  生成try catch  或者 Alt+enter</span><br><span class="line">CTRL+ALT+T  把选中的代码放在 TRY&#123;&#125; IF&#123;&#125; ELSE&#123;&#125; 里</span><br><span class="line">Ctrl + O 重写方法</span><br><span class="line">Ctrl + I 实现方法</span><br><span class="line">Ctr+shift+U 大小写转化</span><br><span class="line">ALT+回车    导入包,自动修正</span><br><span class="line">ALT+&#x2F;       代码提示</span><br><span class="line">CTRL+J      自动代码</span><br><span class="line">Ctrl+Shift+J，整合两行为一行</span><br><span class="line">CTRL+空格   代码提示</span><br><span class="line">CTRL+SHIFT+SPACE 自动补全代码</span><br><span class="line">CTRL+ALT+L  格式化代码</span><br><span class="line">CTRL+ALT+I  自动缩进</span><br><span class="line">CTRL+ALT+O  优化导入的类和包</span><br><span class="line">ALT+INSERT  生成代码(如GET,SET方法,构造函数等)</span><br><span class="line">CTRL+E      最近更改的代码</span><br><span class="line">CTRL+ALT+SPACE  类名或接口名提示</span><br><span class="line">CTRL+P   方法参数提示</span><br><span class="line">CTRL+Q，可以看到当前方法的声明</span><br><span class="line">Shift+F6  重构-重命名 (包、类、方法、变量、甚至注释等)</span><br><span class="line">Ctrl+Alt+V 提取变量</span><br></pre></td></tr></table></figure>

<h3 id="查询快捷键"><a href="#查询快捷键" class="headerlink" title="查询快捷键"></a>查询快捷键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl＋Shift＋Backspace可以跳转到上次编辑的地</span><br><span class="line">CTRL+ALT+ left&#x2F;right 前后导航编辑过的地方</span><br><span class="line">ALT+7  靠左窗口显示当前文件的结构</span><br><span class="line">Ctrl+F12 浮动显示当前文件的结构</span><br><span class="line">ALT+F7 找到你的函数或者变量或者类的所有引用到的地方</span><br><span class="line">CTRL+ALT+F7  找到你的函数或者变量或者类的所有引用到的地方</span><br><span class="line">Ctrl+Shift+Alt+N 查找类中的方法或变量</span><br><span class="line">双击SHIFT 在项目的所有目录查找文件</span><br><span class="line">Ctrl+N   查找类</span><br><span class="line">Ctrl+Shift+N 查找文件</span><br><span class="line">CTRL+G   定位行</span><br><span class="line">CTRL+F   在当前窗口查找文本</span><br><span class="line">CTRL+SHIFT+F  在指定窗口查找文本</span><br><span class="line">CTRL+R   在 当前窗口替换文本</span><br><span class="line">CTRL+SHIFT+R  在指定窗口替换文本</span><br><span class="line">ALT+SHIFT+C  查找修改的文件</span><br><span class="line">CTRL+E   最近打开的文件</span><br><span class="line">F3   向下查找关键字出现位置</span><br><span class="line">SHIFT+F3  向上一个关键字出现位置</span><br><span class="line">选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本</span><br><span class="line">F4   查找变量来源</span><br><span class="line">CTRL+SHIFT+O  弹出显示查找内容</span><br><span class="line">Ctrl+W 选中代码，连续按会有其他效果</span><br><span class="line">F2 或Shift+F2 高亮错误或警告快速定位</span><br><span class="line">Ctrl+Up&#x2F;Down 光标跳转到第一行或最后一行下</span><br><span class="line">Ctrl+B 快速打开光标处的类或方法</span><br><span class="line">CTRL+ALT+B  找所有的子类</span><br><span class="line">CTRL+SHIFT+B  找变量的类</span><br><span class="line">Ctrl+Shift+上下键  上下移动代码</span><br><span class="line">Ctrl+Alt+ left&#x2F;right 返回至上次浏览的位置</span><br><span class="line">Ctrl+X 删除行</span><br><span class="line">Ctrl+D 复制行</span><br><span class="line">Ctrl+&#x2F; 或 Ctrl+Shift+&#x2F;  注释（&#x2F;&#x2F; 或者&#x2F;...&#x2F; ）</span><br><span class="line">Ctrl+H 显示类结构图</span><br><span class="line">Ctrl+Q 显示注释文档</span><br><span class="line">Alt+F1 查找代码所在位置</span><br><span class="line">Alt+1 快速打开或隐藏工程面板</span><br><span class="line">Alt+ left&#x2F;right 切换代码视图</span><br><span class="line">ALT+ ↑&#x2F;↓  在方法间快速移动定位</span><br><span class="line">CTRL+ALT+ left&#x2F;right 前后导航编辑过的地方</span><br><span class="line">Ctrl＋Shift＋Backspace可以跳转到上次编辑的地</span><br><span class="line">Alt+6    查找TODO</span><br></pre></td></tr></table></figure>

<h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHIFT+ENTER 另起一行</span><br><span class="line">CTRL+Z   倒退(撤销)</span><br><span class="line">CTRL+SHIFT+Z  向前(取消撤销)</span><br><span class="line">CTRL+ALT+F12  资源管理器打开文件夹</span><br><span class="line">ALT+F1   查找文件所在目录位置</span><br><span class="line">SHIFT+ALT+INSERT 竖编辑模式</span><br><span class="line">CTRL+F4  关闭当前窗口</span><br><span class="line">Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义</span><br><span class="line">Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）</span><br></pre></td></tr></table></figure>
<h3 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。</span><br><span class="line"></span><br><span class="line">alt+F8    debug时选中查看值</span><br><span class="line">Alt+Shift+F9，选择 Debug</span><br><span class="line">Alt+Shift+F10，选择 Run</span><br><span class="line">Ctrl+Shift+F9，编译</span><br><span class="line">Ctrl+Shift+F8，查看断点</span><br><span class="line">F7，步入</span><br><span class="line">Shift+F7，智能步入</span><br><span class="line">Alt+Shift+F7，强制步入</span><br><span class="line">F8，步过</span><br><span class="line">Shift+F8，步出</span><br><span class="line">Alt+Shift+F8，强制步过</span><br><span class="line">Alt+F9，运行至光标处</span><br><span class="line">Ctrl+Alt+F9，强制运行至光标处</span><br><span class="line">F9，恢复程序</span><br><span class="line">Alt+F10，定位到断点</span><br></pre></td></tr></table></figure>

<h3 id="重构-1"><a href="#重构-1" class="headerlink" title="重构"></a>重构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+Shift+T，弹出重构菜单</span><br><span class="line">Shift+F6，重命名</span><br><span class="line">F6，移动</span><br><span class="line">F5，复制</span><br><span class="line">Alt+Delete，安全删除</span><br><span class="line">Ctrl+Alt+N，内联</span><br></pre></td></tr></table></figure>
<h2 id="eclipse-idea常用"><a href="#eclipse-idea常用" class="headerlink" title="eclipse/idea常用"></a>eclipse/idea常用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl + n ：显示类</span><br><span class="line">Ctrl+L,下一个相同的</span><br><span class="line">Ctrl+Y ：删除当前行</span><br><span class="line">Ctrl+d : 添加行</span><br><span class="line">Ctrl+F ，查找</span><br><span class="line">Ctrl+R ，替换</span><br><span class="line">ctrl + shift +R : 搜索</span><br><span class="line">ctrl + shift +f : 全局搜索</span><br><span class="line">shift+shift ：全局搜索 </span><br><span class="line">Ctrl+G : 定位行数</span><br><span class="line">Ctrl+F12:本類所有方法</span><br><span class="line">alt+方向：tab向前后前後</span><br><span class="line">alt+ctrl+方向，引用向前或向后</span><br><span class="line">fn+alt+F7：引用的地方</span><br><span class="line">shift+ctrl+方向：整行以分号结束的移动</span><br><span class="line">shift+alt+方向：整行上下移动</span><br><span class="line"></span><br><span class="line">eclipse</span><br><span class="line">ctrl+ d : 删除</span><br><span class="line">ctrl+F： 文件内查找</span><br><span class="line">ctrl + shift +R : 全局搜索</span><br><span class="line">ctrl+N ： 查找下一个一样得</span><br><span class="line">ctrl+K： 查走上一个一样得</span><br><span class="line">ctrl+L：定位行数</span><br></pre></td></tr></table></figure>
<h2 id="使用IDEA-Git快捷键"><a href="#使用IDEA-Git快捷键" class="headerlink" title="使用IDEA-Git快捷键"></a>使用IDEA-Git快捷键</h2><p>添加新建的文件 即add 操作<br>shift + alt + a</p>
<p>提交操作 即 commit操作<br>ctrl + k</p>
<p>拉去远程分支操作 即pull操作<br>ctrl + t</p>
<p>提交操作 即push操作<br>ctrl + shift + k</p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA工具箱</title>
    <url>/2021/01/07/PluginTool-IDEA%E5%B7%A5%E5%85%B7%E7%AE%B1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法模板</title>
    <url>/2018/02/10/PluginTool-MarkDown%E8%AF%AD%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="语法大全"><a href="#语法大全" class="headerlink" title="语法大全"></a><a href="http://www.mdeditor.com" target="_blank" rel="noopener">语法大全</a></h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h2 id="可复制区域"><a href="#可复制区域" class="headerlink" title="可复制区域"></a>可复制区域</h2><blockquote>
<p>可以复制区域/置灰区域<br>可以指定是bash/sql</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>###无序列表用 </p>
<blockquote>
<ul>
<li><ul>
<li><ul>
<li>任何一种都可以</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>列表内容1</li>
</ul>
<ul>
<li>列表内容2</li>
</ul>
<ul>
<li>列表内容3</li>
</ul>
<p>###有序列表<br>数字加点跟着空格</p>
<ol>
<li>列表内容1</li>
<li>列表内容2</li>
<li>列表内容3</li>
</ol>
<h2 id="关联链接"><a href="#关联链接" class="headerlink" title="关联链接"></a>关联链接</h2><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><h2 id="三个或者三个以上的-或者-都可以"><a href="#三个或者三个以上的-或者-都可以" class="headerlink" title="三个或者三个以上的 - 或者 * 都可以"></a>三个或者三个以上的 - 或者 * 都可以</h2><hr>
<hr>
<hr>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Jira &amp; Confluence</title>
    <url>/2021/01/09/PluginTool-Jira&amp;Confluence/</url>
    <content><![CDATA[<h2 id="Atlassian产品线全破解"><a href="#Atlassian产品线全破解" class="headerlink" title="Atlassian产品线全破解"></a>Atlassian产品线全破解</h2><p>点击查看README:<a href="https://github.com/cdongtao/atlassian-agent" target="_blank" rel="noopener">atlassian-agent</a></p>
<h2 id="JIRA-7-12-0-和Confluence-6-13-0"><a href="#JIRA-7-12-0-和Confluence-6-13-0" class="headerlink" title="JIRA(7.12.0)和Confluence(6.13.0)"></a><a href="https://my.oschina.net/wuweixiang/blog/3014644" target="_blank" rel="noopener">JIRA(7.12.0)和Confluence(6.13.0)</a></h2><h3 id="在Docker下安装JIRA-7-12-0"><a href="#在Docker下安装JIRA-7-12-0" class="headerlink" title="在Docker下安装JIRA-7.12.0"></a>在Docker下安装JIRA-7.12.0</h3><h4 id="安装-mysql-5-7"><a href="#安装-mysql-5-7" class="headerlink" title="安装 mysql 5.7"></a>安装 mysql 5.7</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动容器mysql</span><br><span class="line">docker run --name mysql \</span><br><span class="line">--restart always \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;zagame10086 \</span><br><span class="line">-v data_mysql_vol:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-v conf_mysql_vol:&#x2F;etc&#x2F;mysql&#x2F;conf.d \</span><br><span class="line">-v data_backup_vol:&#x2F;backup \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>
<h4 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h4><p>MySQL所使用的配置文件my.cnf核心参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set &#x3D; utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set &#x3D; utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server &#x3D; utf8</span><br><span class="line">collation-server &#x3D; utf8_bin</span><br><span class="line">transaction_isolation &#x3D; READ-COMMITTED</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Confluence需要使用utf8_bin，并将事务隔离策略设为READ-COMMITTED。</p>
<h4 id="创建表及用户"><a href="#创建表及用户" class="headerlink" title="创建表及用户"></a>创建表及用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建jira数据库及用户</span><br><span class="line">--drop database jira;</span><br><span class="line">create database jira character set &#39;UTF8&#39;;</span><br><span class="line">create user jira identified by &#39;jira&#39;;</span><br><span class="line">grant all privileges on &#96;jira&#96;.* to &#39;jira&#39;@&#39;172.%&#39; identified by &#39;jira&#39; with grant option;</span><br><span class="line">grant all privileges on &#96;jira&#96;.* to &#39;jira&#39;@&#39;localhost&#39; identified by &#39;jira&#39; with grant option;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">--创建confluence数据库及用户</span><br><span class="line">--drop database confluence;</span><br><span class="line">create database confluence character set &#39;UTF8&#39;;</span><br><span class="line">create user confluence identified by &#39;confluence&#39;;</span><br><span class="line">grant all privileges on &#96;confluence&#96;.* to &#39;confluence&#39;@&#39;%&#39; identified by &#39;confluence&#39; with grant option;</span><br><span class="line">grant all privileges on &#96;confluence&#96;.* to &#39;confluence&#39;@&#39;localhost&#39; identified by &#39;confluence&#39; with grant option;</span><br><span class="line">flush privileges;</span><br><span class="line">--设置confluence字符集</span><br><span class="line">alter database confluence character set utf8 collate utf8_bin;</span><br><span class="line">-- confluence要求设置事务级别为READ-COMMITTED</span><br><span class="line">set global tx_isolation&#x3D;&#39;READ-COMMITTED&#39;;</span><br><span class="line">--set session transaction isolation level read committed;</span><br><span class="line">--show variables like &#39;tx%&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="安装JIRA-7-12-0"><a href="#安装JIRA-7-12-0" class="headerlink" title="安装JIRA 7.12.0"></a>安装JIRA 7.12.0</h3><p>JIRA 是一个缺陷跟踪管理系统，为针对缺陷管理、任务追踪和项目管理的商业性应用软件，开发者是澳大利亚的Atlassian。JIRA这个名字并不是一个缩写，而是截取自“Gojira”，日文的哥斯拉发音</p>
<h4 id="制作Docker破解容器"><a href="#制作Docker破解容器" class="headerlink" title="制作Docker破解容器"></a>制作Docker破解容器</h4><p>编写Dockerfile文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM cptactionhank&#x2F;atlassian-jira-software:7.12.0</span><br><span class="line">USER root</span><br><span class="line"># 将代理破解包加入容器</span><br><span class="line">COPY &quot;atlassian-agent.jar&quot; &#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;</span><br><span class="line"># 设置启动加载代理包</span><br><span class="line">RUN echo &#39;export CATALINA_OPTS&#x3D;&quot;-javaagent:&#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;atlassian-agent.jar $&#123;CATALINA_OPTS&#125;&quot;&#39; &gt;&gt; &#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;bin&#x2F;setenv.sh</span><br></pre></td></tr></table></figure>
<h4 id="更换文件"><a href="#更换文件" class="headerlink" title="更换文件"></a>更换文件</h4><p>下载atlassian-agent.jar文件，放置在Dockerfile同目录下，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- JIRA</span><br><span class="line">  --Dockerfile</span><br><span class="line">  --atlassian-agent.jar</span><br></pre></td></tr></table></figure>
<h4 id="构建镜像，执行命令"><a href="#构建镜像，执行命令" class="headerlink" title="构建镜像，执行命令"></a>构建镜像，执行命令</h4><p>docker build -t jira/jira:v7.12.0 .<br>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon  985.1kB</span><br><span class="line">Step 1&#x2F;4 : FROM cptactionhank&#x2F;atlassian-jira-software:7.12.0</span><br><span class="line"> ---&gt; 1b29859343c2</span><br><span class="line">Step 2&#x2F;4 : USER root</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 31ea501d34b6</span><br><span class="line">Step 3&#x2F;4 : COPY &quot;atlassian-agent.jar&quot; &#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;</span><br><span class="line"> ---&gt; ce3a1f7cd53d</span><br><span class="line">Step 4&#x2F;4 : RUN echo &#39;export CATALINA_OPTS&#x3D;&quot;-javaagent:&#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;atlassian-agent.jar $&#123;CATALINA_OPTS&#125;&quot;&#39; &gt;&gt; &#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;bin&#x2F;setenv.sh</span><br><span class="line"> ---&gt; Running in 88440445ba9e</span><br><span class="line"> ---&gt; f247b9463dbb</span><br><span class="line">Removing intermediate container 88440445ba9e</span><br><span class="line">Successfully built f247b9463dbb</span><br><span class="line">Successfully tagged jira&#x2F;jira:v7.12.0</span><br></pre></td></tr></table></figure>
<h4 id="启动容器，执行命令"><a href="#启动容器，执行命令" class="headerlink" title="启动容器，执行命令"></a>启动容器，执行命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动容器jira，并关联mysql和confluence容器</span><br><span class="line">docker run --name jira \</span><br><span class="line">--restart always \</span><br><span class="line">--link mysql:mysql \</span><br><span class="line">--link confluence:confluence \</span><br><span class="line">-p 9005:8080 \</span><br><span class="line">-v data_jira_var:&#x2F;var&#x2F;atlassian&#x2F;jira \</span><br><span class="line">-v data_jira_opt:&#x2F;opt&#x2F;atlassian&#x2F;jira \</span><br><span class="line">-d jira&#x2F;jira:v7.12.0</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --detach --publish 8080:8080 jira&#x2F;jira:v7.12.0</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://127.0.0.1:8080,可见如下页面">http://127.0.0.1:8080,可见如下页面</a><br><img src="/jira/001.png" alt="001" title="001"><br><img src="/jira/002.png" alt="002" title="002"></p>
<p><font color="red">必须</font>选择手动配置项目</p>
<p><img src="/jira/003.png" alt="003" title="003"></p>
<p><font color="red">必须</font>演示使用内置数据库（生产环境需配置独立数据库）</p>
<p><img src="/jira/005.png" alt="005" title="005"><br><font color="red">破解重点</font></p>
<p><img src="/jira/004.png" alt="004" title="004"></p>
<ul>
<li>复制服务器ID:BY9B-GWD1-1C78-K2DE</li>
<li>在本地存放”atlassian-agent.jar”的目录下执行命令，生成许可证：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 需替换邮箱（test@test.com）、名称（BAT）、</span><br><span class="line"># 访问地址（http:&#x2F;&#x2F;192.168.0.89）、服务器ID（BY9B-GWD1-1C78-K2DE）</span><br><span class="line"># 为你的信息</span><br><span class="line"></span><br><span class="line">java -jar atlassian-agent.jar -d -m test@test.com -n BAT -p jira -o http:&#x2F;&#x2F;192.168.0.89 -s BY9B-GWD1-1C78-K2DE</span><br></pre></td></tr></table></figure>
<img src="/jira/007.png" alt="007" title="007"><br>将生成的许可证复制到页面，完成破解。<br><img src="/jira/006.png" alt="006" title="006"><br><img src="/jira/008.png" alt="008" title="008"></li>
</ul>
<h3 id="在Docker下安装Confluence-6-13-0"><a href="#在Docker下安装Confluence-6-13-0" class="headerlink" title="在Docker下安装Confluence(6.13.0)"></a>在Docker下安装Confluence(6.13.0)</h3><h4 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM cptactionhank&#x2F;atlassian-confluence:6.13.0</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line"># 将代理破解包加入容器</span><br><span class="line">COPY &quot;atlassian-agent.jar&quot; &#x2F;opt&#x2F;atlassian&#x2F;confluence&#x2F;</span><br><span class="line"></span><br><span class="line"># 设置启动加载代理包</span><br><span class="line">RUN echo &#39;export CATALINA_OPTS&#x3D;&quot;-javaagent:&#x2F;opt&#x2F;atlassian&#x2F;confluence&#x2F;atlassian-agent.jar $&#123;CATALINA_OPTS&#125;&quot;&#39; &gt;&gt; &#x2F;opt&#x2F;atlassian&#x2F;confluence&#x2F;bin&#x2F;setenv.sh</span><br></pre></td></tr></table></figure>

<h4 id="更换文件-1"><a href="#更换文件-1" class="headerlink" title="更换文件"></a>更换文件</h4><p>下载atlassian-agent.jar文件，放置在Dockerfile同目录下，例如</p>
<ul>
<li>Confluence<br>–Dockerfile<br>–atlassian-agent.jar</li>
</ul>
<h4 id="构建镜像，执行命令："><a href="#构建镜像，执行命令：" class="headerlink" title="构建镜像，执行命令："></a>构建镜像，执行命令：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f Dockerfile -t confluence&#x2F;confluence:6.13.0 .</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动容器confluence，并关联mysql和jira容器</span><br><span class="line">docker run --name confluence \</span><br><span class="line">    --restart always \</span><br><span class="line">    --link mysql:mysql \</span><br><span class="line">    --link jira:jira \</span><br><span class="line">    -p 9006:8090 \</span><br><span class="line">    -v data_confluence_vol:&#x2F;home&#x2F;confluence_data \</span><br><span class="line">    -v data_confluence_opt:&#x2F;opt&#x2F;atlassian&#x2F;confluence \</span><br><span class="line">    -v data_confluence_var:&#x2F;var&#x2F;atlassian&#x2F;confluence \</span><br><span class="line">    -d confluence&#x2F;confluence:6.13.0</span><br></pre></td></tr></table></figure>

<h4 id="启动容器，执行命令-1"><a href="#启动容器，执行命令-1" class="headerlink" title="启动容器，执行命令"></a>启动容器，执行命令</h4><p>docker run –detach –publish 8090:8090 confluence/confluence:6.13.0</p>
<p>打开浏览器访问 <a href="http://127.0.0.1:9006" target="_blank" rel="noopener">http://127.0.0.1:9006</a> ，可见confluence页面，可切换中文操作，在请指定你的许可证关键字时，把服务器ID记下，使用atlassian-agent.jar算号破解！！！操作如下：</p>
<ul>
<li>复制服务器ID:B6QG-R8VH-YCHH-8EY2</li>
<li>在本地存放”atlassian-agent.jar”的目录下执行命令，生成许可证：</li>
</ul>
<p>生成confluence许可命令参照如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置产品类型：-p conf， 详情可执行：java -jar atlassian-agent.jar </span><br><span class="line">java -jar atlassian-agent.jar -d -m test@test.com -n BAT -p conf -o http:&#x2F;&#x2F;192.168.0.89 -s BY9B-GWD1-1C78-K2DE</span><br></pre></td></tr></table></figure>

<h3 id="后台日志报错Establishing-SSL-connection-without解决"><a href="#后台日志报错Establishing-SSL-connection-without解决" class="headerlink" title="后台日志报错Establishing SSL connection without解决"></a>后台日志报错Establishing SSL connection without解决</h3><p>原因：MySQL5.7.6以上版本要默认要求使用SSL连接，如果不使用需要通过设置useSSL=false来声明。<br>解决方案：在mysql连接字符串url中加入useSSL=true或者false即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Confluence找到配置文件&#x2F;var&#x2F;atlassian&#x2F;confluence&#x2F;confluence.cfg.xml修改mysql连接字符串如下：</span><br><span class="line">jdbc:mysql:&#x2F;&#x2F;mysql&#x2F;confluence?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false</span><br><span class="line"></span><br><span class="line"># Jira找到配置文件&#x2F;var&#x2F;atlassian&#x2F;jira&#x2F;dbconfig.xml修改mysql连接字符串如下：</span><br><span class="line">jdbc:mysql:&#x2F;&#x2F;address&#x3D;(protocol&#x3D;tcp)(host&#x3D;mysql)(port&#x3D;3306)&#x2F;jira?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF8&amp;sessionVariables&#x3D;default_storage_engine&#x3D;InnoDB&amp;useSSL&#x3D;false</span><br></pre></td></tr></table></figure>

<h2 id="Jira-7-10-0-与Confluence-6-9-0-与Crowd-3-2-1"><a href="#Jira-7-10-0-与Confluence-6-9-0-与Crowd-3-2-1" class="headerlink" title="Jira(7.10.0)与Confluence(6.9.0)与Crowd(3.2.1)"></a><a href="https://www.jianshu.com/p/093cf14361ed" target="_blank" rel="noopener">Jira(7.10.0)</a>与<a href="https://www.jianshu.com/p/bda2638fdbc2" target="_blank" rel="noopener">Confluence(6.9.0)</a>与<a href="https://www.jianshu.com/p/963910d01795" target="_blank" rel="noopener">Crowd(3.2.1)</a></h2><ol>
<li>JDK1.8已经Mysql自己准备</li>
<li>JIRA版本: 7.10.0:<a href="https://www.atlassian.com/software/jira/download" target="_blank" rel="noopener">点击官方下载地址</a> &amp;&amp; atlassian-extras-3.2.jar</li>
<li>confluence：6.9.0：<a href="https://www.atlassian.com/software/confluence/download" target="_blank" rel="noopener">点击官方下载地址</a> &amp;&amp; atlassian-extras-decoder-v2-3.3.0.jar &amp;&amp; patch工具 </li>
<li>Crowd: 3.2.1:<a href="https://www.atlassian.com/software/crowd/download" target="_blank" rel="noopener">点击官方下载地址</a> &amp;&amp; atlassian-extras-3.2.jar<br><a href="https://pan.baidu.com/s/1wF8MJ4nq5aZQvGlHqtEMSw" target="_blank" rel="noopener">所有文件链接:</a> - 密码:6xzf</li>
</ol>
<h3 id="Jira-7-10-0"><a href="#Jira-7-10-0" class="headerlink" title="Jira(7.10.0)"></a>Jira(7.10.0)</h3><h4 id="传统方式安装和启动准备"><a href="#传统方式安装和启动准备" class="headerlink" title="传统方式安装和启动准备"></a>传统方式安装和启动准备</h4><ul>
<li>CentOS 7.x</li>
<li>JDK 1.8（配置好JAVA_HOME）</li>
<li>MYSQL 5.7.X（二进制安装或者Docker镜像）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 解压安装包</span><br><span class="line">cd your-path</span><br><span class="line">tar -xvf atlassian-jira-software-7.10.0.tar.gz</span><br><span class="line">mv &#x2F;your-path&#x2F;atlassian-jira-software-7.10.0-standalone&#x2F; &#x2F;your-path&#x2F;atlassian-jira-7.10.0</span><br><span class="line">## 配置环境变量JIRA_HOME</span><br><span class="line">vim ~&#x2F;.zshrc #看大家用的什么系统，环境文件有所不同</span><br><span class="line">export JIRA_HOME&#x3D;&#x2F;tmp&#x2F;jira-home</span><br><span class="line">## mysql的驱动Jar去官网下载一个适合5.7的即可</span><br><span class="line">cp mysql-connector-java-5.1.45.jar &#x2F;your-path&#x2F;atlassian-jira-7.10.0&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib</span><br><span class="line"># 请复制atlassian-extras-3.2.jar到&#x2F;your-path&#x2F;atlassian-jira-7.10.0&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib</span><br><span class="line">cp atlassian-extras-3.2.jar &#x2F;your-path&#x2F;atlassian-jira-7.10.0&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib</span><br><span class="line">## 启动</span><br><span class="line">&#x2F;your-path&#x2F;atlassian-jira-7.10.0&#x2F;bin&#x2F;start-jira.sh</span><br><span class="line"># 默认是8080端口，在浏览器打开http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h4><p>由于jira官方已经在docker有镜像，我们在官方镜像上面加入自定义的内容即可，<a href="https://github.com/cptactionhank/docker-atlassian-jira-software/tree/7.10.0" target="_blank" rel="noopener">官方的7.10.0的Dockerfile的Repo地址</a>，我们需要的是红框的2个文件，后面需要修改为自己Dockerfile来使用：<br><img src="/jira/0001.png" alt="0001" title="0001"></p>
<p>我在本地建立了一个Docker Build目录，包含下面几个文件</p>
<ul>
<li>Dockerfile（上面的官方repo下载）</li>
<li>atlassian-jira-software-7.10.0.tar.gz（官方二进制包，主要是Dockerfile里面的Curl自动下载的速度实在是慢的可以，我在提前下载好，COPY进去，这块不是非必须用这个包，可以依赖Dockerfile的Curl到官方下载安装包）</li>
<li>atlassian-extras-3.2.jar（百度网盘工具包）</li>
<li>docker-entrypoint.sh（上面的官方repo下载）</li>
<li>修改Dockerfile<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-alpine</span><br><span class="line"></span><br><span class="line"># Configuration variables.</span><br><span class="line">ENV JIRA_HOME     &#x2F;var&#x2F;atlassian&#x2F;jira</span><br><span class="line">ENV JIRA_INSTALL  &#x2F;opt&#x2F;atlassian&#x2F;jira</span><br><span class="line">ENV JIRA_VERSION  7.10.0</span><br><span class="line"></span><br><span class="line"># [新增]</span><br><span class="line">COPY atlassian-jira-software-$&#123;JIRA_VERSION&#125;.tar.gz &#x2F;tmp&#x2F;atlassian-jira-software-$&#123;JIRA_VERSION&#125;.tar.gz</span><br><span class="line">COPY atlassian-extras-3.2.jar &#x2F;tmp&#x2F;atlassian-extras-3.2.jar</span><br><span class="line"># [新增]</span><br><span class="line">RUN mkdir -p $&#123;JIRA_INSTALL&#125;</span><br><span class="line">RUN tar -xzvf &#x2F;tmp&#x2F;atlassian-jira-software-$&#123;JIRA_VERSION&#125;.tar.gz -C $&#123;JIRA_INSTALL&#125; --strip-components&#x3D;1 --no-same-owner \</span><br><span class="line">    &amp;&amp; mv $&#123;JIRA_INSTALL&#125;&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib&#x2F;atlassian-extras-3.2.jar $&#123;JIRA_INSTALL&#125;&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib&#x2F;atlassian-extras-3.2.jar.bak \</span><br><span class="line">    &amp;&amp; mv &#x2F;tmp&#x2F;atlassian-extras-3.2.jar $&#123;JIRA_INSTALL&#125;&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib \</span><br><span class="line">    &amp;&amp; rm -rf &#x2F;tmp&#x2F;atlassian-jira-software-$&#123;JIRA_VERSION&#125;.tar.gz</span><br><span class="line"></span><br><span class="line"># Install Atlassian JIRA and helper tools and setup initial home</span><br><span class="line"># directory structure.</span><br><span class="line">RUN set -x \</span><br><span class="line">    &amp;&amp; apk add --no-cache curl xmlstarlet bash ttf-dejavu libc6-compat \</span><br><span class="line">    &amp;&amp; mkdir -p                &quot;$&#123;JIRA_HOME&#125;&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p                &quot;$&#123;JIRA_HOME&#125;&#x2F;caches&#x2F;indexes&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;JIRA_HOME&#125;&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;JIRA_HOME&#125;&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p                &quot;$&#123;JIRA_INSTALL&#125;&#x2F;conf&#x2F;Catalina&quot; \</span><br><span class="line">    &amp;&amp; curl -Ls                &quot;https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;Connector-J&#x2F;mysql-connector-java-5.1.38.tar.gz&quot; | tar -xz --directory &quot;$&#123;JIRA_INSTALL&#125;&#x2F;lib&quot; --strip-components&#x3D;1 --no-same-owner &quot;mysql-connector-java-5.1.38&#x2F;mysql-connector-java-5.1.38-bin.jar&quot; \</span><br><span class="line">    &amp;&amp; rm -f                   &quot;$&#123;JIRA_INSTALL&#125;&#x2F;lib&#x2F;postgresql-9.4.1212.jar&quot; \ # [修改] 之前的要删除的jar发现lib没有</span><br><span class="line">    &amp;&amp; curl -Ls                &quot;https:&#x2F;&#x2F;jdbc.postgresql.org&#x2F;download&#x2F;postgresql-42.2.1.jar&quot; -o &quot;$&#123;JIRA_INSTALL&#125;&#x2F;lib&#x2F;postgresql-42.2.1.jar&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;JIRA_INSTALL&#125;&#x2F;conf&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;JIRA_INSTALL&#125;&#x2F;logs&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;JIRA_INSTALL&#125;&#x2F;temp&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;JIRA_INSTALL&#125;&#x2F;work&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;JIRA_INSTALL&#125;&#x2F;conf&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;JIRA_INSTALL&#125;&#x2F;logs&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;JIRA_INSTALL&#125;&#x2F;temp&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;JIRA_INSTALL&#125;&#x2F;work&quot; \</span><br><span class="line">    &amp;&amp; sed --in-place          &quot;s&#x2F;java version&#x2F;openjdk version&#x2F;g&quot; &quot;$&#123;JIRA_INSTALL&#125;&#x2F;bin&#x2F;check-java.sh&quot; \</span><br><span class="line">    &amp;&amp; echo -e                 &quot;\njira.home&#x3D;$JIRA_HOME&quot; &gt;&gt; &quot;$&#123;JIRA_INSTALL&#125;&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;classes&#x2F;jira-application.properties&quot; \</span><br><span class="line">    &amp;&amp; touch -d &quot;@0&quot;           &quot;$&#123;JIRA_INSTALL&#125;&#x2F;conf&#x2F;server.xml&quot;</span><br><span class="line"></span><br><span class="line"># Use the default unprivileged account. This could be considered bad practice</span><br><span class="line"># on systems where multiple processes end up being executed by &#39;daemon&#39; but</span><br><span class="line"># here we only ever run one process anyway.</span><br><span class="line">USER daemon:daemon</span><br><span class="line"></span><br><span class="line"># Expose default HTTP connector port.</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"># Set volume mount points for installation and home directory. Changes to the</span><br><span class="line"># home directory needs to be persisted as well as parts of the installation</span><br><span class="line"># directory due to eg. logs.</span><br><span class="line">VOLUME [&quot;&#x2F;var&#x2F;atlassian&#x2F;jira&quot;, &quot;&#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;logs&quot;]</span><br><span class="line"></span><br><span class="line"># Set the default working directory as the installation directory.</span><br><span class="line">WORKDIR &#x2F;var&#x2F;atlassian&#x2F;jira</span><br><span class="line"></span><br><span class="line">COPY &quot;docker-entrypoint.sh&quot; &quot;&#x2F;&quot;</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line"># Run Atlassian JIRA as a foreground process by default.</span><br><span class="line">CMD [&quot;&#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;bin&#x2F;start-jira.sh&quot;, &quot;-fg&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="执行build"><a href="#执行build" class="headerlink" title="执行build"></a>执行build</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;your-docker-build-path</span><br><span class="line">docker build -t michael&#x2F;atlassian-jira:7.10.0 .</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="启动镜像（配套如果使用MYSQL，建议Docker-Compose启动Jira-MYSQL）"><a href="#启动镜像（配套如果使用MYSQL，建议Docker-Compose启动Jira-MYSQL）" class="headerlink" title="启动镜像（配套如果使用MYSQL，建议Docker Compose启动Jira + MYSQL）"></a>启动镜像（配套如果使用MYSQL，建议Docker Compose启动Jira + MYSQL）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --rm --name&#x3D;jira -p 8080:8080 \</span><br><span class="line">-v &#x2F;Users&#x2F;liuyang&#x2F;CodeMonkey&#x2F;workspace&#x2F;docker-workspace&#x2F;jira&#x2F;home:&#x2F;var&#x2F;atlassian&#x2F;jira \</span><br><span class="line">-v &#x2F;Users&#x2F;liuyang&#x2F;CodeMonkey&#x2F;workspace&#x2F;docker-workspace&#x2F;jira&#x2F;logs:&#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;logs \</span><br><span class="line">michael&#x2F;atlassian-jira:7.10.0</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><img src="/jira/0002.png" alt="0002" title="0002"></p>
<ul>
<li><p>配置数据库<br><img src="/jira/0003.png" alt="0003" title="0003"></p>
</li>
<li><p>设置应用程序的属性<br><img src="/jira/0004.png" alt="0004" title="0004"></p>
</li>
<li><p>指定许可证（需要先去官网注册新账号，相当于注册一个试用的code，生成许可证）<br><img src="/jira/0005.png" alt="0005" title="0005"><br><img src="/jira/0006.png" alt="0006" title="0006"></p>
</li>
<li><p>配置管理员相关信息<br><img src="/jira/0007.png" alt="0007" title="0007"><br><img src="/jira/0008.png" alt="0008" title="0008"></p>
</li>
</ul>
<h3 id="Confluence-6-9-0"><a href="#Confluence-6-9-0" class="headerlink" title="Confluence(6.9.0)"></a>Confluence(6.9.0)</h3><h4 id="传统方式安装和启动准备-1"><a href="#传统方式安装和启动准备-1" class="headerlink" title="传统方式安装和启动准备"></a>传统方式安装和启动准备</h4><ul>
<li>CentOS 7.x</li>
<li>JDK 1.8（配置好JAVA_HOME）</li>
<li>MYSQL 5.7.X（二进制安装或者Docker镜像）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 解压安装包</span><br><span class="line">cd your-path</span><br><span class="line">tar -xvf atlassian-confluence-6.9.0.tar.gz</span><br><span class="line">## 指定工作目录</span><br><span class="line">vi &#x2F;your-path&#x2F;atlassian-confluence-6.9.0&#x2F;confluence&#x2F;WEB-INF&#x2F;classes&#x2F;confluence-init.properties</span><br><span class="line"># 在文件中加入 confluence.home&#x3D;&#x2F;your-home-path&#x2F;</span><br><span class="line">## 用下载的atlassian-extras-decoder-v2-3.3.0.jar覆盖原有Jar</span><br><span class="line">cp -aR &#x2F;your-path&#x2F;atlassian-extras-decoder-v2-3.3.0.jar &#x2F;your-path&#x2F;atlassian-confluence-6.9.0&#x2F;confluence&#x2F;WEB-INF&#x2F;lib&#x2F;</span><br><span class="line">## mysql的驱动Jar去官网下载一个适合5.7的即可</span><br><span class="line">cp mysql-connector-java-5.1.45.jar &#x2F;your-path&#x2F;atlassian-confluence-6.9.0&#x2F;confluence&#x2F;WEB-INF&#x2F;lib</span><br><span class="line">## 启动</span><br><span class="line">&#x2F;your-path&#x2F;atlassian-confluence-6.9.0&#x2F;bin&#x2F;start-confluence.sh</span><br><span class="line"># 默认是8090端口，在浏览器打开http:&#x2F;&#x2F;localhost:8090</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Docker方式安装-1"><a href="#Docker方式安装-1" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h4><p>由于官方已经有镜像，我们在官方镜像上面加入自定义的内容即可，<a href="https://github.com/cptactionhank/docker-atlassian-confluence/tree/6.9.0" target="_blank" rel="noopener">官方的6.9.0的Dockerfile的Repo地址</a>，我们需要的是红框的2个文件，后面需要修改使用，<br><img src="/jira/0009.png" alt="0009" title="0009"></p>
<p>建立了一个Docker Build目录，包含下面几个文件</p>
<ul>
<li>Dockerfile（上面的官方repo下载）</li>
<li>atlassian-confluence-6.9.0.tar.gz（官方二进制包，主要是Dockerfile里面的Curl自动下载的速度实在是慢的可以，我在提前下载好，COPY进去，这块不是非必须用这个包，可以依赖Dockerfile的Curl到官方下载安装包）</li>
<li>atlassian-extras-decoder-v2-3.3.0.jar（百度网盘工具包）</li>
<li>docker-entrypoint.sh（上面的官方repo下载）</li>
<li>修改Dockerfile<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-alpine</span><br><span class="line"></span><br><span class="line"># Setup useful environment variables</span><br><span class="line">ENV CONF_HOME     &#x2F;var&#x2F;atlassian&#x2F;confluence</span><br><span class="line">ENV CONF_INSTALL  &#x2F;opt&#x2F;atlassian&#x2F;confluence</span><br><span class="line">ENV CONF_VERSION  6.9.0</span><br><span class="line"></span><br><span class="line">ENV JAVA_CACERTS  $JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;security&#x2F;cacerts</span><br><span class="line">ENV CERTIFICATE   $CONF_HOME&#x2F;certificate</span><br><span class="line"></span><br><span class="line"># [新增] 把build目录的必要文件复制到镜像内</span><br><span class="line">COPY atlassian-confluence-$&#123;CONF_VERSION&#125;.tar.gz &#x2F;tmp&#x2F;atlassian-confluence-$&#123;CONF_VERSION&#125;.tar.gz</span><br><span class="line">COPY atlassian-extras-decoder-v2-3.3.0.jar &#x2F;tmp&#x2F;atlassian-extras-decoder-v2-3.3.0.jar</span><br><span class="line"></span><br><span class="line"># [新增] 创建Install目录，解压安装包，替换工具Jar包，删除安装包压缩文件</span><br><span class="line">RUN mkdir -p $&#123;CONF_INSTALL&#125;</span><br><span class="line">RUN tar -xzvf &#x2F;tmp&#x2F;atlassian-confluence-$&#123;CONF_VERSION&#125;.tar.gz -C $&#123;CONF_INSTALL&#125; --strip-components&#x3D;1 --no-same-owner \</span><br><span class="line">    &amp;&amp; mv $&#123;CONF_INSTALL&#125;&#x2F;confluence&#x2F;WEB-INF&#x2F;lib&#x2F;atlassian-extras-decoder-v2-3.3.0.jar $&#123;CONF_INSTALL&#125;&#x2F;confluence&#x2F;WEB-INF&#x2F;lib&#x2F;atlassian-extras-decoder-v2-3.3.0.jar.bak \</span><br><span class="line">    &amp;&amp; mv &#x2F;tmp&#x2F;atlassian-extras-decoder-v2-3.3.0.jar $&#123;CONF_INSTALL&#125;&#x2F;confluence&#x2F;WEB-INF&#x2F;lib \</span><br><span class="line">    &amp;&amp; rm -rf &#x2F;tmp&#x2F;atlassian-confluence-$&#123;CONF_VERSION&#125;.tar.gz</span><br><span class="line"></span><br><span class="line"># Install Atlassian Confluence and helper tools and setup initial home</span><br><span class="line"># directory structure.</span><br><span class="line">RUN set -x \</span><br><span class="line">    &amp;&amp; apk --no-cache add curl xmlstarlet bash ttf-dejavu libc6-compat gcompat \</span><br><span class="line">    &amp;&amp; mkdir -p                &quot;$&#123;CONF_HOME&#125;&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;CONF_HOME&#125;&quot; \</span><br><span class="line">    &amp;&amp; chown daemon:daemon     &quot;$&#123;CONF_HOME&#125;&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p                &quot;$&#123;CONF_INSTALL&#125;&#x2F;conf&quot; \</span><br><span class="line">    &amp;&amp; curl -Ls                &quot;https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;Connector-J&#x2F;mysql-connector-java-5.1.44.tar.gz&quot; | tar -xz --directory &quot;$&#123;CONF_INSTALL&#125;&#x2F;confluence&#x2F;WEB-INF&#x2F;lib&quot; --strip-components&#x3D;1 --no-same-owner &quot;mysql-connector-java-5.1.44&#x2F;mysql-connector-java-5.1.44-bin.jar&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;CONF_INSTALL&#125;&#x2F;conf&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;CONF_INSTALL&#125;&#x2F;temp&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;CONF_INSTALL&#125;&#x2F;logs&quot; \</span><br><span class="line">    &amp;&amp; chmod -R 700            &quot;$&#123;CONF_INSTALL&#125;&#x2F;work&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;CONF_INSTALL&#125;&#x2F;conf&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;CONF_INSTALL&#125;&#x2F;temp&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;CONF_INSTALL&#125;&#x2F;logs&quot; \</span><br><span class="line">    &amp;&amp; chown -R daemon:daemon  &quot;$&#123;CONF_INSTALL&#125;&#x2F;work&quot; \</span><br><span class="line">    &amp;&amp; echo -e                 &quot;\nconfluence.home&#x3D;$CONF_HOME&quot; &gt;&gt; &quot;$&#123;CONF_INSTALL&#125;&#x2F;confluence&#x2F;WEB-INF&#x2F;classes&#x2F;confluence-init.properties&quot; \</span><br><span class="line">    &amp;&amp; xmlstarlet              ed --inplace \</span><br><span class="line">        --delete               &quot;Server&#x2F;@debug&quot; \</span><br><span class="line">        --delete               &quot;Server&#x2F;Service&#x2F;Connector&#x2F;@debug&quot; \</span><br><span class="line">        --delete               &quot;Server&#x2F;Service&#x2F;Connector&#x2F;@useURIValidationHack&quot; \</span><br><span class="line">        --delete               &quot;Server&#x2F;Service&#x2F;Connector&#x2F;@minProcessors&quot; \</span><br><span class="line">        --delete               &quot;Server&#x2F;Service&#x2F;Connector&#x2F;@maxProcessors&quot; \</span><br><span class="line">        --delete               &quot;Server&#x2F;Service&#x2F;Engine&#x2F;@debug&quot; \</span><br><span class="line">        --delete               &quot;Server&#x2F;Service&#x2F;Engine&#x2F;Host&#x2F;@debug&quot; \</span><br><span class="line">        --delete               &quot;Server&#x2F;Service&#x2F;Engine&#x2F;Host&#x2F;Context&#x2F;@debug&quot; \</span><br><span class="line">                               &quot;$&#123;CONF_INSTALL&#125;&#x2F;conf&#x2F;server.xml&quot; \</span><br><span class="line">    &amp;&amp; touch -d &quot;@0&quot;           &quot;$&#123;CONF_INSTALL&#125;&#x2F;conf&#x2F;server.xml&quot; \</span><br><span class="line">    &amp;&amp; chown daemon:daemon     &quot;$&#123;JAVA_CACERTS&#125;&quot;</span><br><span class="line"></span><br><span class="line"># Use the default unprivileged account. This could be considered bad practice</span><br><span class="line"># on systems where multiple processes end up being executed by &#39;daemon&#39; but</span><br><span class="line"># here we only ever run one process anyway.</span><br><span class="line">USER daemon:daemon</span><br><span class="line"></span><br><span class="line"># Expose default HTTP connector port.</span><br><span class="line">EXPOSE 8090 8091</span><br><span class="line"></span><br><span class="line"># Set volume mount points for installation and home directory. Changes to the</span><br><span class="line"># home directory needs to be persisted as well as parts of the installation</span><br><span class="line"># directory due to eg. logs.</span><br><span class="line">VOLUME [&quot;&#x2F;var&#x2F;atlassian&#x2F;confluence&quot;, &quot;&#x2F;opt&#x2F;atlassian&#x2F;confluence&#x2F;logs&quot;]</span><br><span class="line"></span><br><span class="line"># Set the default working directory as the Confluence home directory.</span><br><span class="line">WORKDIR &#x2F;var&#x2F;atlassian&#x2F;confluence</span><br><span class="line"></span><br><span class="line">COPY docker-entrypoint.sh &#x2F;</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line"># Run Atlassian Confluence as a foreground process by default.</span><br><span class="line">CMD [&quot;&#x2F;opt&#x2F;atlassian&#x2F;confluence&#x2F;bin&#x2F;start-confluence.sh&quot;, &quot;-fg&quot;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="执行build-1"><a href="#执行build-1" class="headerlink" title="执行build"></a>执行build</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;your-docker-build-path</span><br><span class="line">docker build -t michael&#x2F;atlassian-confluence:6.9.0 .</span><br></pre></td></tr></table></figure>

<h4 id="启动镜像（配套如果使用MYSQL，建议Docker-Compose启动Confluence-MYSQL）"><a href="#启动镜像（配套如果使用MYSQL，建议Docker-Compose启动Confluence-MYSQL）" class="headerlink" title="启动镜像（配套如果使用MYSQL，建议Docker Compose启动Confluence + MYSQL）"></a>启动镜像（配套如果使用MYSQL，建议Docker Compose启动Confluence + MYSQL）</h4><p>docker run -d –rm –name=wiki -p 8090:8090 -p 8091:8091 <br>-v /your-confluence-path/home:/var/atlassian/confluence <br>-v /your-confluence-path/logs:/opt/atlassian/confluence/logs <br>michael/atlassian-confluence:6.9.0 </p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><ul>
<li>选择产品安装<br><img src="/jira/0010.png" alt="0010" title="0010"></li>
<li>点击下一步（省略了一步，授权码填写，用keygen，你懂得）<br><img src="/jira/0011.png" alt="0011" title="0011"></li>
<li>选择配置数据库<br><img src="/jira/0012.png" alt="0012" title="0012"></li>
<li>配置数据库并测试（我选择的是MYSQL，这里需要修改MYSQL事务隔离级别，改成transaction-isolation = READ-COMMITTED，读取已提交，Confluence要求的，会检查）<br><img src="/jira/0013.png" alt="0013" title="0013"><br><img src="/jira/0014.png" alt="0014" title="0014"></li>
<li>选择红框选项（Confluence有多种用户管理方式，为了单纯介绍Confluence，暂时不展开；剩余方式有：Jira数据库、Crowd数据库、LDAP数据库等等）<br><img src="/jira/0015.png" alt="0015" title="0015"><br><img src="/jira/0016.png" alt="0016" title="0016"></li>
</ul>
<h3 id="Crowd-3-2-1"><a href="#Crowd-3-2-1" class="headerlink" title="Crowd(3.2.1)"></a>Crowd(3.2.1)</h3><h4 id="Docker方式安装-2"><a href="#Docker方式安装-2" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h4><p>由于官方已经有镜像，我们在官方镜像上面加入自定义的内容即可，<a href="https://bitbucket.org/atlassian-docker/docker-atlassian-crowd/src/3.2.1/" target="_blank" rel="noopener">官方3.2.1镜像Repo</a>，我们需要的是红框的2个文件，如下（Repo托管是bitbucket）<br><img src="/jira/0017.png" alt="0017" title="0017"></p>
<p>建立了一个Docker Build目录，包含下面几个文件</p>
<ul>
<li>Dockerfile（上面的官方repo下载）</li>
<li>atlassian-crowd-3.2.1.tar.gz（官方二进制包，主要是Dockerfile里面的Curl自动下载的速度实在是慢的可以，我在提前下载好，COPY进去，这块不是非必须用这个包，可以依赖Dockerfile的Curl到官方下载安装包）</li>
<li>atlassian-extras-3.2.jar（百度网盘工具包）</li>
<li>mysql-connector-java-5.1.45.jar（Mysql官网下载一个）</li>
<li>entrypoint.sh（上面的官方repo下载）</li>
<li>修改Dockerfile<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">MAINTAINER Dave Chevell</span><br><span class="line"></span><br><span class="line">ENV RUN_USER            daemon</span><br><span class="line">ENV RUN_GROUP           daemon</span><br><span class="line"></span><br><span class="line"># https:&#x2F;&#x2F;confluence.atlassian.com&#x2F;crowd&#x2F;important-directories-and-files-78676537.html</span><br><span class="line">ENV CROWD_HOME          &#x2F;var&#x2F;atlassian&#x2F;application-data&#x2F;crowd</span><br><span class="line">ENV CROWD_INSTALL_DIR   &#x2F;opt&#x2F;atlassian&#x2F;crowd</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;$&#123;CROWD_HOME&#125;&quot;]</span><br><span class="line"></span><br><span class="line"># Expose HTTP port</span><br><span class="line">EXPOSE 8095</span><br><span class="line"></span><br><span class="line">WORKDIR $CROWD_HOME</span><br><span class="line"></span><br><span class="line">CMD [&quot;&#x2F;entrypoint.sh&quot;, &quot;-fg&quot;]</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;sbin&#x2F;tini&quot;, &quot;--&quot;]</span><br><span class="line"></span><br><span class="line">RUN apk add --no-cache wget curl openssh bash procps openssl perl ttf-dejavu tini</span><br><span class="line"></span><br><span class="line">COPY entrypoint.sh              &#x2F;entrypoint.sh</span><br><span class="line"></span><br><span class="line">ARG CROWD_VERSION&#x3D;3.2.1</span><br><span class="line"></span><br><span class="line">COPY atlassian-crowd-$&#123;CROWD_VERSION&#125;.tar.gz &#x2F;tmp&#x2F;atlassian-crowd-$&#123;CROWD_VERSION&#125;.tar.gz</span><br><span class="line">COPY atlassian-extras-3.2.jar &#x2F;tmp&#x2F;atlassian-extras-3.2.jar</span><br><span class="line">COPY mysql-connector-java-5.1.45.jar &#x2F;tmp&#x2F;mysql-connector-java-5.1.45.jar</span><br><span class="line"></span><br><span class="line">RUN mkdir -p                             $&#123;CROWD_INSTALL_DIR&#125; \</span><br><span class="line">    &amp;&amp; tar -xzvf &#x2F;tmp&#x2F;atlassian-crowd-$&#123;CROWD_VERSION&#125;.tar.gz -C $&#123;CROWD_INSTALL_DIR&#125; --strip-components&#x3D;1 --no-same-owner \</span><br><span class="line">    &amp;&amp; mv $&#123;CROWD_INSTALL_DIR&#125;&#x2F;crowd-webapp&#x2F;WEB-INF&#x2F;lib&#x2F;atlassian-extras-3.2.jar $&#123;CROWD_INSTALL_DIR&#125;&#x2F;crowd-webapp&#x2F;WEB-INF&#x2F;lib&#x2F;atlassian-extras-3.2.jar.bak \</span><br><span class="line">    &amp;&amp; mv &#x2F;tmp&#x2F;atlassian-extras-3.2.jar $&#123;CROWD_INSTALL_DIR&#125;&#x2F;crowd-webapp&#x2F;WEB-INF&#x2F;lib \</span><br><span class="line">    &amp;&amp; mv &#x2F;tmp&#x2F;mysql-connector-java-5.1.45.jar $&#123;CROWD_INSTALL_DIR&#125;&#x2F;crowd-webapp&#x2F;WEB-INF&#x2F;lib \</span><br><span class="line">    &amp;&amp; rm -rf &#x2F;tmp&#x2F;atlassian-crowd-$&#123;CROWD_VERSION&#125;.tar.gz \</span><br><span class="line">    &amp;&amp; chown -R $&#123;RUN_USER&#125;:$&#123;RUN_GROUP&#125; $&#123;CROWD_INSTALL_DIR&#125;&#x2F; \</span><br><span class="line">    &amp;&amp; sed -i -e &#39;s&#x2F;-Xms\([0-9]\+[kmg]\) -Xmx\([0-9]\+[kmg]\)&#x2F;-Xms\$&#123;JVM_MINIMUM_MEMORY:&#x3D;\1&#125; -Xmx\$&#123;JVM_MAXIMUM_MEMORY:&#x3D;\2&#125; \$&#123;JVM_SUPPORT_RECOMMENDED_ARGS&#125; -Dcrowd.home&#x3D;\$&#123;CROWD_HOME&#125;&#x2F;g&#39; $&#123;CROWD_INSTALL_DIR&#125;&#x2F;apache-tomcat&#x2F;bin&#x2F;setenv.sh \</span><br><span class="line">    &amp;&amp; sed -i -e &#39;s&#x2F;port&#x3D;&quot;8095&quot;&#x2F;port&#x3D;&quot;8095&quot; secure&#x3D;&quot;$&#123;catalinaConnectorSecure&#125;&quot; scheme&#x3D;&quot;$&#123;catalinaConnectorScheme&#125;&quot; proxyName&#x3D;&quot;$&#123;catalinaConnectorProxyName&#125;&quot; proxyPort&#x3D;&quot;$&#123;catalinaConnectorProxyPort&#125;&quot;&#x2F;&#39; $&#123;CROWD_INSTALL_DIR&#125;&#x2F;apache-tomcat&#x2F;conf&#x2F;server.xml</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="执行build-2"><a href="#执行build-2" class="headerlink" title="执行build"></a>执行build</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;your-docker-build-path</span><br><span class="line">docker build -t michael&#x2F;atlassian-crowd:3.2.1 .</span><br></pre></td></tr></table></figure>

<h4 id="启动镜像（配套如果使用MYSQL，建议Docker-Compose启动Jira-MYSQL）-1"><a href="#启动镜像（配套如果使用MYSQL，建议Docker-Compose启动Jira-MYSQL）-1" class="headerlink" title="启动镜像（配套如果使用MYSQL，建议Docker Compose启动Jira + MYSQL）"></a>启动镜像（配套如果使用MYSQL，建议Docker Compose启动Jira + MYSQL）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --rm --name&#x3D;&quot;crowd&quot; \</span><br><span class="line">-v &#x2F;your-path&#x2F;crowd:&#x2F;var&#x2F;atlassian&#x2F;application-data&#x2F;crowd  \</span><br><span class="line">-p 8095:8095 \</span><br><span class="line">-e &quot;JVM_MINIMUM_MEMORY&#x3D;384m&quot;</span><br><span class="line">-e &quot;JVM_MAXIMUM_MEMORY&#x3D;768m&quot;</span><br><span class="line">michael&#x2F;atlassian-crowd:3.2.1</span><br></pre></td></tr></table></figure>

<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><ul>
<li>打开<a href="http://ip:8095，点击Set">http://ip:8095，点击Set</a> up Crowd<br><img src="/jira/0018.png" alt="0018" title="0018"></li>
<li>用百度网盘的包，进行操作，进入下一步</li>
<li>选择New installation<br><img src="/jira/0019.png" alt="0019" title="0019"></li>
<li>配置数据库<br><img src="/jira/0020.png" alt="0020" title="0020"></li>
<li>其他信息确认<br><img src="/jira/0021.png" alt="0021" title="0021"></li>
<li>默认管理员信息<br><img src="/jira/0022.png" alt="0022" title="0022"></li>
</ul>
<h2 id="JIRA-7-8-详细版本"><a href="#JIRA-7-8-详细版本" class="headerlink" title="JIRA(7.8)详细版本"></a><a href="https://www.cnblogs.com/houchaoying/p/9096118.html" target="_blank" rel="noopener">JIRA(7.8)详细版本</a></h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>jira的运行是依赖java环境的，也就是说需要安装jdk并且要是1.8以上版本<br><img src="/jira/01.png" alt="01" title="01"></p>
<p>除此之外，我们还需要安装MySQL，为jira创建对应的数据库、用户名和密码，如下：<br>注意：建库名jira,字符集为UTF-8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p&#39;kans123QWE&#39; -e &quot;create database jira default character set utf8 collate utf8_bin;grant all on jira.* to &#39;jira@’%&#39; identified by &#39;jirapasswd&#39;;&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/jira/01.png" alt="02" title="02"><br><img src="/jira/01.png" alt="03" title="03"><br><img src="/jira/01.png" alt="04" title="04"></p>
<h3 id="下载并安装jira。"><a href="#下载并安装jira。" class="headerlink" title="下载并安装jira。"></a>下载并安装jira。</h3><p>查看Linux系统是多少位的下载相应的版本<br><img src="/jira/05.png" alt="05" title="05"></p>
<p><a href="https://www.atlassian.com/software/jira/download" target="_blank" rel="noopener">jira 的下载网站</a><br><img src="/jira/06.png" alt="06" title="06"></p>
<p>wget  <a href="https://downloads.atlassian.com/software/jira/downloads/atlassian-jira-software-7.8.1-x64.bin" target="_blank" rel="noopener">https://downloads.atlassian.com/software/jira/downloads/atlassian-jira-software-7.8.1-x64.bin</a><br><img src="/jira/07.png" alt="07" title="07"></p>
<h3 id="开始安装jira"><a href="#开始安装jira" class="headerlink" title="开始安装jira"></a>开始安装jira</h3><p><img src="/jira/08.png" alt="08" title="08"><br><img src="/jira/09.png" alt="09" title="09"><br><img src="/jira/10.png" alt="10" title="10"><br><img src="/jira/11.png" alt="11" title="11"><br><img src="/jira/12.png" alt="12" title="12"></p>
<p>通过上图，我们可以很明显的看出jira安装到了/opt/atlassian/jira和/var/atlassian/application-data/jira目录下，并且jira监听的端口是8080。<br>jira的主要配置文件，存放在/opt/atlassian/jira/conf/server.xml文件中<br> vim /opt/atlassian/jira/conf/server.xml<br><img src="/jira/13.png" alt="13" title="13"></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><img src="/jira/14.png" alt="14" title="14"><br><img src="/jira/15.png" alt="15" title="15"><br>现在我们先关闭jira，然后把破解包里面的atlassian-extras-3.2.jar和mysql-connector-java-5.1.39-bin.jar两个文件复制到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下。<br>其中atlassian-extras-3..2.jar是用来替换原来的atlassian-extras-3.2.jar文件，用作破解jira系统的。<br>而mysql-connector-java-5.1.39-bin.jar是用来连接mysql数据库的驱动软件包。</p>
<h3 id="安装破解"><a href="#安装破解" class="headerlink" title="安装破解"></a>安装破解</h3><p><img src="/jira/16.png" alt="16" title="16"></p>
<p>在/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/这个目录下，找到atlassian-extras-的包看看是3点几的 然后现在对应的破解包，替换这个<br><img src="/jira/17.png" alt="17" title="17"></p>
<p>替换<br><img src="/jira/18.png" alt="18" title="18"></p>
<p>放置连接mysql数据库的包<br><img src="/jira/19.png" alt="19" title="19"></p>
<p>然后启动 就可以ip:8080访问了<br><img src="/jira/20.png" alt="20" title="20"></p>
<p>ip:8080页面安装<br><img src="/jira/21.png" alt="21" title="21"></p>
<p><img src="/jira/22.png" alt="22" title="22"></p>
<p>填写好后测试连接一下看看是否成功，在下一步<br><img src="/jira/23.png" alt="23" title="23"></p>
<p>然后下一步，因为要初始化数据库 要等会<br><img src="/jira/24.png" alt="24" title="24"></p>
<p>而连接数据库的配置是/var/atlassian/application-data/jira/dbconfig.xml，如下：<br>cat /var/atlassian/application-data/jira/dbconfig.xml<br><img src="/jira/25.png" alt="25" title="25"></p>
<p>下面的配置就比较简单了，自定义也可以，默认也可以。<br><img src="/jira/26.png" alt="26" title="26"></p>
<p>注意：上图中的Mode中，我们在此使用的是Private（私有）模式，在这个模式下，用户的创建需要由管理员创建。而在Public（共用）模式下，用户是可以自己进行注册。<br>下面这个页面是需要我们输入jira的license，如下：<br><img src="/jira/27.png" alt="27" title="27"></p>
<p>注意：上图中的Server ID：BSG9-24QF-8M40-O1CT<br>因为我们没有正式的license，所以需要我们在jira官网注册一个账号，然后利用这个账号申请一个可以试用30天的license，点击生成jira许可证。如下：<br><img src="/jira/28.png" alt="28" title="28"></p>
<p>注意：这个图中的Server ID就是我们上面刚刚截图的Server ID。<br><img src="/jira/29.png" alt="29" title="29"></p>
<p>点击yes 上面的key 就会自动复制到你的许可征<br><img src="/jira/30.png" alt="30" title="30"></p>
<p>密码我设的lilili用户lili<br><img src="/jira/31.png" alt="31" title="31"></p>
<p><img src="/jira/32.png" alt="32" title="32"></p>
<p><img src="/jira/33.png" alt="33" title="33"></p>
<p><img src="/jira/34.png" alt="34" title="34"></p>
<p> 创建第一个项目，如下：<br><img src="/jira/35.png" alt="35" title="35"><br><img src="/jira/36.png" alt="36" title="36"><br><img src="/jira/37.png" alt="37" title="37"><br><img src="/jira/38.png" alt="38" title="38"><br><img src="/jira/39.png" alt="39" title="39"></p>
<p>到此 jira 7.8的安装就好了，现在看看jira的破解<br>破解jira，其实我们已经破解了在前面复制atlassian-extras-3.1.2.jar到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下时，再次启动jira时就已经破解了。我们现在登陆到jira中查看授权信息，如下：<br><img src="/jira/40.png" alt="40" title="40"><br><img src="/jira/41.png" alt="41" title="41"></p>
<p>通过上图，我们可以很明显的看到jira我们可以使用到2033年，。到此有关jira的安装、破解就已经全部结束。<br>如何修改内存？<br>vim /opt/atlassian/jira/bin/setenv.sh<br><img src="/jira/42.png" alt="42" title="42"></p>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p>tail -f /opt/atlassian/jira/logs/catalina.out</p>
<h2 id="jira-8-0-2"><a href="#jira-8-0-2" class="headerlink" title="jira(8.0.2)"></a><a href="https://www.cnblogs.com/qiangyuzhou/p/10530937.html" target="_blank" rel="noopener">jira(8.0.2)</a></h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>centos7.4</li>
<li>java1.8</li>
<li>jira版本：8.0.2</li>
<li>mysql ：mariadb</li>
</ul>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p>破解包： atlassian-extras-3.2.jar<br>连接mysql驱动：mysql-connector-java-5.1.42.jar<br><a href="https://www.atlassian.com/software/jira/download" target="_blank" rel="noopener">软件可以到官网下载最新版本</a>：jira-8.0.2<br><a href="https://pan.baidu.com/s/1-P3V47GUhEuZB3wVlOIpvg" target="_blank" rel="noopener">下载地址</a> 提取码:rjxd </p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mariadb mariadb-server</span><br><span class="line">systemctl start mariadb</span><br><span class="line">systemctl enablemariadb</span><br></pre></td></tr></table></figure>
<ul>
<li><p>mysql操作：<br>首先是设置密码，会提示先输入密码<br>Enter current password for root (enter fornone):&lt;–初次运行直接回车</p>
</li>
<li><p>设置密码<br>Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车<br>New password: &lt;– 设置root用户的密码<br>Re-enter new password: &lt;– 再输入一次你设置的密码</p>
</li>
<li><p>其他配置<br>Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车<br>Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车,<br>Remove test database and access to it?[Y/n] &lt;– 是否删除test数据库，回车<br>Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车<br>退出重新登录ok</p>
</li>
<li><p>mysql配置文件修改<br>接下来配置MariaDB的字符集:</p>
</li>
</ul>
<ol>
<li><p>-&gt; 首先是配置文件/etc/my.cnf，在[mysqld]标签下添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init_connect&#x3D;&#39;SET collation_connection &#x3D;utf8_unicode_ci&#39;</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">collation-server&#x3D;utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">max_allowed_packet&#x3D;256M</span><br><span class="line">transaction-isolation&#x3D;READ-COMMITTED</span><br></pre></td></tr></table></figure>
</li>
<li><p>-&gt;接着配置文件/etc/my.cnf.d/client.cnf，在[client]中添加<br>default-character-set=utf8</p>
</li>
<li><p>-&gt; 然后配置文件/etc/my.cnf.d/mysql-clients.cnf，在[mysql]中添加<br>default-character-set=utf8</p>
</li>
</ol>
<ul>
<li>初始化数据及授权：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database jira default character set utf8 collate utf8_bin;</span><br><span class="line">grant all on jira.* to &#39;jira@’%&#39; identified by &#39;jira&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="jdk安装"><a href="#jdk安装" class="headerlink" title="jdk安装"></a>jdk安装</h4><p><a href="https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz" target="_blank" rel="noopener">官方软件下载</a><br>下载完成后进行解压到:/usr/local/java<br>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib</span><br><span class="line"></span><br><span class="line">cd &#x2F;usr&#x2F;bin</span><br><span class="line">ln -s -f  &#x2F;usr&#x2F;local&#x2F;java&#x2F;bin&#x2F;javac</span><br><span class="line">ln -s  -f &#x2F;usr&#x2F;local&#x2F;java&#x2F;jre&#x2F;bin&#x2F;java</span><br></pre></td></tr></table></figure>

<h3 id="jira-8-0-2-安装"><a href="#jira-8-0-2-安装" class="headerlink" title="jira(8.0.2)安装"></a>jira(8.0.2)安装</h3><ol>
<li>将/opt/atlassian/jira/atlassian-jira/WEB-INF/lib  中的atlassian-extras-3.2.jar删除</li>
<li>copy最新的破解包到此目录：/opt/atlassian/jira/atlassian-jira/WEB-INF/lib</li>
</ol>
<p>mysql数据库选择5.6<br>主机名：ip<br>数据库名：jira<br>密码：jira</p>
<p>测试正常后，进入授权码页面，<a href="https://my.atlassian.com/product" target="_blank" rel="noopener">https://my.atlassian.com/product</a><br>选择jira soft 生产授权码</p>
<p>安装完成，重启jira<br>/etc/init.d/jira stop<br>/etc/init.d/jira start</p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Jira</tag>
        <tag>Confluence</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 基础知识</title>
    <url>/2021/06/07/PluginTool-Maven/</url>
    <content><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>在一个maven项目中，如果存在编译需要而发布不需要的jar包，可以用scope标签，值设为provided。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;classifier &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>scope的其他参数如下：</p>
<ul>
<li><p>compile:如编译时期找不到对应的引用<br>  默认值。compile表示对应依赖会参与当前项目的编译、测试、运行等，是一个比较强的依赖。打包时通常会包含该依赖，部署时会打包到lib目录下。比如：spring-core这些核心的jar包。</p>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
  </dependency></li>
<li><p>provided<br>  provided适合在编译和测试的环境，和compile功能相似，但provide仅在编译和测试阶段生效，provide不会被打包，项目与项目之间也不具有传递性。比如：上面讲到的spring-boot-devtools、servlet-api等，前者是因为不需要在生产中热部署，后者是因为容器已经提供，不需要重复引入。</p>
  <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <scope>provided</scope>
  </dependency>
</li>
<li><p>runtime:如1/0时的判断,只有执行到这行代码才知道错误<br>  runntime仅仅适用于运行和测试环节，在编译环境下不会被使用。比如编译时只需要JDBC API的jar，而只有运行时才需要JDBC驱动实现。</p>
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.20</version>
      <scope>runtime</scope>
  </dependency></li>
<li><p>test<br>  scope为test表示依赖项目仅参与测试环节，在编译、运行、打包时不会使用。最常见的使用就是单元测试类了：</p>
  <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
  </dependency></li>
<li><p>system<br>system范围依赖与provided类似，不过依赖项不会从maven仓库获取，而需要从本地文件系统提供。使用时，一定要配合systemPath属性。不推荐使用，尽量从Maven库中引用依赖。</p>
  <dependency>
      <groupId>sun.jdk</groupId>
      <artifactId>tools</artifactId>
      <version>1.5.0</version>
      <scope>system</scope>
      <systemPath>${java.home}/../lib/tools.jar</systemPath>
  </dependency>
</li>
<li><p>optional</p>
</li>
<li><p>这里的optional元素设置为true表示何意？optional是Maven依赖jar时的一个选项，表示该依赖是可选的，项目之间依赖不传递。不设置optional（默认）或者optional是false，表示传递依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;A的pom文件。</span><br><span class="line">&lt;project .....&gt;</span><br><span class="line">    &lt;groupId&gt;A&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;A&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;joda-time&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;joda-time&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.9&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line">&#x2F;&#x2F;B的pom文件直接引入A项目会继承A引入的包:</span><br><span class="line">&lt;project ....&gt;</span><br><span class="line">    &lt;groupId&gt;B&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;B&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;A&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;A&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>在A工程对joda-time添加optional选项<optional>true</optional>，这时在B工程中，joda-time依赖包会消失.<br>如果B想引这个包，需要在A项目中设optional为false或者去除optional，或者在B项目重新引入调用。</p>
</li>
</ul>
<h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;A&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;A&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;joda-time&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;joda-time&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.9.9&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line">&lt;project .....&gt;</span><br><span class="line">    &lt;groupId&gt;B&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;B&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;A&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;A&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>A中加入 <optional>true</optional>，则B不会继承到 jar 包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;B再去引用的话，还是可以正常引用joda-time包，optional选项在统一控制版本的情况下会失效。</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;joda-time&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;joda-time&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;B</span><br></pre></td></tr></table></figure>

<h2 id="Maven-内置属性使用"><a href="#Maven-内置属性使用" class="headerlink" title="Maven 内置属性使用"></a>Maven 内置属性使用</h2><h3 id="内置属性-Maven预定义-用户可以直接使用"><a href="#内置属性-Maven预定义-用户可以直接使用" class="headerlink" title="内置属性(Maven预定义,用户可以直接使用)"></a>内置属性(Maven预定义,用户可以直接使用)</h3><p>${basedir}表示项目根目录,即包含pom.xml文件的目录;<br>${version}表示项目版本;<br>${project.basedir}同 ${basedir};<br>${project.baseUri}表示项目文件地址;<br>${maven.build.timestamp}表示项目构件开始时间;<br>${maven.build.timestamp.format}表示属性 ${maven.build.timestamp}的展示格式,默认值为yyyyMMdd-HHmm,可自定义其格式,其类型可参考java.text.SimpleDateFormat。用法如下：<br><properties><br>    &lt;maven.build.timestamp.format&gt;yyyy-MM-dd HH:mm:ss&lt;/maven.build.timestamp.format&gt;<br></properties></p>
<h3 id="POM属性-使用pom属性可以引用到pom-xml文件对应元素的值"><a href="#POM属性-使用pom属性可以引用到pom-xml文件对应元素的值" class="headerlink" title="POM属性(使用pom属性可以引用到pom.xml文件对应元素的值)"></a>POM属性(使用pom属性可以引用到pom.xml文件对应元素的值)</h3><p>用户可以使用该属性引用POM文件中对应元素的值，常用的POM属性包括：</p>
<p>${project.build.sourceDirectory}：项目的主源码目录，默认为 src/main/java<br>${project.build.testSourceDirectory}：项目的测试源码目录，默认为 src/test/java<br>${project.build.directory}：项目构件输出目录，默认为 target/<br>${project.outputDirectory}：项目主代码编译输出目录，默认为 target/classes/<br>${project.testOutputDirectory}：项目测试代码编译输出目录，默认为 target/test-classes/<br>${project.groupId}：项目的 groupId<br>${project.artifactId}：项目的 artifactId</p>
<p>project.version项目的project.version， 与 {project.version}：项目的 version，与project.version：项目的version，与{version}等价<br>project.build.finalName： 项 目 打 包 输 出 文 件 的 名 称 。 默 认 为 {project.build.fianlName}：项目打包输出文件的名称。默认为project.build.fianlName：项目打包输出文件的名称。默认为{project.artifactId}-${project.version}</p>
<h3 id="Java系统属性-所有的Java系统属性都可以使用Maven属性引用"><a href="#Java系统属性-所有的Java系统属性都可以使用Maven属性引用" class="headerlink" title="Java系统属性(所有的Java系统属性都可以使用Maven属性引用)"></a>Java系统属性(所有的Java系统属性都可以使用Maven属性引用)</h3><p>使用mvn help:system命令可查看所有的Java系统属性;<br>System.getProperties()可得到所有的Java属性;<br>${user.home}表示用户目录;</p>
<h3 id="环境变量属性-所有的环境变量都可以用以env-开头的Maven属性引用"><a href="#环境变量属性-所有的环境变量都可以用以env-开头的Maven属性引用" class="headerlink" title="环境变量属性(所有的环境变量都可以用以env.开头的Maven属性引用)"></a>环境变量属性(所有的环境变量都可以用以env.开头的Maven属性引用)</h3><p>使用mvn help:system命令可查看所有环境变量;<br>${env.JAVA_HOME}表示JAVA_HOME环境变量的值;</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Memcached</title>
    <url>/2021/01/09/PluginTool-Memcached/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2021/01/09/PluginTool-MongoDB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman使用</title>
    <url>/2021/04/23/PluginTool-Postman%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Postman安装说明"><a href="#Postman安装说明" class="headerlink" title="Postman安装说明"></a>Postman安装说明</h2><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p><a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">postman官方网站</a></p>
<h3 id="界面导航说明"><a href="#界面导航说明" class="headerlink" title="界面导航说明"></a>界面导航说明</h3><p><img src="/postman/1.png" alt="界面导航说明" title="界面导航说明"></p>
<h3 id="常见4种类型的接口请求"><a href="#常见4种类型的接口请求" class="headerlink" title="常见4种类型的接口请求"></a>常见4种类型的接口请求</h3><h4 id="查询参数的接口请求"><a href="#查询参数的接口请求" class="headerlink" title="查询参数的接口请求"></a>查询参数的接口请求</h4><p>具体实现步骤：</p>
<ol>
<li>打开postman，新建一个请求。</li>
<li>在请求方法中选择请求方法：GET,因为在postman中默认的请求方法就是GET,所以这一步可以忽略</li>
<li>接口URL中输入地址，点击Send按钮就可以发送请求了<br><img src="/postman/2.png" alt="查询参数的接口请求" title="查询参数的接口请求"></li>
</ol>
<h4 id="表单类型的接口请求"><a href="#表单类型的接口请求" class="headerlink" title="表单类型的接口请求"></a>表单类型的接口请求</h4><p>具体实现步骤：</p>
<ol>
<li>打开postman，新建一个请求</li>
<li>在请求中设置以上四个参数，点击Send按钮。在postman中设置请求体类型为，需要选择body-&gt; x-www-form-urlencoded</li>
<li>查看响应数据。<br><img src="/postman/3.png" alt="表单类型的接口请求" title="表单类型的接口请求"></li>
</ol>
<h4 id="上传文件的表单请求"><a href="#上传文件的表单请求" class="headerlink" title="上传文件的表单请求"></a>上传文件的表单请求</h4><ol>
<li>打开postman，新建一个请求</li>
<li>在请求中设置以上四个参数，点击Send按钮。<br> 注意：在postman中设置请求体类型，需要选择body-&gt; form-datafile中要选择File类型，然后上传本地的文件 </li>
<li>查看响应数据。<br><img src="/postman/4.png" alt="上传文件的表单请求" title="上传文件的表单请求"></li>
</ol>
<h4 id="json类型的接口请求"><a href="#json类型的接口请求" class="headerlink" title="json类型的接口请求"></a>json类型的接口请求</h4><p>具体实现步骤：<br>打开postman，新建一个请求<br>在请求中设置以上四个参数，点击Send按钮。注意：在postman中设置请求体类型，需要选择body-&gt; raw -JSON<br>查看响应数据。<br><img src="/postman/5.png" alt="json类型的接口请求" title="json类型的接口请求"></p>
<h3 id="响应数据解析"><a href="#响应数据解析" class="headerlink" title="响应数据解析"></a>响应数据解析</h3><p><img src="/postman/6.png" alt="响应数据解析" title="响应数据解析"></p>
<h4 id="接口管理-Collection"><a href="#接口管理-Collection" class="headerlink" title="接口管理(Collection)"></a>接口管理(Collection)</h4><p>先对Collection功能的使用场景做个简单总结</p>
<ol>
<li>用例分类管理，方便后期维护</li>
<li>可以进行批量用例回归测试<br>实现步骤：</li>
<li>点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）<br><img src="/postman/7.png" alt="Collection7" title="Collection7"></li>
<li>选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）<br><img src="/postman/8.png" alt="Collection8" title="Collection8"></li>
<li>选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例<br><img src="/postman/9.png" alt="Collection9" title="Collection9"><br>那么通过以上三个步骤，达到的效果就是如图所示：<br><img src="/postman/10.png" alt="Collection10" title="Collection10"></li>
</ol>
<h4 id="批量执行接口请求"><a href="#批量执行接口请求" class="headerlink" title="批量执行接口请求"></a>批量执行接口请求</h4><ol>
<li>选中一个Collection，点击右三角，在弹出的界面点击RUN<br><img src="/postman/11.png" alt="Collection11" title="Collection11"></li>
<li>这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选中<br><img src="/postman/12.png" alt="Collection12" title="Collection12"></li>
<li>点击界面下方的RUN Collection，就会对Collection中选中的所有测试用例运行<br><img src="/postman/13.png" alt="Collection13" title="Collection13"></li>
</ol>
<ul>
<li>断言统计：左上角的两个0是统计当前Collection中断言成功的执行数和失败的执行数，如果没有编写断言默认都为0</li>
<li>Run Summary: 运行结果总览，点击它可以看到每个请求中具体的测试断言详细信息。Export Result：导出运行结果，默认导出的结果json文件</li>
<li>Retry: 重新运行，点击它会把该Collection重新运行一遍</li>
<li>New：返回到Runner，可以重新选择用例的组合.</li>
</ul>
<h3 id="日志调试"><a href="#日志调试" class="headerlink" title="日志调试"></a>日志调试</h3><p><img src="/postman/14.png" alt="Collection14" title="Collection14"><br>那么打印的日如何看呢 ？ 在postman中有俩个入口，第一个入口就是：view-show postman console<br>第二个入口就是左下角第三个图标<br><img src="/postman/15.png" alt="Collection15" title="Collection15"><br>打开的日志界面<br><img src="/postman/16.png" alt="Collection16" title="Collection16"><br>这里面有几个比较实用的功能：</p>
<ol>
<li>搜索日志：输入URL或者打印的日志就能直接搜索出我们想要的请求和日志，这对我们在众多日志中查找某一条日志是非常方便的 。</li>
<li>按级别搜索：可以查询log,info,warning,error级别的日志 ，有助于我们更快定位到错误 。</li>
<li>查看原始报文(Show raw log)：如果习惯看原始请求报文的话，这个功能可能更方便些 。</li>
<li>隐藏请求(Hide network)：把请求都隐藏掉，只查看输出日志 </li>
</ol>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>具体如下</p>
<ol>
<li>断言编写位置：Tests标签</li>
<li>断言所用语言：JavaScript</li>
<li>断言执行顺序：在响应体数据返回后执行 。</li>
<li>断言执行结果查看：Test Results<br><img src="/postman/17.png" alt="断言" title="断言"><br>在上面我们介绍到，编写的断言代码是JavaScript，那如果不会写怎么办 ？ 不用担心，因为postman已经给我们内置了一些常用的断言 。用的时候，只需从右侧点击其中一个断言，就会在文本框中自动生成对应断言代码块</li>
</ol>
<h4 id="状态行中的断言"><a href="#状态行中的断言" class="headerlink" title="状态行中的断言"></a>状态行中的断言</h4><ul>
<li><p>断言状态码：Status code: code is 200</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.test(&quot;Status code is 200&quot;, function () &#123;</span><br><span class="line">    pm.response.to.have.status(200);        &#x2F;&#x2F;这里填写的200是预期结果，实际结果是请求返回结果</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言状态消息：Status code：code name has string</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.test(&quot;Status code name has string&quot;, function () &#123;</span><br><span class="line">    pm.response.to.have.status(&quot;OK&quot;);   &#x2F;&#x2F;断言响应状态消息包含OK</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言响应头中包含：Response headers:Content-Type header check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.test(&quot;Content-Type is present&quot;, function () &#123;</span><br><span class="line">    pm.response.to.have.header(&quot;Content-Type&quot;); &#x2F;&#x2F;断言响应头存在&quot;Content-Type&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言响应体中包含XXX字符串：Response body:Contains string</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.test(&quot;Body matches string&quot;, function () &#123;</span><br><span class="line">    pm.expect(pm.response.text()).to.include(&quot;string_you_want_to_search&quot;);</span><br><span class="line">&#125;);     </span><br><span class="line">&#x2F;&#x2F;注解</span><br><span class="line">pm.expect(pm.response.text()).to.include(&quot;string&quot;)      获取响应文本中包含string</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言响应体等于XXX字符串：Response body : is equal to a string</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.test(&quot;Body is correct&quot;, function () &#123;</span><br><span class="line">    pm.response.to.have.body(&quot;response_body_string&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;注解</span><br><span class="line">pm.response.to.have.body(&quot;response_body_string&quot;);   获取响应体等于response_body_string</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言响应体(json)中某个键名对应的值：Response body : JSON value check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.test(&quot;Your test name&quot;, function () &#123;</span><br><span class="line">    var jsonData &#x3D; pm.response.json();</span><br><span class="line">    pm.expect(jsonData.value).to.eql(100);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;注解</span><br><span class="line">var jsonData &#x3D; pm.response.json()   获取响应体，以json显示，赋值给jsonData .注意：该响应体必须返会是的json，否则会报错</span><br><span class="line">pm.expect(jsonData.value).to.eql(100)  获取jsonData中键名为value的值，然后和100进行比较</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言响应时间：Response time is less than 200ms</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.test(&quot;Response time is less than 200ms&quot;, function () &#123;</span><br><span class="line">    pm.expect(pm.response.responseTime).to.be.below(200);   &#x2F;&#x2F;断言响应时间&lt;200ms</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cityid&quot;: &quot;101120101&quot;,</span><br><span class="line">    &quot;city&quot;: &quot;济南&quot;,</span><br><span class="line">    &quot;update_time&quot;: &quot;2020-04-17 10:50&quot;,</span><br><span class="line">    &quot;wea&quot;: &quot;晴&quot;,</span><br><span class="line">    &quot;wea_img&quot;: &quot;qing&quot;,</span><br><span class="line">    &quot;tem&quot;: &quot;16&quot;,</span><br><span class="line">    &quot;tem_day&quot;: &quot;20&quot;,</span><br><span class="line">    &quot;tem_night&quot;: &quot;9&quot;,</span><br><span class="line">    &quot;win&quot;: &quot;东北风&quot;,</span><br><span class="line">    &quot;win_speed&quot;: &quot;3级&quot;,</span><br><span class="line">    &quot;win_meter&quot;: &quot;小于12km&#x2F;h&quot;,</span><br><span class="line">    &quot;air&quot;: &quot;113&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>断言响应状态码为200</li>
<li>断言city等于济南</li>
<li>断言update_time包含2020-04-17<br><img src="/postman/18.png" alt="断言" title="断言"></li>
</ul>
<h3 id="变量-全局-集合-环境"><a href="#变量-全局-集合-环境" class="headerlink" title="变量(全局/集合/环境)"></a>变量(全局/集合/环境)</h3><p>变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。<br>对我们做接口测试来说，又是一个非常重要的功能 。<br>在postman常用的三种变量分别是全局变量，环境变量，集合变量 。</p>
<ul>
<li>全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。</li>
<li>环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。</li>
<li>集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。<br>其中，他们的作用域范围依次从大到小：全局变量&gt;集合变量&gt;环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。</li>
</ul>
<p>想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。</p>
<ol>
<li>定义变量（设置变量）</li>
<li>获取变量（访问变量）</li>
</ol>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>定义全局变量和环境变量，点击右上角的小齿轮，弹出如下界面，就可以根据需求定义全局变量或者环境变量了。<br><img src="/postman/19.png" alt="定义变量" title="定义变量"></p>
<p>已经定义的全局变量和环境变量，可以进行快速查看<br><img src="/postman/20.png" alt="定义变量" title="定义变量"></p>
<h4 id="定义集合变量"><a href="#定义集合变量" class="headerlink" title="定义集合变量"></a>定义集合变量</h4><p>选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。<br><img src="/postman/21.png" alt="定义集合变量" title="定义集合变量"><br>定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。</p>
<ul>
<li>在URL，Params , Authorization , Headers , Body中定义：</li>
</ul>
<ol>
<li>手工方式创建一个空的变量名</li>
<li>在以上的位置把想要的值选中右击，选中Set：环境|全局 ，选中一个变量名，点击后就会保存到这个变量中<br><img src="/postman/22.png" alt="定义集合变量" title="定义集合变量"><br>在Tests，Pre-requests Script：</li>
<li>定义全局变量：pm.collectionVariables.set(“变量名”,变量值)</li>
<li>定义环境变量：pm.environment.set(“变量名”，变量值)</li>
<li>定义集合变量：pm.variables.set(“变量名”,变量值)</li>
</ol>
<h4 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h4><p>定义好变量，接下来就可以使用变量了 。需要注意的是，在不同的位置获取变量，编写的规则也是不一样的 。<br>如果在请求参数中获取变量，无论是获取全局变量，还是环境变量，还是集合变量，获取的方式都是一样的编写规则： 。</p>
<ul>
<li>请求参数指的是：URL，Params , Authorization , Headers , Body<br>如果是在编写代码的位置(Tests,Pre-requests Script)获取变量，获取不同类型的变量，编写的代码都不相同，具体如下：</li>
</ul>
<ol>
<li>获取环境变量：pm.environment.get(‘变量名’)</li>
<li>获取全局变量：pm.globals.get(‘变量名’)</li>
<li>获取集合变量：pm.pm.collectionVariables.get.get(‘变量名’)<br><img src="/postman/23.png" alt="获取变量" title="获取变量"></li>
</ol>
<h3 id="请求前置脚本"><a href="#请求前置脚本" class="headerlink" title="请求前置脚本"></a>请求前置脚本</h3><p>前置脚本其实就是在Pre-requests Script中编写的JavaScript脚本，想要了解这个功能，需要先了解它的执行顺序。那么下面就来看下它的执行顺序。<br>可以看出，一个请求在发送之前，会先去执行Pre Request Script（前置脚本）中的代码 。那么这个功能在实际工作中有什么作用呢 ？</p>
<p>主要场景：一般情况下，在发送请求前需要对接口的数据做进一步处理，就都可以使用这个功能，比如说，登录接口的密码，在发送前需要做加密处理，那么就可以在前置脚本中做加密处理，再比如说，有的接口的输入参数有一些随机数，每请求一次接口参数值都会发送变化，就可以在前置脚本中编写生成随机数的代码 。总体来说，就是在请求接口之前对我们的请求数据进行进一步加工处理的都可以使用前置脚本这个功能。<br><img src="/postman/24.png" alt="请求前置脚本" title="请求前置脚本"></p>
<p>实现步骤：</p>
<ol>
<li>在前置脚本中编写生成随机数</li>
<li>将这个值保存成环境变量</li>
<li>将参数t的值替换成环境变量的值 。<br><img src="/postman/25.png" alt="请求前置脚本" title="请求前置脚本"></li>
</ol>
<h3 id="接口关联"><a href="#接口关联" class="headerlink" title="接口关联"></a>接口关联</h3><p>在我们测试的接口中，经常出现这种情况 。 上一个接口的返回数据是下一个接口的输入参数 ，那么这俩个接口就产生了关联。 这种关联在做接口测试时非常常见，那么在postman中，如何实现这种关联关系呢 ？</p>
<p>实现思路：</p>
<ol>
<li>提取上一个接口的返回数据值，</li>
<li>将这个数据值保存到环境变量或全局变量中</li>
<li>在下一个接口获取环境变量或全局变量</li>
</ol>
<p>案例：<br>用户上传头像功能，需要用户先上传一张图片，然后会自动预览 。那么在这个过程中，会调用到俩个接口 ，第一个上传头像接口，第二个预览图像接口 。<br>其中调用上传头像接口成功后会返回如下信息：<br><img src="/postman/26.png" alt="接口关联" title="接口关联"><br>实现步骤：</p>
<ol>
<li>获取上传头像接口返回url的值</li>
<li>将这个值保存成全局变量(环境变量也可以)</li>
<li>在图像预览中使用全局变量</li>
</ol>
<h3 id="常见返回值获取"><a href="#常见返回值获取" class="headerlink" title="常见返回值获取"></a>常见返回值获取</h3><p>在做接口测试时，请求接口返回的数据都是很复杂的json数据，有着多层嵌套，这样的数据层级在postman怎么获取呢 ？</p>
<h4 id="案例1：多层json嵌套-获取user-id的值"><a href="#案例1：多层json嵌套-获取user-id的值" class="headerlink" title="案例1：多层json嵌套, 获取user_id的值"></a>案例1：多层json嵌套, 获取user_id的值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功！&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;user_id&quot;: &quot;1252163151781167104&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取json体数据</span><br><span class="line">var jsonData &#x3D; pm.response.json()</span><br><span class="line">&#x2F;&#x2F; 获取user_id的值,通过.获取</span><br><span class="line">var user_id &#x3D; jsonData.data.user_id</span><br></pre></td></tr></table></figure>
<h4 id="案例2：json中存在列表，获取points中的第二个元素"><a href="#案例2：json中存在列表，获取points中的第二个元素" class="headerlink" title="案例2：json中存在列表，获取points中的第二个元素"></a>案例2：json中存在列表，获取points中的第二个元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功！&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;roles&quot;: &#123;</span><br><span class="line">            &quot;api&quot;: [</span><br><span class="line">                &quot;API-USER-DELETE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;points&quot;: [</span><br><span class="line">                &quot;point-user-delete&quot;,</span><br><span class="line">                &quot;POINT-USER-UPDATE&quot;,</span><br><span class="line">                &quot;POINT-USER-ADD&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;authCache&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取json体数据</span><br><span class="line">var jsonData &#x3D; pm.response.json()</span><br><span class="line">&#x2F;&#x2F; 获取user_id的值,通过下标获取列表中某个元素</span><br><span class="line">var user_id &#x3D; jsonData.data.roles.points[1]</span><br></pre></td></tr></table></figure>
<p>案例3：列表中取最后一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功！&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 24,</span><br><span class="line">        &quot;rows&quot;: [</span><br><span class="line">           </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;1066370498633486336&quot;,</span><br><span class="line">                &quot;mobile&quot;: &quot;15812340003&quot;,</span><br><span class="line">                &quot;username&quot;: &quot;zbz&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;1071632760222810112&quot;,</span><br><span class="line">                &quot;mobile&quot;: &quot;16612094236&quot;,</span><br><span class="line">                &quot;username&quot;: &quot;llx&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;1075383133106425856&quot;,</span><br><span class="line">                &quot;mobile&quot;: &quot;13523679872&quot;,</span><br><span class="line">                &quot;username&quot;: &quot;test001&quot;,</span><br><span class="line">       </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取json体数据</span><br><span class="line">var jsonData &#x3D; pm.response.json()</span><br><span class="line">&#x2F;&#x2F; 获取id的值,通过slice(-1)获取列表中最后一个元素。</span><br><span class="line">var id &#x3D; jsonData.data.rows.slice(-1)[0]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis &amp; MongoDB &amp; Memcached</title>
    <url>/2021/01/09/PluginTool-Redis&amp;MongoDB&amp;Memcached/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/tuyile006/p/6382062.html" target="_blank" rel="noopener">Redis、Memcache和MongoDB的区别</a></p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Memcached</tag>
        <tag>MongoDB</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis详解</title>
    <url>/2020/08/18/PluginTool-Redis/</url>
    <content><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。<br>Redis与其他key-value缓存产品有以下三个特点:</p>
<ul>
<li>Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储</li>
<li>Redis支持数据的备份，即 master - slave 模式的数据备份</li>
</ul>
<h2 id="Redis优势"><a href="#Redis优势" class="headerlink" title="Redis优势"></a>Redis优势</h2><ul>
<li>性能极高–Redis 读的速度是 110000 次/s, 写的速度是 81000 次/s 。</li>
<li>丰富的数据类型-Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 ZSets 数据类型操作。</li>
<li>原子性-Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li>
<li>其他特性-Redis 还支持 publish/subscribe 通知，key 过期等特性。</li>
</ul>
<h2 id="Redis数据类型-5种"><a href="#Redis数据类型-5种" class="headerlink" title="Redis数据类型(5种)"></a>Redis数据类型(5种)</h2><p>Redis支持5种数据类型：string(字符串)，hash(哈希)，list(列表)，set(集合:无序不重复)，zset(有序集合:有序不重复)</p>
<h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><p>string类型是redis最基本的数据类型,最大能存储512MB,一个key对应一个value<br>string是二进制安全的。也就是说redis的string 可以包含任何数据。比如jpg图片或者序列化的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式:set key value1  &#x2F;&#x2F;重复key会覆盖原来的值</span><br><span class="line">get key </span><br><span class="line">set key value2&#x2F;&#x2F;重复会覆盖value1</span><br></pre></td></tr></table></figure>

<h3 id="hash类型-类似Map"><a href="#hash类型-类似Map" class="headerlink" title="hash类型(类似Map)"></a>hash类型(类似Map)</h3><p>hash是一个键值对(key-Object),value是String类型(key-value)多个集合,特别适合用于存储对象,无序,Object-key为不能重复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式:hset key Object-key Object-value &#x2F;&#x2F;Object-key为不能重复</span><br><span class="line">hset hash-key sub-key1 value1</span><br><span class="line">hset hash-key sub-key1 value2 </span><br><span class="line">hgetall hash-key</span><br></pre></td></tr></table></figure>

<h3 id="List类型-类似Array"><a href="#List类型-类似Array" class="headerlink" title="List类型(类似Array)"></a>List类型(类似Array)</h3><p>redis list的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销<br>list就是一个简单的字符串集合,和Java中的list相差不大,区别就是这里的list存放的是字符串.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式:rpush key value &#x2F;&#x2F;list内的value元素是可重复的,存在不同下标</span><br><span class="line">rpush list-key v1</span><br><span class="line">rpush list-key v2 </span><br><span class="line">rpush list-key v2</span><br></pre></td></tr></table></figure>

<h3 id="Set类型-字符串"><a href="#Set类型-字符串" class="headerlink" title="Set类型(字符串)"></a>Set类型(字符串)</h3><p>redis的set是字符串类型的无序集合,集合是通过哈希表实现的，因此添加、删除、查找的复杂度都是 O(1)<br>redis的set是一个key对应着多个value，但是set和redis的list 不同的是set中的字符串集合元素不能重复，但是list可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式:sadd key value &#x2F;&#x2F;value也是一个字符串类型的不能重复集合</span><br><span class="line">sadd k1 v1</span><br><span class="line">sadd k1 v2</span><br></pre></td></tr></table></figure>

<h3 id="Zset类型-有序"><a href="#Zset类型-有序" class="headerlink" title="Zset类型(有序)"></a>Zset类型(有序)</h3><p>redis zset和set一样都是字符串类型元素的集合，并且集合内的value元素不能重复。一个key,多个value<br>不同的是zset每个元素都会关联一个double 类型的分数。redis通过分数来为集合中的成员进行从小到大的排序。<br>zset的元素是唯一的，但是分数(score)却可以重复。zset是按照分数的大小来排序的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式:zadd key score value &#x2F;&#x2F;不可以重复:用于防重复防并发</span><br><span class="line">zadd zset-key 728 member1</span><br><span class="line">zadd zset-key 982 member0</span><br></pre></td></tr></table></figure>

<h3 id="总结及应用"><a href="#总结及应用" class="headerlink" title="总结及应用:"></a>总结及应用:</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><p>类型简介特性场景string(字符串)二进制安全可以包含任何数据，比如 jpg 图片或者序列化的对象，一个键最大能存储 521M—Hash（哈希）键值对集合，即编程语言中的 Map 类型适合存储对象，并且可以像数据库中 update 一样只修改某一项属性值存储、读取、修改用户属性List（列表）双向链表增删快，提供了操作某一段元素的 API1</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>消息队列Set(集合)哈希表实现，元素不能重复添加删除查找的复杂度都是 O(1);带权重的消息队列;</li>
<li>集合操作:为集合提供了求交集、并集、差集等操作共同好友；</li>
<li>防重复防并发:利用唯一性，统计访问网站的所有独立 ip；</li>
<li>消息排行功能:好友推荐时，根据 tag 求交集，大于某个阈值就可以推荐Zset（有序集合）将 Set 中的元素增加一个权重参数 score，元素按 score 有序排列数据插入集合时，已经进行天然排序排行榜；最新消息朋友圈的时间线</li>
</ul>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>一般不用 Redis 做消息发布订阅<br>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>redis事务一次可以执行多条命令，服务器在执行命令期间，不会去执行其他客户端的命令请求。事务中的多条命令被一次性发送给服务器，而不是一条一条地发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。执行具有原子型,事务不具有原子性,也不存在隔离机制</p>
<h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余命令依然被执行。也就是说 Redis 事务不保证原子性。</li>
<li>在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
</ul>
<p>单个 Redis 执行命令是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。<br>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。队列未提交之前不会执行,不存在隔离机制</p>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开始事务(MULTI)</li>
<li>命令入队</li>
<li>执行事务(EXEC)</li>
</ul>
<h3 id="Redis事务命令"><a href="#Redis事务命令" class="headerlink" title="Redis事务命令"></a>Redis事务命令</h3><p>下表列出了redis事务的相关命令：<br>序号命令及描述<br>    1.DISCARD 取消事务，放弃执行事务块内的所有命令。<br>    2.EXEC 执行所有事务块内的命令。<br>    3.MULTI 标记一个事务块的开始。<br>    4.UNWATCH 取消 WATCH 命令对所有 key 的监视。<br>    5.WATCH key [key …] 监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>将某个时间点的所有数据都存放到硬盘上。可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。<br>如果系统发生故障，将会丢失最后一次创建快照之后的数据。如果数据量大，保存快照的时间会很长。</p>
<h3 id="AOF持久化-append-only-file"><a href="#AOF持久化-append-only-file" class="headerlink" title="AOF持久化(append only file)"></a>AOF持久化(append only file)</h3><p>将写命令添加到 AOF 文件末尾;使用 AOF 持久化需要设置同步选项，文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。</p>
<h4 id="选项同步频率"><a href="#选项同步频率" class="headerlink" title="选项同步频率"></a>选项同步频率</h4><ul>
<li>always每个写命令都同步,选项会严重减低服务器的性能</li>
<li>eyerysec每秒同步一次,选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器几乎没有任何影响。</li>
<li>no让操作系统来决定何时同步,选项并不能给服务器性能带来多大的提升，而且会增加系统崩溃时数据丢失的数量。<br>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</li>
</ul>
<h2 id="Redis缓存的过时-6种-淘汰策略"><a href="#Redis缓存的过时-6种-淘汰策略" class="headerlink" title="Redis缓存的过时(6种)淘汰策略"></a>Redis缓存的过时(6种)淘汰策略</h2><p>核心思想:如果一个数据最近一段时间没被使用,将来被使用可能性很小,可以淘汰</p>
<h3 id="noeviction"><a href="#noeviction" class="headerlink" title="noeviction"></a>noeviction</h3><p>不淘汰策略，若超过最大内存，返回错误信息</p>
<h3 id="volitile-ttl"><a href="#volitile-ttl" class="headerlink" title="volitile-ttl"></a>volitile-ttl</h3><p>从已设置过期时间的KV集中优先对剩余时间短(time to live)的数据淘汰</p>
<p>###　volitile-random<br>从已设置过期时间的KV集中随机选择数据淘汰</p>
<h3 id="allKeys-random"><a href="#allKeys-random" class="headerlink" title="allKeys-random"></a>allKeys-random</h3><p>从所有KV集中随机选择数据淘汰</p>
<h3 id="volatile-lru"><a href="#volatile-lru" class="headerlink" title="volatile-lru"></a>volatile-lru</h3><p>从已设置过期时间的KV集中优先对最近最少使用(less recently used)的数据淘汰</p>
<h3 id="allkeys-lru"><a href="#allkeys-lru" class="headerlink" title="allkeys-lru"></a>allkeys-lru</h3><p>从所有KV集中优先对最近最少使用(less recently used)的数据淘汰</p>
<h3 id="LRU-less-recently-used-算法"><a href="#LRU-less-recently-used-算法" class="headerlink" title="LRU(less recently used)算法"></a>LRU(less recently used)算法</h3><p>一种缓存置换算法:作用缓存满后(超出容量),需要淘汰老数据,淘汰链标最后一个数据</p>
<ul>
<li>基于linkedHashMap实现:超出定义容量capacity容量,淘汰链标最后一个数据<br>1.定义容量capacity 2.重写removeEldest方法 3.构造两个初始化构造器:内引父类构造器,现函数LRUcahe(1参数),LRUcahe(4参数)</li>
<li>手写算法:(链表)<br>1.定义节点类Node对象:包含前节点对象HeadNode,NodeTail对象<br>2.定义LRU内容包括capcity,NodeMap&lt;k,Node&gt;;NodeHead,NodeTail<br>3.实现put,add,remove方法</li>
</ul>
<h2 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h2><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>大量高并发访问,在失效某时刻某个key,导致数据承压</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>1.加互斥锁,被锁时,(再访问缓存,还没有结果sleep一会)[循环访问-自旋],一会再递归</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>大量并发访问Redis没有的key,穿过Redis直接访问数据库,使得数据库承受压力.(主要是查数据库返回null,不会写入缓存)</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>1.查到数据库为null要缓存,同时设置过时</li>
<li>2.查到数据库为null时做<a href="/BitMap算法详解"><font color='red'>BitMap算法</font></a>映射表解析</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>设置大量的key时间同时失效,或者某时间缓存宕机</p>
<h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>1.设置时间加入随机因子,使得缓存时间分布均匀</li>
<li>2.设置手动刷新缓存</li>
<li>3.设置二级缓存,主要缓存时间短,备存时间长</li>
<li>4.加锁或队列实现减压</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="master-slave模式-主从模式"><a href="#master-slave模式-主从模式" class="headerlink" title="master-slave模式(主从模式)"></a>master-slave模式(主从模式)</h3><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><p>主服务器创建快照文件，即 RDB 文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始像从服务器发送存储在缓冲区的写命令。<br>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。<br>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p>
<h3 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h3><p>随着负载不断上升，主服务器无法很快的更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器<br><img src="/img/Redis-Master.png" alt="Redis-Master" title="Redis-Master"></p>
<h3 id="哨兵机制4种原理"><a href="#哨兵机制4种原理" class="headerlink" title="哨兵机制4种原理"></a>哨兵机制4种原理</h3><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举处新的主服务器。<br><a href="/img/哨兵机制.png" title="哨兵机制">哨兵机制</a></p>
<h4 id="哨兵监控原理"><a href="#哨兵监控原理" class="headerlink" title="哨兵监控原理"></a>哨兵监控原理</h4><ol>
<li>每个哨兵每10s向主从点发送info命令获取最新拓扑结果图(其实只对主节点监控即可,通过主节点发送info获取信息,只要有从节点更新立马感知)</li>
<li>每个哨兵每隔2秒,向主Redis节点订阅其他哨兵节点信息和发布自己节点信息</li>
<li>每个哨兵每隔1秒向主从节点发送ping命令做一次心跳检测<br><a href="/img/哨兵监控机制.png" title="哨兵监控机制.png">哨兵监控机制</a><h4 id="哨兵判断原理"><a href="#哨兵判断原理" class="headerlink" title="哨兵判断原理"></a>哨兵判断原理</h4></li>
<li>主观下线:由心跳检测超时,哨兵节点认为该节点错误或下线,可能会存在错误判断</li>
<li>客观下线:当主观下线为主节点时,需要其他通知哨兵节点判断,当哨兵判断超过没定法定人数quorum个数,此哨兵节点则认为主节点有问题(其实就是其他哨兵同意下线)</li>
</ol>
<h4 id="哨兵选举原理"><a href="#哨兵选举原理" class="headerlink" title="哨兵选举原理"></a>哨兵选举原理</h4><ol>
<li>每个哨兵都可以成为领导,每个哨兵都可以推选自己或同意别人或拒绝别人选举</li>
<li>满足设定当选人数,成为领导并负债故障转移</li>
</ol>
<h4 id="哨兵故障处理原理"><a href="#哨兵故障处理原理" class="headerlink" title="哨兵故障处理原理"></a>哨兵故障处理原理</h4><ol>
<li>从节点脱离原节点,选择从节点优先级最高,升级为主节点,其他从节点将以此节点为主节点,原主节点变为从节点</li>
<li>将最后更新拓扑图信息通知个节点</li>
</ol>
<h2 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h2><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<h3 id="分片2种方法"><a href="#分片2种方法" class="headerlink" title="分片2种方法"></a>分片2种方法</h3><p>假设有 4 个 Redis 实例 R0, R1, R2, R3, 还有很多表示用户的键 user:1, user:2, … , 有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<h4 id="范围分片-最简单-代价高"><a href="#范围分片-最简单-代价高" class="headerlink" title="范围分片(最简单,代价高):"></a>范围分片(最简单,代价高):</h4><p>例如用户 id 从 0 ~ 1000 的存储到实例 R0 中，用户 id 从 1001 ~ 2000 的存储到实例 R1中等等。但是这样需要维护一张映射范围表，维护操作代价高。<br>####　哈希分片<br>使用哈希函数将键转换为一个数字，再对实例数量求模就能知道存储的实例。</p>
<h4 id="处理片3种位置"><a href="#处理片3种位置" class="headerlink" title="处理片3种位置"></a>处理片3种位置</h4><p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定应当分布到哪个节点。</li>
<li>代理分片：将客户端的请求发送到代理上，由代理转发到正确的节点上。</li>
<li>服务器分片：Redis Cluster</li>
</ul>
<h2 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h2><ul>
<li>存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。</li>
<li>数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。</li>
<li>使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
<li>value的大小：redis可以达到1GB，而memcache只有1MB。</li>
</ul>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisTemplate详解</title>
    <url>/2020/08/18/PluginTool-RedisTemplate/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/pMjqW1Jy-BrgsByHxaSWeg" target="_blank" rel="noopener">Spring Boot 中的 RestTemplate 不好用？试试 Retrofit</a></p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>RedisTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis可视化工具</title>
    <url>/2021/01/09/PluginTool-Redis%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/I7wU7ypt2Wkub5Z4E1G9jA" target="_blank" rel="noopener"> Redis 可视化工具</a></p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Screw-管理数据库表结构文档</title>
    <url>/2021/01/09/PluginTool-Screw/</url>
    <content><![CDATA[<p>screw 是一个简洁好用的数据库表结构文档的生成工具 ，支持 MySQL、Oracle、PostgreSQL 等主流的关系数据库</p>
<p><a href="https://mp.weixin.qq.com/s/UPh0--gqPLQsYJAmARjbyQ" target="_blank" rel="noopener">数据库表结构文档的生成工具</a></p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Screw</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code快捷键</title>
    <url>/2018/02/13/PluginTool-VSCode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="VS-Code快捷键"><a href="#VS-Code快捷键" class="headerlink" title="VS Code快捷键"></a>VS Code快捷键</h2><p><a href="https://www.cnblogs.com/ManWingloeng/p/10758483.html" target="_blank" rel="noopener">VScode中使用IntelliJ的快捷键</a></p>
<p><a href="https://www.jianshu.com/p/943fa16f31ab" target="_blank" rel="noopener">ES7 缩写快捷键</a></p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Wget批量下载</title>
    <url>/2018/02/11/PluginTool-Wget%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>wget 上是一个命令行下载工具,下载一个 windows 下可用的版本：<a href="https://eternallybored.org/misc/wget/" target="_blank" rel="noopener">Windows binaries of GNU Wget</a>;</p>
<p>方式一:<br>把下载好的 wget.exe 文件放到 C:\Windows\System32 目录下就可以用了。去命令行下用:wget -V 来测试一下，如果出现 wget 信息则 wget 命令就可以正常使用了。</p>
<p>方式二:</p>
<ol>
<li>打开『系统属性』，点击左侧的『高级系统设置』</li>
<li>点击『高级』选项卡，然后点击『环境变量』</li>
<li>点击环境变量中的『 Path 』然后点击『编辑』</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>用 wget 发送 post 请求</p>
<pre><code>wget --post-data=&quot;DDDDD=学号&amp;upass=密码&amp;0MKKey=&quot; http://10.3.8.211</code></pre><h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><p>而要让档案自动储存到指令的目录下，则需要借用-P 这个参数，可以使用以下的指令</p>
<pre><code>wget -P 目录 网址
举例来说，如果你要放到/root底下，你可以打下列的指令：
wget -P /root 网址
wget -P D:\xxx.zip http://www.xdown.com/xxx.zip
wget -O &quot;D:\xxx.zip&quot; http://www.xdown.com/xxx.zip</code></pre><p>用 wget 下载东西，的确很方便，它会自动重连并断点续传。让人很放心。<br>经常要下载一个网站或网站的某个目录。<br>下载一个目录，例如下载网站 <a href="http://www.example.com/目录" target="_blank" rel="noopener">www.example.com/目录</a> mydir 下的所有内容</p>
<pre><code>命令如下：
wget -r -p -k -np -nc -e robots=off http://www.example.com/mydir/
如果要想下载整个网站，最好去除-np参数。
wget -r -p -k -nc -e robots=off http://www.example.com/mydir/

-r 递归；对于HTTP主机，wget首先下载URL指定的文件，然后（如果该文件是一个HTML文档的话）递归下载该文件所引用（超级连接）的所有文件（递 归深度由参数-l指定）。对FTP主机，该参数意味着要下载URL指定的目录中的所有文件，递归方法与HTTP主机类似。
-c 指定断点续传功能。实际上，wget默认具有断点续传功能，只有当你使用别的ftp工具下载了某一文件的一部分，并希望wget接着完成此工作的时候，才 需要指定此参数。

-nc 不下载已经存在的文件
-np 表示不追溯至父目录，不跟随链接，只下载指定目录及子目录里的东西；
-p 下载页面显示所需的所有文件。比如页面中包含了图片，但是图片并不在/yourdir目录中，而在/images目录下，有此参数，图片依然会被正常下 载。

-k 修复下载文件中的绝对连接为相对连接，这样方便本地阅读。
-o down.log 记录日记到down.log
-e robots=off 忽略robots.txt</code></pre>]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Wget</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger管理API文档</title>
    <url>/2021/01/08/PluginTool-Swagger/</url>
    <content><![CDATA[<h2 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h2><p>URL:<a href="http://localhost:8080/swagger-ui/index.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui/index.html</a></p>
<h3 id="引入jar包"><a href="#引入jar包" class="headerlink" title="引入jar包"></a>引入jar包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &lt;!--     swagger2 接口API文档       --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="增加配置"><a href="#增加配置" class="headerlink" title="增加配置"></a>增加配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swagger:</span><br><span class="line">  enable: true</span><br><span class="line">  application-name: $&#123;spring.application.name&#125;</span><br><span class="line">  application-version: 1.0</span><br><span class="line">  application-description: springfox swagger 3.0整合Demo</span><br><span class="line">  try-host: http:&#x2F;&#x2F;localhost:$&#123;server.port&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Data</span><br><span class="line">@ConfigurationProperties(&quot;swagger&quot;)</span><br><span class="line">public class SwaggerProperties &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否开启swagger，生产环境一般关闭，所以这里定义一个变量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Boolean enable;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 项目应用名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String applicationName;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 项目版本信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String applicationVersion;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 项目描述信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String applicationDescription;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接口调试地址</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String tryHost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">@ConditionalOnProperty(prefix &#x3D; &quot;swagger2&quot;,value &#x3D; &#123;&quot;enable&quot;&#125;,havingValue &#x3D; &quot;true&quot;)</span><br><span class="line">public class SwaggerConfiguration implements WebMvcConfigurer &#123;</span><br><span class="line">    private final SwaggerProperties swaggerProperties;</span><br><span class="line"></span><br><span class="line">    public SwaggerConfiguration(SwaggerProperties swaggerProperties) &#123;</span><br><span class="line">        this.swaggerProperties &#x3D; swaggerProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.OAS_30).pathMapping(&quot;&#x2F;&quot;)</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 定义是否开启swagger，false为关闭，可以通过变量控制</span><br><span class="line">                .enable(swaggerProperties.getEnable())</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 将api的元信息设置为包含在json ResourceListing响应中。</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 接口调试地址</span><br><span class="line">                .host(swaggerProperties.getTryHost())</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 选择哪些接口作为swagger的doc发布</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 支持的通讯协议集合</span><br><span class="line">                .protocols(newHashSet(&quot;https&quot;, &quot;http&quot;))</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 授权信息设置，必要的header token等认证信息</span><br><span class="line">                .securitySchemes(securitySchemes())</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 授权信息全局应用</span><br><span class="line">                .securityContexts(securityContexts());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * API 页面上半部分展示信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder().title(swaggerProperties.getApplicationName() + &quot; Api Doc&quot;)</span><br><span class="line">                .description(swaggerProperties.getApplicationDescription())</span><br><span class="line">                .contact(new Contact(&quot;lighter&quot;, null, &quot;123456@gmail.com&quot;))</span><br><span class="line">                .version(&quot;Application Version: &quot; + swaggerProperties.getApplicationVersion() + &quot;, Spring Boot Version: &quot; + SpringBootVersion.getVersion())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 设置授权信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private List&lt;SecurityScheme&gt; securitySchemes() &#123;</span><br><span class="line">        ApiKey apiKey &#x3D; new ApiKey(&quot;BASE_TOKEN&quot;, &quot;token&quot;, In.HEADER.toValue());</span><br><span class="line">        return Collections.singletonList(apiKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 授权信息全局应用</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private List&lt;SecurityContext&gt; securityContexts() &#123;</span><br><span class="line">        return Collections.singletonList(</span><br><span class="line">                SecurityContext.builder()</span><br><span class="line">                        .securityReferences(Collections.singletonList(new SecurityReference(&quot;BASE_TOKEN&quot;, new AuthorizationScope[]&#123;new AuthorizationScope(&quot;global&quot;, &quot;&quot;)&#125;)))</span><br><span class="line">                        .build()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SafeVarargs</span><br><span class="line">    private final &lt;T&gt; Set&lt;T&gt; newHashSet(T... ts) &#123;</span><br><span class="line">        if (ts.length &gt; 0) &#123;</span><br><span class="line">            return new LinkedHashSet&lt;&gt;(Arrays.asList(ts));</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通用拦截器排除swagger设置，所有拦截器都会自动加swagger相关的资源排除信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field registrationsField &#x3D; FieldUtils.getField(InterceptorRegistry.class, &quot;registrations&quot;, true);</span><br><span class="line">            List&lt;InterceptorRegistration&gt; registrations &#x3D; (List&lt;InterceptorRegistration&gt;) ReflectionUtils.getField(registrationsField, registry);</span><br><span class="line">            if (registrations !&#x3D; null) &#123;</span><br><span class="line">                for (InterceptorRegistration interceptorRegistration : registrations) &#123;</span><br><span class="line">                    interceptorRegistration</span><br><span class="line">                            .excludePathPatterns(&quot;&#x2F;swagger**&#x2F;**&quot;)</span><br><span class="line">                            .excludePathPatterns(&quot;&#x2F;webjars&#x2F;**&quot;)</span><br><span class="line">                            .excludePathPatterns(&quot;&#x2F;v3&#x2F;**&quot;)</span><br><span class="line">                            .excludePathPatterns(&quot;&#x2F;doc.html&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在生产环境中如何禁用swagger"><a href="#在生产环境中如何禁用swagger" class="headerlink" title="在生产环境中如何禁用swagger"></a>在生产环境中如何禁用swagger</h2><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>通过@ConditionalOnProperty(prefix = “swagger2”,value = {“enable”},havingValue = “true”)注解实现。读取配置文件中前缀为swagger2的配置，属性名为enable，值为true。当条件成立，此配置类被激活。两个属性name以及havingValue，其中name用来从application.properties中读取某个属性值，如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效</p>
<ul>
<li><p>dev环境application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	profiles: dev</span><br><span class="line">swagger2:</span><br><span class="line">	enable: true</span><br></pre></td></tr></table></figure></li>
<li><p>prod环境application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	profiles: prod</span><br><span class="line">swagger2:</span><br><span class="line">	enable: false(或者在pro环境下不写此配置)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行dev环境Java -jar demo.jar –spring.profiles.active=dev</p>
</li>
<li><p>运行prod环境 java -jar demo.jar –spring.profiles.active=prod</p>
</li>
</ul>
<p>此时我们访问开发环境可以进swagger，进生产环境则会被屏蔽调。</p>
<h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>在配置文件中配置，从配置文件读取</p>
<p>注:在Spring Boot的启动过程中，只能有一个继承WebMvcConfigurationSupport的@Configuration类（使用@EnableMvc效果相同），如果存在多个这样的类，只有一个配置可以生效。对于这个问题，其实可以通过implements WebMvcConfigurer来解决，多个不同的类实现这个接口后的配置都可以正常运行或者合并到一个WebMvcConfigurationSupport中实现</p>
<h2 id="Swagger-3"><a href="#Swagger-3" class="headerlink" title="Swagger 3"></a>Swagger 3</h2><p>通过在项目中引入 springfox-boot-starter 依赖，直接使用,也可以通过自带配置可以禁掉Swagger<br>URL:<a href="http://localhost:8080/swagger-ui/" target="_blank" rel="noopener">http://localhost:8080/swagger-ui/</a></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre><h3 id="自带配置项"><a href="#自带配置项" class="headerlink" title="自带配置项"></a>自带配置项</h3><p><img src="/swagger/1.png" alt="1.png" title="1.png"></p>
<h2 id="Swagger相关注解说明"><a href="#Swagger相关注解说明" class="headerlink" title="Swagger相关注解说明"></a>Swagger相关注解说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api：用在请求的类上，表示对类的说明</span><br><span class="line">	tags&#x3D;&quot;说明该类的作用，可以在UI界面上看到的注解&quot;</span><br><span class="line">	value&#x3D;&quot;该参数没什么意义，在UI界面上也看到，所以不需要配置&quot;</span><br><span class="line"></span><br><span class="line">@ApiOperation：用在请求的方法上，说明方法的用途、作用</span><br><span class="line">	value&#x3D;&quot;说明方法的用途、作用&quot;</span><br><span class="line">	notes&#x3D;&quot;方法的备注说明&quot;</span><br><span class="line"></span><br><span class="line">@ApiImplicitParams：用在请求的方法上，表示一组参数说明</span><br><span class="line">	@ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面</span><br><span class="line">	    name：参数名</span><br><span class="line">	    value：参数的汉字说明、解释</span><br><span class="line">	    required：参数是否必须传</span><br><span class="line">	    paramType：参数放在哪个地方</span><br><span class="line">	        · header --&gt; 请求参数的获取：@RequestHeader</span><br><span class="line">	        · query --&gt; 请求参数的获取：@RequestParam</span><br><span class="line">	        · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable</span><br><span class="line">	        · body（不常用）</span><br><span class="line">	        · form（不常用）	   </span><br><span class="line">	    dataType：参数类型，默认String，其它值dataType&#x3D;&quot;Integer&quot;	   </span><br><span class="line">	    defaultValue：参数的默认值</span><br><span class="line">	    </span><br><span class="line">@ApiResponses：用在请求的方法上，表示一组响应</span><br><span class="line">	@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</span><br><span class="line">	    code：数字，例如400</span><br><span class="line">	    message：信息，例如&quot;请求参数没填好&quot;</span><br><span class="line">	    response：抛出异常的类</span><br><span class="line">	    </span><br><span class="line">@ApiModel：用于响应类上，表示一个返回响应数据的信息</span><br><span class="line">			（这种一般用在post创建的时候，使用@RequestBody这样的场景，</span><br><span class="line">			请求参数无法使用@ApiImplicitParam注解进行描述的时候）</span><br><span class="line">	@ApiModelProperty：用在属性上，描述响应类的属性</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Hexo教程</title>
    <url>/2018/02/09/PluginTool-%E5%AE%89%E8%A3%85Hexo%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h1><ol>
<li>首先安装<br><code>cnpm(Node.js)</code></li>
<li>然后安装 hexo<br><code>cnpm install hexo-cli -g</code></li>
<li>初始化一个 hexo 项目<br><code>hexo init blog</code></li>
<li>常用命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">清理缓存文件:hexo clean </span><br><span class="line">生成静态文件:hexo generate or hexo g</span><br><span class="line">启动本地服务器:hexo server or hexo s</span><br><span class="line">部署站点，在本地生成.deploy_git文件夹，并将编译后的文件上传至 GitHub:hexo deploy or hexo d</span><br><span class="line">删除:rm -rf .deploy_git(.deploy_git部署报错,删除文件夹重新生成)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li>添加配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save</span><br><span class="line">hexo-renderer-jade</span><br><span class="line">hexo-renderer-scss</span><br><span class="line">hexo-generator-feed</span><br><span class="line">hexo-generator-sitemap</span><br><span class="line">hexo-browsersync</span><br><span class="line">hexo-generator-archive</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>安装<br><code>cnpm install</code></li>
</ol>
<h1 id="添加-theme-文件"><a href="#添加-theme-文件" class="headerlink" title="添加 theme 文件:"></a>添加 theme 文件:</h1><ul>
<li>在 github 上找出自己喜欢的一个主题</li>
<li>用 git 命令 clone 下来</li>
<li>将文件放到 themes 文件夹，然后修改 hexo 文件的_config.yml</li>
<li>将 themes 文件夹里面的那个主题名称添加到 theme 这个标签之后</li>
<li>可以在 theme 文件夹里面修改_config.yml 这个文件来获得想要的效果</li>
</ul>
<h1 id="设置主题-theme-doc-教程"><a href="#设置主题-theme-doc-教程" class="headerlink" title="设置主题 theme doc 教程"></a><a href="http://theme-next.iissnan.com/theme-settings.html#author-sites" target="_blank" rel="noopener">设置主题 theme doc 教程</a></h1><ul>
<li><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">对 theme 目录下_config.yml 的 tag/categories/archives 标签进行释放</a></li>
<li><a href="https://www.jianshu.com/p/a79422ab2013" target="_blank" rel="noopener">设置 RSS 标签教程</a>需要安装：<br><code>cnpm install hexo-generator-feed --save</code></li>
<li><a href="https://www.jianshu.com/p/b9665a8e8282" target="_blank" rel="noopener">日历功能教程</a>：<br><a href="https://www.jianshu.com/p/5f19fc242c36" target="_blank" rel="noopener">教程</a>:<br>需要安装为：<br><code>cnpm install hexo-generator-calendar --save</code></li>
<li>主题内容设置：<a href="https://www.jianshu.com/p/efbeddc5eb19" target="_blank" rel="noopener">Hexo+Next 个人博客主题优化</a></li>
<li>设置好配置文件后,search 功能安装：<br><code>cnpm install hexo-generator-searchdb --save</code></li>
</ul>
<h2 id="添加Pdf"><a href="#添加Pdf" class="headerlink" title="添加Pdf"></a>添加Pdf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.npm install --save hexo-pdf</span><br><span class="line">2.文件链接</span><br><span class="line">外部链接：</span><br><span class="line">&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;</span><br><span class="line">本地连接：</span><br><span class="line">&#123;% pdf &#x2F;目录&#x2F;pdf名字.pdf %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA热部署</title>
    <url>/2021/06/07/Plugins-IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="spring-boot-devtools部署"><a href="#spring-boot-devtools部署" class="headerlink" title="spring-boot-devtools部署"></a>spring-boot-devtools部署</h2><ul>
<li><p>pom文件引入坐标</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre></li>
<li><p>pom文件增加下面配置</p>
<build>
      <plugins>
          <plugin>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-maven-plugin</artifactId>
              <configuration>
                  <fork>true</fork><!--必须添加这个配置-->
              </configuration>
          </plugin>
      </plugins>
  </build>
</li>
<li><p>在IDEA中设置开启自动编译<br><img src="/plugins/1.png" alt="IDEA自动编译" title="1"></p>
</li>
<li><p>Shift+Ctrl+Alt+/，选择Registry<br>选 compiler.automake.allow.when.app.running<br>重启项目就可以了</p>
</li>
</ul>
<h2 id="Jrebel-实时编译和热部署"><a href="#Jrebel-实时编译和热部署" class="headerlink" title="Jrebel 实时编译和热部署"></a>Jrebel 实时编译和热部署</h2>]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Mapstruct</title>
    <url>/2021/06/14/Plugins-Mapstruct/</url>
    <content><![CDATA[<h2 id="Mapstruct"><a href="#Mapstruct" class="headerlink" title="Mapstruct"></a>Mapstruct</h2><p>MapStruct 是用于生成类型安全的 Bean 映射类的 Java 注解处理器。你所要做的就是定义一个映射器接口，声明任何需要映射的方法。在编译过程中，MapStruct 将生成该接口的实现。此实现使用纯 Java 的方法调用源对象和目标对象之间进行映射，并非 Java 反射机制。与手工编写映射代码相比，MapStruct 通过生成冗长且容易出错的代码来节省时间。在配置方法的约定之后，MapStruct 使用了合理的默认值，但在配置或实现特殊行为时将不再适用。</p>
<p>与动态映射框架相比，MapStruct 具有以下优点：</p>
<ul>
<li>使用纯 Java 方法代替 Java 反射机制快速执行。</li>
<li>编译时类型安全：只能映射彼此的对象和属性，不能映射一个 Order 实体到一个 Customer DTO 中等等。</li>
<li>如果无法映射实体或属性，则在编译时清除错误报告。</li>
</ul>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">        &lt;org.mapstruct.version&gt;1.3.0.Final&lt;&#x2F;org.mapstruct.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mapstruct&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapstruct-jdk8&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mapstruct&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapstruct-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;$&#123;java.version&#125;&lt;&#x2F;source&gt;</span><br><span class="line">                &lt;target&gt;$&#123;java.version&#125;&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;annotationProcessorPaths&gt;</span><br><span class="line">                    &lt;path&gt;</span><br><span class="line">                        &lt;groupId&gt;org.mapstruct&lt;&#x2F;groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mapstruct-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">                        &lt;version&gt;$&#123;mapstruct.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                    &lt;&#x2F;path&gt;</span><br><span class="line">                &lt;&#x2F;annotationProcessorPaths&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>


<h3 id="创建entity和dto对象"><a href="#创建entity和dto对象" class="headerlink" title="创建entity和dto对象"></a>创建entity和dto对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Order &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *订单id</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 订单编号</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String orderSn;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 收货人姓名&#x2F;号码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String receiverKeyword;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 订单状态：0-&gt;待付款；1-&gt;待发货；2-&gt;已发货；3-&gt;已完成；4-&gt;已关闭；5-&gt;无效订单</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 订单类型：0-&gt;正常订单；1-&gt;秒杀订单</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer orderType;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 订单来源：0-&gt;PC订单；1-&gt;app订单</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer sourceType;</span><br><span class="line"></span><br><span class="line">    private String product;</span><br><span class="line"></span><br><span class="line">    private Date createTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class OrderQueryParam &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 订单编号</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String orderSn;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 收货人姓名&#x2F;号码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String receiverKeyword;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 订单状态：0-&gt;待付款；1-&gt;待发货；2-&gt;已发货；3-&gt;已完成；4-&gt;已关闭；5-&gt;无效订单</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 订单类型：0-&gt;正常订单；1-&gt;秒杀订单</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer orderType;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 订单来源：0-&gt;PC订单；1-&gt;app订单</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer sourceType;</span><br><span class="line"></span><br><span class="line">    private String productName;</span><br><span class="line"></span><br><span class="line">    private String createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Mapper"><a href="#创建Mapper" class="headerlink" title="创建Mapper"></a>创建Mapper</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface OrderMapper &#123;</span><br><span class="line">    &#x2F;&#x2F;方式一</span><br><span class="line">    OrderQueryParam entity2queryParam(Order order);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方式二</span><br><span class="line">    &#x2F;&#x2F;OrderMapper INSTANCE &#x3D; Mappers.getMapper(OrderMapper.class);</span><br><span class="line">    &#x2F;&#x2F;OrderQueryParam entity2queryParam(Order order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void entity2queryParam() &#123;</span><br><span class="line">    Order order &#x3D; new Order();</span><br><span class="line">    order.setId(12345L);</span><br><span class="line">    order.setOrderSn(&quot;orderSn&quot;);</span><br><span class="line">    order.setOrderType(0);</span><br><span class="line">    order.setReceiverKeyword(&quot;keyword&quot;);</span><br><span class="line">    order.setSourceType(1);</span><br><span class="line">    order.setStatus(2);</span><br><span class="line">    &#x2F;&#x2F;方式一</span><br><span class="line">    OrderMapper mapper &#x3D; Mappers.getMapper(OrderMapper.class);</span><br><span class="line">    OrderQueryParam orderQueryParam &#x3D; mapper.entity2queryParam(order);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方式二</span><br><span class="line">    &#x2F;&#x2F;OrderQueryParam orderQueryParam &#x3D; OrderMapper.INSTANCE.entity2queryParam(order);</span><br><span class="line">    assertEquals(orderQueryParam.getOrderSn(), order.getOrderSn());</span><br><span class="line">    assertEquals(orderQueryParam.getOrderType(), order.getOrderType());</span><br><span class="line">    assertEquals(orderQueryParam.getReceiverKeyword(), order.getReceiverKeyword());</span><br><span class="line">    assertEquals(orderQueryParam.getSourceType(), order.getSourceType());</span><br><span class="line">    assertEquals(orderQueryParam.getStatus(), order.getStatus());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两个字段名不一致"><a href="#两个字段名不一致" class="headerlink" title="两个字段名不一致"></a>两个字段名不一致</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface OrderMapper &#123;</span><br><span class="line">    OrderMapper INSTANCE &#x3D; Mappers.getMapper(OrderMapper.class);</span><br><span class="line"></span><br><span class="line">    @Mapping(source &#x3D; &quot;product&quot;, target &#x3D; &quot;productName&quot;)</span><br><span class="line">    OrderQueryParam entity2queryParam(Order order);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果有多个映射关系可以用@Mappings注解，嵌套多个@Mapping注解实现，后文说明！</span><br><span class="line">    @Mappings(&#123;</span><br><span class="line">        @Mapping(source &#x3D; &quot;product&quot;, target &#x3D; &quot;productName&quot;),</span><br><span class="line">        @Mapping(target &#x3D; &quot;createTime&quot;, expression &#x3D; &quot;java(com.guduyan.util.DateUtil.dateToStr(source.getCreateTime()))&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    OrderQueryParam entity2queryParam(Order order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合类型转换"><a href="#集合类型转换" class="headerlink" title="集合类型转换"></a>集合类型转换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface OrderMapper &#123;</span><br><span class="line">    OrderMapper INSTANCE &#x3D; Mappers.getMapper(OrderMapper.class);</span><br><span class="line"></span><br><span class="line">    List&lt;OrderQueryParam&gt; entity2queryParamList(List&lt;Order&gt; source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字段名一致但类型不一致"><a href="#字段名一致但类型不一致" class="headerlink" title="字段名一致但类型不一致"></a>字段名一致但类型不一致</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在Order加一个属性为Date类型的createTime,而在OrderQueryParam加一个属性为String类型的createTime</span><br><span class="line">@Mapper</span><br><span class="line">public interface OrderMapper &#123;</span><br><span class="line">    OrderMapper INSTANCE &#x3D; Mappers.getMapper(OrderMapper.class);</span><br><span class="line"></span><br><span class="line">    @Mappings(&#123;</span><br><span class="line">        @Mapping(source &#x3D; &quot;product&quot;, target &#x3D; &quot;productName&quot;),</span><br><span class="line">        @Mapping(target &#x3D; &quot;createTime&quot;, expression &#x3D; &quot;java(com.guduyan.util.DateUtil.dateToStr(order.getCreateTime()))&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    OrderQueryParam entity2queryParam(Order order);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多对一-多个Bean映射为一个Bean的情况"><a href="#多对一-多个Bean映射为一个Bean的情况" class="headerlink" title="多对一(多个Bean映射为一个Bean的情况)"></a>多对一(多个Bean映射为一个Bean的情况)</h4><p><font color=red>如果出现属性重合source2会覆盖source1相同部分</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在Order加一个属性为Date类型的createTime,而在OrderQueryParam加一个属性为String类型的createTime</span><br><span class="line">@Mapper</span><br><span class="line">public interface OrderMapper &#123;</span><br><span class="line">    OrderMapper INSTANCE &#x3D; Mappers.getMapper(OrderMapper.class);</span><br><span class="line">    &#x2F;&#x2F;source1,source2有相同属性，最后以source1覆盖</span><br><span class="line">    OrderQueryParam toConvertBo(Order source1, Order source2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用其他的值"><a href="#使用其他的值" class="headerlink" title="使用其他的值"></a>使用其他的值</h4><p>//OrderQueryParam，order有相同的id字段，但是映射器会使用mapTo方法里面的id参数<br>@Mapping(target = “id”, source = “id”)<br>OrderQueryParam toConvertBo(Order source1, String id);</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper(uses &#x3D;DateFormtUtil.class)</span><br><span class="line"> public interface OrderMapper &#123;</span><br><span class="line">        OrderMapper INSTANCE &#x3D; Mappers.getMapper(OrderMapper.class);</span><br><span class="line">        &#x2F;&#x2F;如果带注释的方法从数字映射到字符串，则使用DecimalFormat将格式字符串作为可处理的格式</span><br><span class="line">        @Mapping(target &#x3D; &quot;sourceType&quot;,source &#x3D; &quot;sourceType&quot;, numberFormat &#x3D; &quot;#0.00&quot;)</span><br><span class="line">        OrderQueryParam entity2queryParam(Order order);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="逆映射"><a href="#逆映射" class="headerlink" title="逆映射"></a>逆映射</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface OrderMapper &#123;</span><br><span class="line">       OrderMapper INSTANCE &#x3D; Mappers.getMapper(OrderMapper.class);</span><br><span class="line">       @InheritInverseConfiguration</span><br><span class="line">       OrderQueryParam entity2queryParam(Order order);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义类型转换方法"><a href="#自定义类型转换方法" class="headerlink" title="自定义类型转换方法"></a>自定义类型转换方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DateMapper &#123;</span><br><span class="line"></span><br><span class="line">    public String asString(Date date) &#123;</span><br><span class="line">        return date !&#x3D; null ? new SimpleDateFormat( &quot;yyyy-MM-dd&quot; )</span><br><span class="line">            .format( date ) : null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date asDate(String date) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return date !&#x3D; null ? new SimpleDateFormat( &quot;yyyy-MM-dd&quot; )</span><br><span class="line">                .parse( date ) : null;</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( ParseException e ) &#123;</span><br><span class="line">            throw new RuntimeException( e );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Mapper(uses&#x3D;DateMapper.class)</span><br><span class="line">public interface PersonMapper&#123;</span><br><span class="line">  PersonMapper INSTANCT &#x3D; Mappers.getMapper(PersonMapper.class);</span><br><span class="line">  PersonDTO conver(Person person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PersonMapperImpl implements PersonMapper &#123;</span><br><span class="line">    private final DateMapper dateMapper &#x3D; new DateMapper();</span><br><span class="line"></span><br><span class="line">    public PersonMapperImpl() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PersonDTO conver(Person person) &#123;</span><br><span class="line">      ....</span><br><span class="line">      personDTO.setCreateTime(this.dateMapper.asDate(person.getCreateTime()));</span><br><span class="line">	  ...</span><br><span class="line">      return personDTO;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="集成到-spring作为Bean"><a href="#集成到-spring作为Bean" class="headerlink" title="集成到 spring作为Bean"></a>集成到 spring作为Bean</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper(componentModel &#x3D; &quot;spring&quot;)</span><br><span class="line">public interface ModelMapper &#123;</span><br><span class="line"></span><br><span class="line">    ModelMapper INSTANT &#x3D; Mappers.getMapper(ModelMapper.class);</span><br><span class="line"></span><br><span class="line">    ModelVO conver(Model model);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 直接在类中使用Autowired注入就行了</span><br><span class="line">@RestController</span><br><span class="line">class MapperSpringController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ModelMapper modelMapper;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;get&quot;)</span><br><span class="line">    ModelVO getModle()&#123;</span><br><span class="line">       Model model &#x3D; new Model();</span><br><span class="line">       model.setId(&quot;123456&quot;);</span><br><span class="line">       model.setName(&quot;张三&quot;);</span><br><span class="line">       model.setCreate(new Date());</span><br><span class="line">       return modelMapper.conver(model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h4><p>//target找不到source有对应属性就为defaultValue = “默认值”,如果没有defaultValue 则为null<br>@Mapping(target = “describe”, source = “describe”, defaultValue = “默认值”)<br>// 忽略id，不进行映射<br>@Mapping(target = “id”, ignore = true)<br>//如果属性从字符串映射到日期，则该格式字符串可由SimpleDateFormat处理<br>@Mapping(target = “createTime” ,source = “createTime”, dateFormat = “yyyy-MM-dd”)</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title>Prepare-Environment</title>
    <url>/2021/01/09/Project-Prepare/</url>
    <content><![CDATA[<h2 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h2><h3 id="创业公司一般面临下面几个问题"><a href="#创业公司一般面临下面几个问题" class="headerlink" title="创业公司一般面临下面几个问题"></a>创业公司一般面临下面几个问题</h3><ul>
<li>钱不多，省着花</li>
<li>一般研发人员，不具备此类知识体系或者所知不多</li>
</ul>
<h3 id="需求一直存在"><a href="#需求一直存在" class="headerlink" title="需求一直存在"></a>需求一直存在</h3><p>虽然，存在一些问题，但是随着业务发展，人员增多，此类问题会暴露的越发明显，产品技术团队的高效工作，其实是建立在合适、安全、方便的基础设施之上的</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul>
<li>Dell服务器1台（约2 - 3w RMB）</li>
<li>NAS存储，主要做重要系统数据备份（可选）</li>
<li>交换机（不做过多介绍）</li>
<li>整理办公和研发需求<br>下面是选择的服务器，这个配置，基本可以满足100人左右企业的日常办公和部分研发测试需求</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>T640 塔式服务器</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>Intel(R) Xeon(R) CPU 银牌4110*2</td>
</tr>
<tr>
<td>MEM</td>
<td>16G*6</td>
</tr>
<tr>
<td>硬盘</td>
<td>4T*3 raid5 + 256固态系统盘</td>
</tr>
</tbody></table>
<h2 id="基础设施包含什么"><a href="#基础设施包含什么" class="headerlink" title="基础设施包含什么"></a>基础设施包含什么</h2><ul>
<li>虚拟化的平台工具：<br>  我这里选择的是Vmware，好处毋庸置疑，但是收费，我这里之所以选，是因为，有一些历史原因（你懂得，有需求可以单独找我），如果不用，可以考虑OpenStack替代</li>
<li>容器化：<br>  Docker是不二之选，这个根据企业自己的需求来看，我个人觉得，初期可以不用容器化，但是，如果有相关维护人员，可以选择Docker Swam或者K8s进行容器化管理</li>
<li>据需要选择工具<br>  一般企业需要解决的是，知识库、项目和流程管理系统、资产管理系统、统一账户体系、代码库、工件库、如何在外安全上网、内部域名管理、如何安全登录服务器这些需求、数据安全和备份</li>
</ul>
<h3 id="基础设施搭建示意图"><a href="#基础设施搭建示意图" class="headerlink" title="基础设施搭建示意图"></a>基础设施搭建示意图</h3><p>基于VMware ESXI &amp; vSphere</p>
<ul>
<li><p>层级示意<br><img src="/myProject/%E5%B1%82%E7%BA%A7%E7%A4%BA%E6%84%8F.png" alt="层级示意" title="层级示意"></p>
</li>
<li><p>架构示意<br><img src="/myProject/%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F.png" alt="架构示意" title="架构示意"></p>
</li>
<li><p>用到的工具</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>MyProject</tag>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot配置ELK环境</title>
    <url>/2021/01/07/Project-SpringBoot%20%E9%85%8D%E7%BD%AE%20ELK%20%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/jMPtQ3vK3zzi9o5YTidKow" target="_blank" rel="noopener">SpringBoot 配置 ELK 环境</a></p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>MyProject</tag>
      </tags>
  </entry>
  <entry>
    <title>MyProject-path</title>
    <url>/2020/01/01/Project-path/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/UVmVBGggsaiuFH-WEtSRkg" target="_blank" rel="noopener">JSON Web 令牌（JWT）是如何保护 API 的？？</a></p>
<ol start="0">
<li>规划项目目录管理，检查开发环境:JDK1.8<ol>
<li>JUnit—-&gt;测试类命名规则</li>
<li>Mockito—–&gt;搭建mockserver</li>
<li>编译时检查规范SonarLint<br> <a href="https://blog.csdn.net/qq_35981283/article/details/81080402" target="_blank" rel="noopener">https://blog.csdn.net/qq_35981283/article/details/81080402</a></li>
<li>覆盖率Jacoco<br> <a href="https://blog.csdn.net/weixin_40514600/article/details/102583631" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40514600/article/details/102583631</a></li>
<li>配置Swagger</li>
<li>缓存Guava/Caffeine加载<br> <a href="https://blog.csdn.net/mafei6827/article/details/80868931" target="_blank" rel="noopener">https://blog.csdn.net/mafei6827/article/details/80868931</a><br> <a href="https://blog.csdn.net/sinat_36553913/article/details/85837164" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36553913/article/details/85837164</a><br> Guava cache原理    <a href="https://albenw.github.io/posts/df42dc84/" target="_blank" rel="noopener">https://albenw.github.io/posts/df42dc84/</a><br> Guava cache使用总结：<a href="https://www.cnblogs.com/rickiyang/p/11074159.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/11074159.html</a><br> 还在用 Guava Cache？它才是 Java 本地缓存之王  <a href="https://mp.weixin.qq.com/s/Dnk7c0TthRG9puCWAsbb6g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Dnk7c0TthRG9puCWAsbb6g</a><br> 万字详解本地缓存之王 Caffeine，SpringBoot2.X 官方推荐  <a href="https://mp.weixin.qq.com/s/cAZdTyfM6D2GFFQmeoG-jg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cAZdTyfM6D2GFFQmeoG-jg</a></li>
<li>日志打印<br> <a href="https://zhuanlan.zhihu.com/p/96597358" target="_blank" rel="noopener">springboot-自定义注解-系统打印日志</a><br> 你会正确的使用日志吗？:<a href="https://mp.weixin.qq.com/s/wHj12Pez3uSI86fXcA1kqg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wHj12Pez3uSI86fXcA1kqg</a><br> 别在 Java 代码里乱打日志了，这才是打印日志的正确姿势   <a href="https://mp.weixin.qq.com/s/mGWB_VV8cemgRKfWZmZgiw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mGWB_VV8cemgRKfWZmZgiw</a><br> <a href="https://mp.weixin.qq.com/s/9x4HHTrPexwPvCqRZytNxw" target="_blank" rel="noopener">从 0 到 1，看我是如何玩弄千万日志于股掌的~</a></li>
<li>异常规范&amp;&amp; 全局异常</li>
<li>使用数据Flyway控制版本<br> Flyway版本化管理数据库常见错误和解决方法 <a href="https://www.icode9.com/content-2-626086.html" target="_blank" rel="noopener">https://www.icode9.com/content-2-626086.html</a><br> Spring Boot项目使用Flyway的详细教程 <a href="https://www.cnblogs.com/it-deepinmind/p/11761616.html" target="_blank" rel="noopener">https://www.cnblogs.com/it-deepinmind/p/11761616.html</a></li>
<li>分页MybatisHepler    </li>
<li>mysql 主键id用雪花算法<br>一文搞定分布式系统 ID 生成方案  <a href="https://mp.weixin.qq.com/s/JtxOvPoIIpGHhaXbz_Ii9A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JtxOvPoIIpGHhaXbz_Ii9A</a></li>
<li>MapStruct 实体转换类<br>Spring Boot 对象转换 MapStruct 入门    <a href="https://mp.weixin.qq.com/s/JhG5igY_1XJjGx8S0gSBEQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JhG5igY_1XJjGx8S0gSBEQ</a><br>BeanUtils 来做对象转换吗？快试试 MapStruct 吧   <a href="https://mp.weixin.qq.com/s/hrpoYHAN7xLcd1JbVtPXEw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hrpoYHAN7xLcd1JbVtPXEw</a></li>
<li>生成string方法</li>
<li>数据库界的 Swagger，一键自动生成 Java 实体类和数据库文档！不讲武德<br> <a href="https://mp.weixin.qq.com/s/UPh0--gqPLQsYJAmARjbyQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/UPh0--gqPLQsYJAmARjbyQ</a></li>
<li>MyBatis  sql日志打印<br> MyBatis  sql打印<br> MyBatis Plus 常用 API 全套教程，看完没有不懂的:<a href="https://mp.weixin.qq.com/s/MIW7Z3P9EJTVZopK1vMwsw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MIW7Z3P9EJTVZopK1vMwsw</a><br> <a href="https://www.cnblogs.com/it-deepinmind/p/11761616.html" target="_blank" rel="noopener">https://www.cnblogs.com/it-deepinmind/p/11761616.html</a></li>
<li>加密算法：<a href="https://www.cnblogs.com/rickiyang/p/13210830.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/13210830.html</a></li>
</ol>
</li>
</ol>
<pre><code>别人博客;  https://www.cnblogs.com/rickiyang/
https://www.zhihu.com/people/xue-chuan-da-chong</code></pre><p>微服务全流程分析  :<a href="https://www.cnblogs.com/rickiyang/p/12153070.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/12153070.html</a><br>零拷贝(Zero-copy) 浅析及其应用  <a href="https://www.cnblogs.com/rickiyang/p/13265043.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/13265043.html</a><br>MYSQL 整体架构浅析 <a href="https://www.cnblogs.com/rickiyang/p/13473854.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/13473854.html</a><br>分布式事务 <a href="https://www.cnblogs.com/rickiyang/p/13704868.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/13704868.html</a><br>MySQL 主从复制原理不再难 <a href="https://www.cnblogs.com/rickiyang/p/13856388.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/13856388.html</a><br> Spring Cloud 大全学习  <a href="https://www.cnblogs.com/rickiyang/category/1583046.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/category/1583046.html</a><br><a href="https://www.cnblogs.com/brady-wang/p/8416116.html" target="_blank" rel="noopener">博客打赏</a><br>跨域问题:<a href="https://mp.weixin.qq.com/s/1Y4eEckZedjiH1cq0Z66XQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1Y4eEckZedjiH1cq0Z66XQ</a><br>谈谈几个 Spring Cloud 常见面试题及答案:<a href="https://mp.weixin.qq.com/s/T_XaGbDzKmwFSXSyeFo__g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/T_XaGbDzKmwFSXSyeFo__g</a></p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>MyProject</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-path</title>
    <url>/2020/01/01/Python-Python%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzU5MzU5NzIzMw==&scene=1&album_id=1339404513958117378#wechat_redirect" target="_blank" rel="noopener">python基础及公众号</a></p>
<p><a href="https://mp.weixin.qq.com/s/XV55NgUYuonc4WF8mEtBaA" target="_blank" rel="noopener">pPython金融实战案例精粹（斯文 著）</a><br><a href="https://item.jd.com/65004647657.html" target="_blank" rel="noopener">基于Python的金融分析与风险管理</a><br><a href="https://mp.weixin.qq.com/s/3l5hvaXB4yWUA0XPqC0flw" target="_blank" rel="noopener">Python金融实战（严玉星 著）</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>path</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2020/09/12/Spring-%E6%B6%88%E6%81%AFKafka/</url>
    <content><![CDATA[<p>简历写了会Kafka，面试官90%会让你讲讲acks参数对消息持久化的影响(<a href="https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A</a>)</p>
<p>窥探源码，让我更加优雅的使用Kafka生产者！(<a href="https://mp.weixin.qq.com/s/RHe_YM3fzcVKkV_nHuZcxg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RHe_YM3fzcVKkV_nHuZcxg</a>)</p>
<p>为什么Kafka不支持读写分离？(<a href="https://mp.weixin.qq.com/s/OzAffmFx62Dcs5YgkkP06A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OzAffmFx62Dcs5YgkkP06A</a>)</p>
<p>当面试官问你啥是Kafka的选举时，抓住机会“吊打”他！(<a href="https://mp.weixin.qq.com/s/XvDpq1xxXPzRoRKMO-MxeQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XvDpq1xxXPzRoRKMO-MxeQ</a>)</p>
<p>干趴面试官系列：请简述一下Kafka中的分区分配？(<a href="https://mp.weixin.qq.com/s/cr_IVoAVcUpKJ5kqFbpTPw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cr_IVoAVcUpKJ5kqFbpTPw</a>)</p>
<p>Kafka如何通过精妙的架构设计优化JVM GC问题？(<a href="https://mp.weixin.qq.com/s/XheJNFr5iEVCptZNw6c2oQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XheJNFr5iEVCptZNw6c2oQ</a>)</p>
<p>Kafka参数调优实战，看这篇文章就够了！(<a href="https://mp.weixin.qq.com/s/YLrGg-jx5ddmHECmdccppw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YLrGg-jx5ddmHECmdccppw</a>)</p>
<h2 id="Kafka是什么？"><a href="#Kafka是什么？" class="headerlink" title="Kafka是什么？"></a>Kafka是什么？</h2><p>Kafka是分布式实时流处理平台。在这个平台上，可以：</p>
<ul>
<li>发布与订阅消息</li>
<li>作为消息中间件使用(类比于一个有入水口和出水口的大型蓄水池)</li>
<li>对实时流数据传输具有可靠保证</li>
</ul>
<h3 id="Kafka解决什么问题？"><a href="#Kafka解决什么问题？" class="headerlink" title="Kafka解决什么问题？"></a>Kafka解决什么问题？</h3><p><img src="/Kafka/%E8%A7%A3%E8%80%A61.png" alt="解耦1" title="解耦1"><br><img src="/Kafka/%E8%A7%A3%E8%80%A62.png" alt="解耦2" title="解耦2"></p>
<ul>
<li>解耦:让系统解耦,不再相互依赖</li>
<li>削峰:</li>
<li>异步:<h3 id="Kafka在大数据体系中的位置"><a href="#Kafka在大数据体系中的位置" class="headerlink" title="Kafka在大数据体系中的位置"></a>Kafka在大数据体系中的位置</h3><img src="/Kafka/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE.png" alt="大数据位置" title="大数据位置"></li>
</ul>
<h3 id="Kafka一共提供了如下四类核心API"><a href="#Kafka一共提供了如下四类核心API" class="headerlink" title="Kafka一共提供了如下四类核心API"></a>Kafka一共提供了如下四类核心API</h3><p><img src="/Kafka/%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83API.png" alt="四大核心API" title="四大核心API"><br>Kafka所起的作用是：消息中间件、消息引擎、消息队列等</p>
<ul>
<li>Producer API：生产者API</li>
<li>Consumer API：消费者API</li>
<li>Streams API：流式处理API</li>
<li>Connector API：与各其他数据库系统对接API</li>
</ul>
<h2 id="Kafka集群的安装、部署与配置"><a href="#Kafka集群的安装、部署与配置" class="headerlink" title="Kafka集群的安装、部署与配置"></a>Kafka集群的安装、部署与配置</h2><h3 id="Kafka集群HA-高可用-模式部署的原理"><a href="#Kafka集群HA-高可用-模式部署的原理" class="headerlink" title="Kafka集群HA(高可用)模式部署的原理"></a>Kafka集群HA(高可用)模式部署的原理</h3><ul>
<li>任何分布式系统都有HA(Hight Availability)模式，即高可用性模式。</li>
<li>Kafka的HA机制主要是通过数据复制和领袖选举来保证的</li>
</ul>
<p>假设用三台服务器部署Kafka集群，其整体架构应该如下所示<br><img src="/Kafka/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="高可用架构图" title="高可用架构图"></p>
<p>这里网上很多其他教程中ZooKeeper只有一个实例，这其实是不对的。ZooKeeper应该需要多个实例才能真正做到高可用性。具体表现为两个方面的高可用性：</p>
<ul>
<li>ZK集群的高可用性：<br>　　当ZooKeeper集群中有一个结点挂掉的话，会立刻有新的ZK结点代替该挂掉的结点。集群版的Zookeeper之间实际上是互为备份的，这样保证了ZK的整体服务不会有问题。</li>
<li>Kafka集群的高可用性<br>　　当Kafka中有一个实例挂掉的话，ZooKeeper服务会立刻从剩下的实例中选出一个作为新的领袖结点，从而代替挂掉的实例，实现了Kafka集群的高可用性。</li>
</ul>
<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h3 id="Kafka与ZooKeeper的关系"><a href="#Kafka与ZooKeeper的关系" class="headerlink" title="Kafka与ZooKeeper的关系"></a>Kafka与ZooKeeper的关系</h3><p>那么为什么搭建Kafka集群一定需要ZooKeeper呢？从以上其实可以看出：Kafka集群实际上是利用了外部的ZooKeeper集群来解决其分布式一致性问题。如下图所示<br><img src="/Kafka/kafka%E4%B8%8EZK.png" alt="kafka与ZK" title="kafka与ZK"></p>
<p>我们可以简单的认为Kafka将ZooKeeper做数据库用了(哨兵)，用于管理producer，broker和consumer之间的协同调用。<br>一般分布式系统中状态一致性的维护有以下两种方式：</p>
<ul>
<li>P2P自己维护，例如Redis集群</li>
<li>通过第三方系统(ZooKeeper)维护，例如Kafka集群</li>
</ul>
<h3 id="Kafka集群的故障转移"><a href="#Kafka集群的故障转移" class="headerlink" title="Kafka集群的故障转移"></a>Kafka集群的故障转移</h3><p>在高可用性分布式系统中，故障转移一般是以“心跳”或者“会话”的机制来实现的。Kafka的故障转移方式则是采用会话机制：每个Kafka实例启动后，都会以会话形式把自己注册到ZooKeeper服务中。一旦该实例运转现问题，它与ZooKeeper的会话便不能维持从而超时失效，此时Kafka集群会选举出另一个实例来完全代替这个实例继续提供服务，并且这一切换过程对外界服务完全透明。下图表明的是Kafka在ZooKeeper中保存的相关信息及其作用：<br><img src="/Kafka/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png" alt="故障转移" title="故障转移"></p>
<h3 id="Kafka集群搭建"><a href="#Kafka集群搭建" class="headerlink" title="Kafka集群搭建"></a>Kafka集群搭建</h3><p>Kafka集群的搭建过程，一共分为三个步骤</p>
<h4 id="Step1：下载Kafka包"><a href="#Step1：下载Kafka包" class="headerlink" title="Step1：下载Kafka包"></a>Step1：下载Kafka包</h4><p>示例采用的Kafka版本为kafka_2.11-2.0.0。注意这个版本号前面的2.11表明的是编译该Kafka所用的Scala语言的版本号，后面的2.0.0才是Kafka的真正版本号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1# 下载包</span><br><span class="line">2wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;kafka&#x2F;2.0.0&#x2F;kafka_2.11-2.0.0.tgz</span><br><span class="line">3# 解压缩</span><br><span class="line">4tar -zxvf kafka_2.11-2.0.0.tgz</span><br><span class="line">5cd kafka_2.11-2.0.0</span><br></pre></td></tr></table></figure>

<h4 id="Step2：修改配置文件"><a href="#Step2：修改配置文件" class="headerlink" title="Step2：修改配置文件"></a>Step2：修改配置文件</h4><p>要修改的配置文件名称为：server.properties，修改的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1broker.id&#x3D;2 # 用唯一的数字进行区分</span><br><span class="line">2listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;99.99.99.99:9092 # 本机IP</span><br><span class="line">3advertised.listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;99.99.99.99:9092  # 本机IP</span><br><span class="line">4zookeeper.connect&#x3D;99.99.99.99:2181,99.99.99.98:2181,99.99.99.97:2181 # zookeeper的集群地址</span><br><span class="line">5log.dirs&#x3D;&#x2F;home&#x2F;work&#x2F;kafka-logs # 数据存放地址</span><br><span class="line">6log.retention.hours&#x3D;1 # 数据保留的时间</span><br></pre></td></tr></table></figure>
<h4 id="Step3：启动Kafka"><a href="#Step3：启动Kafka" class="headerlink" title="Step3：启动Kafka"></a>Step3：启动Kafka</h4><ul>
<li>启动之前确保ZooKeeper进程存在，且处于正常状态</li>
<li>在每台机器上逐一启动（重要）<br>启动和关闭命令如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1# 启动Kafka</span><br><span class="line">2bin&#x2F;kafka-server-start.sh config&#x2F;server.properties &gt; kafka_start.log 2&gt;&amp;1 &amp;</span><br><span class="line">3# 关闭Kafka</span><br><span class="line">4bin&#x2F;kafka-server-stop.sh</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Kafka监控的安装、部署与配置"><a href="#Kafka监控的安装、部署与配置" class="headerlink" title="Kafka监控的安装、部署与配置"></a>Kafka监控的安装、部署与配置</h2><ul>
<li>监控工具用的是：Kafka-Manager</li>
<li><a href="https://github.com/yahoo/kafka-manager" target="_blank" rel="noopener">点击源码下载</a></li>
<li><a href="https://blog.wolfogre.com/posts/kafka-manager-download/" target="_blank" rel="noopener">点击编译好的包下载</a>：非常感谢作者的维护</li>
</ul>
<h3 id="Step1：下载编译好的项目并解压"><a href="#Step1：下载编译好的项目并解压" class="headerlink" title="Step1：下载编译好的项目并解压"></a>Step1：下载编译好的项目并解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1# 下载编译好的包</span><br><span class="line">2wget &quot;https:&#x2F;&#x2F;github.com&#x2F;wolfogre&#x2F;kafka-manager-docker&#x2F;releases&#x2F;download&#x2F;1.3.3.23&#x2F;kafka-manager-1.3.3.23.zip&quot;</span><br><span class="line">3# 下载安装压缩与解压缩的包</span><br><span class="line">4sudo yum install zip</span><br><span class="line">5sudo yum install unzip</span><br><span class="line">6# 解压缩</span><br><span class="line">7unzip kafka-manager-1.3.3.23.zip</span><br></pre></td></tr></table></figure>
<h3 id="Step2：修改配置文件-1"><a href="#Step2：修改配置文件-1" class="headerlink" title="Step2：修改配置文件"></a>Step2：修改配置文件</h3><p>修改配置文件conf/application.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1kafka-manager.zkhosts&#x3D;&quot;99.99.99.99:2181,99.99.99.98:2181,99.99.99.97:2181&quot;</span><br><span class="line">2basicAuthentication.enabled&#x3D;true  # 开启访问认证 </span><br><span class="line">3basicAuthentication.username&#x3D;&quot;admin&quot;  # 设置访问用户名</span><br><span class="line">4basicAuthentication.password&#x3D;&quot;admin&quot;  # 设置访问密码</span><br></pre></td></tr></table></figure>
<h3 id="Step3：启动监控进程"><a href="#Step3：启动监控进程" class="headerlink" title="Step3：启动监控进程"></a>Step3：启动监控进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动监控</span><br><span class="line">bin&#x2F;kafka-manager -Dconfig.file&#x3D;.&#x2F;conf&#x2F;application.conf -Dhttp.port&#x3D;8081 &gt; kafka_manager_start.log 2&gt;&amp;1 &amp;</span><br><span class="line"># 关闭监控</span><br><span class="line">1ps aux | grep kafka-manager | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill</span><br></pre></td></tr></table></figure>

<h3 id="Step4：访问监控地址"><a href="#Step4：访问监控地址" class="headerlink" title="Step4：访问监控地址"></a>Step4：访问监控地址</h3><ul>
<li>可以查看Kafka集群的监控:<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a></li>
</ul>
<h2 id="Kafka原理详解"><a href="#Kafka原理详解" class="headerlink" title="Kafka原理详解"></a>Kafka原理详解</h2><ul>
<li>Kafka中的基本概念</li>
<li>broker：一个独立的Kafka服务器称为一个broker</li>
<li>集群：多个broker组成一个Kafka集群</li>
<li>消息(Message)：Kafka中的数据单元，通过&lt;tpoic、partition、offset&gt;三元组，可以找到在Kafka中唯一对应的一条消息</li>
<li>批次：消息被分批次写入Kafka，批次就是一组消息</li>
<li>副本(Replica)：冗余机制，防止数据丢失。分为领导者副本（leader replica）与追随者副本（follower replica）</li>
<li>消息模式：消息被序列化的方式：Json、XML、Apache Avro</li>
<li>提交：更新分区当前位置的操作叫作提交</li>
<li>主题(Topic)：不同的主题，类比MySQL数据库中不同的表格</li>
<li>分区(Partition)：一个主题的消息可以设置多个分区</li>
<li>生产者：创建消息，消息的输入</li>
<li>消费者：读取消息，消息的输出</li>
</ul>
<h3 id="消息复制与分区"><a href="#消息复制与分区" class="headerlink" title="消息复制与分区"></a>消息复制与分区</h3><p><img src="/Kafka/%E6%B6%88%E6%81%AF%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%88%86%E5%8C%BA.png" alt="消息复制与分区" title="消息复制与分区"></p>
<ul>
<li>一个主题可以包含多个分区。Kafka无法在整个主题范围内保证消息的顺序，但可以保证消息在单个分区内的顺序。</li>
<li>Kafka在物理上把Topic分成一个或多个Partition，每个Partiton在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。</li>
<li>Kafka通过分区设计可以实现数据冗余和伸缩，分区可以分布在不同的服务器上，以此为高并发提供可能。</li>
<li>消息复制指的是每一个分区都可能会有一个或者多个副本，其中有一个副本会被推选为领袖节点，其余的落选的为从节点。其中领袖节点将会跟踪与其保持同步的副本列表，该列表称为ISR（In-Sync Replica）。</li>
</ul>
<p>Kafka默认提供了很智能的leader选举算法，可以在集群的所有机器上以均等机会分散各个分区的leader节点，从而整体上实现了负载均衡。Kafka保证同一个分区的多个副本一定不会分配在同一台物理机上。如下图所示：<br><img src="/Kafka/%E5%88%86%E5%8C%BA%E5%8E%9F%E7%90%86.png" alt="分区原理" title="分区原理"></p>
<h3 id="数据的清理"><a href="#数据的清理" class="headerlink" title="数据的清理"></a>数据的清理</h3><ul>
<li>对于Kafka来说，磁盘是最重要的子系统。所有的消息都保存在磁盘上，所以Kafka的性能严重依赖磁盘的性能。</li>
<li>对于超过时间周期的数据，Kafka会对其进行清理</li>
</ul>
<h3 id="Kafka的高性能"><a href="#Kafka的高性能" class="headerlink" title="Kafka的高性能"></a>Kafka的高性能</h3><p>Kafka的吞吐性能可达到千万级，相比于其他的系统，Kafka为什么有如此优秀的性能表现呢？原因有以下几点：</p>
<ul>
<li>Kafka大量使用操作系统页缓存，内存操作速度快且命中率高</li>
<li>Kafka不直接参与物理I/O操作，而是交由最擅长此事的操作系统来完成</li>
<li>采用追加写入方式，摒弃了缓慢的磁盘随机读写操作</li>
<li>使用以sendfile为代表的零拷贝技术加强了网络间的数据传输效率<h2 id="Kafka配置文件详解"><a href="#Kafka配置文件详解" class="headerlink" title="Kafka配置文件详解"></a>Kafka配置文件详解</h2>Kafka中一共有四类配置，分别如下：</li>
</ul>
<ol>
<li>broker configs：server.properties（主要）</li>
<li>zookeeper configs：zookeeper.properties（主要）</li>
<li>consumer configs ：consumer.properties（生产者配置文件）</li>
<li>producer configs：producer.properties（消费者配置文件）其中broker和zookeeper是主要的配置文件。</li>
</ol>
<h3 id="Kafka的配置文件"><a href="#Kafka的配置文件" class="headerlink" title="Kafka的配置文件"></a>Kafka的配置文件</h3><p>Kafka的配置文件对应名称为：server.properties，其示例及字段解释如下：</p>
<ul>
<li>broker.id=0 # 用唯一的数字进行区分实例，从0开始</li>
<li>host.name=99.99.99.99 #本机的IP地址</li>
<li>zookeeper.connect=99.99.99.99:2181,99.99.99.98:2181,99.99.99.97:2181 # Zookeeper的集群地址</li>
<li>log.dirs=/ssd1/kafka-logs-1,/ssd2/kafka-logs-2,/ssd3/kafka-logs-3 # 数据存放地址</li>
<li>num.network.threads=24 # broker处理消息的线程数</li>
<li>num.io.threads=60 # broker处理磁盘IO的线程数</li>
<li>socket.send.buffer.bytes=102400</li>
<li>socket.receive.buffer.bytes=102400</li>
<li>socket.request.max.bytes=104857600</li>
<li>num.partitions=3 # 创建topic时的默认分区数</li>
<li>num.recovery.threads.per.data.dir=8</li>
<li>offsets.topic.replication.factor=3</li>
<li>transaction.state.log.replication.factor=3</li>
<li>transaction.state.log.min.isr=3</li>
<li>log.retention.hours=96 # 日志保留时间为四天</li>
<li>log.segment.bytes=107374182</li>
<li>log.retention.check.interval.ms=300000 # 文件大小检查时间周期</li>
<li>zookeeper.connection.timeout.ms=6000 # zookeeper的心跳时间间隔</li>
<li>group.initial.rebalance.delay.ms=3<br>// 新增修改的配置</li>
<li>auto.create.topics.enable=false   # 不允许自动创建Topic</li>
<li>auto.leader.rebalance.enable=true   # 允许自动平衡数据</li>
<li>background.threads=15 # 后台任务的线程数</li>
<li>delete.topic.enable=true # 允许通过客户端删除topic</li>
<li>leader.imbalance.check.interval.seconds=300 # 检查leader是否不平衡的时间间隔，5分钟检查一次</li>
<li>leader.imbalance.per.broker.percentage=10 # leader的不平衡比例，如果超过这个比例，会对分区进行重新平衡</li>
<li>default.replication.factor=2 # 创建Topic时的默认副本数，表示一份数据，有两份</li>
<li>controlled.shutdown.enable=true # 优雅的重启，关闭一台机器的时候将leader转移到其他机器</li>
</ul>
<p>其中对于磁盘容量的规划与以下因素有关：</p>
<ul>
<li>新增消息数</li>
<li>消息留存时间</li>
<li>平均消息大小</li>
<li>副本数</li>
<li>是否启动压缩</li>
</ul>
<h3 id="ZooKeeper的配置文件"><a href="#ZooKeeper的配置文件" class="headerlink" title="ZooKeeper的配置文件"></a>ZooKeeper的配置文件</h3><p>ZooKeeper的配置文件对应名称为：zookeeper.properties，其示例及字段解释如下：</p>
<ul>
<li>dataDir=/ssd1/zookeeper # 数据存储目录</li>
<li>clientPort=2181 # zookeeper 对外服务的接口</li>
<li>maxClientCnxns=0 # 最大客户端连接数量</li>
<li>tickTime=2000 # 最小时间单元（毫秒）</li>
<li>initLimit=10 # 领袖节点同步最新数据的最长时间，10个时间单元</li>
<li>syncLimit=5 # 心跳机制的时间间隔，5个时间单元</li>
<li>server.1=99.99.99.99:2888:3888 # 第一个端口是主从同步的通信端口，第二个端口是领袖选举的端口</li>
<li>server.2=99.99.99.98:2888:3888</li>
<li>server.3=99.99.99.97:2888:3888</li>
</ul>
<h2 id="Kafka命令行操作"><a href="#Kafka命令行操作" class="headerlink" title="Kafka命令行操作"></a>Kafka命令行操作</h2><p>本节主要讲解Kafka常用的命令行操作及其示例<br>Topic的创建、删除与查看<br>//创建一个副本数为1，分区数为3的Topic，名称为test</p>
<ul>
<li>bin/kafka-topics.sh –create –zookeeper 99.99.99.99:2181 –replication-factor 1 –partitions 3 –topic test<br>// 创建一个副本数为1，分区数为3，日志保留6小时的Topic，名称为test2</li>
<li>bin/kafka-topics.sh –create –zookeeper 99.99.99.99:2181 –replication-factor 1 –partitions 3 –topic test –config delete.retention.ms=21600000<br>// 删除Topic</li>
<li>bin/kafka-topics.sh –delete –zookeeper 99.99.99.99:2181 –topic test<br>// 查看指定Topic的所有信息</li>
<li>bin/kafka-topics.sh –describe –zookeeper 99.99.99.99:2181 –topic test<br>// 列出所有的Topic 注意Zookeeper后面的IP地址可以写集群里面任一Zookeeper的地址和端口</li>
<li>bin/kafka-topics.sh –list –zookeeper 99.99.99.99:2181</li>
</ul>
<h3 id="生产者与消费者客户端使用示例"><a href="#生产者与消费者客户端使用示例" class="headerlink" title="生产者与消费者客户端使用示例"></a>生产者与消费者客户端使用示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生产者</span><br><span class="line">bin&#x2F;kafka-console-producer.sh --broker-list 99.99.99.99:9092 --topic test</span><br><span class="line"># 消费者</span><br><span class="line">bin&#x2F;kafka-console-consumer.sh --bootstrap-server 99.99.99.99:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure>
<p>这些所有Kafka脚本工具虽然实现了各自不同的功能，但底层都是使用kafka-run-class.sh脚本来实现的</p>
<h3 id="列出所有的消费者"><a href="#列出所有的消费者" class="headerlink" title="列出所有的消费者"></a>列出所有的消费者</h3><p>bin/kafka-consumer-groups.sh –bootstrap-server 99.99.99.99:9092 –list</p>
<h3 id="查看分区里面最新的消息"><a href="#查看分区里面最新的消息" class="headerlink" title="查看分区里面最新的消息"></a>查看分区里面最新的消息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注意这里写机器的IP地址和域名都可以,查看指定Topic，指定分区的最新消息。</span><br><span class="line">bin&#x2F;kafka-console-consumer.sh --bootstrap-server 99.99.99.99:9092 --topic test --offset latest --partition 0</span><br></pre></td></tr></table></figure>
<h3 id="生产者吞吐量测试"><a href="#生产者吞吐量测试" class="headerlink" title="生产者吞吐量测试"></a>生产者吞吐量测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-producer-perf-test.sh --num-records 100000 --topic test --producer-props bootstrap.servers&#x3D;99.99.99.99:9092,99.99.99.98:9092,99.99.99.97:9092 --throughput 5000 --record-size 102400 --print-metrics</span><br></pre></td></tr></table></figure>
<h3 id="消费者吞吐量测试"><a href="#消费者吞吐量测试" class="headerlink" title="消费者吞吐量测试"></a>消费者吞吐量测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-consumer-perf-test.sh --topic test --messages 100000 --num-fetch-threads 10 --threads 10 --broker-list 99.99.99.99:9092,99.99.99.98:9092,99.99.99.97:9092 --group perf-consumer-30108</span><br></pre></td></tr></table></figure>

<h2 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h2><p>消息发送机制,发送消息有以下三种方式：</p>
<ul>
<li>发送并忘记：发送消息，但不关心它是否真正到达</li>
<li>同步发送：阻塞发送确保消息到达</li>
<li>异步发送：非阻塞发送，不一定确保消息达到，但有重试机制<br>注:Kafka异步发送消息比同步发送消息要快，一般采用异步发送消息</li>
</ul>
<p>其中消息发送中的键有两个用途：</p>
<ul>
<li>可以作为消息的附加信息</li>
<li>可以用来决定消息该被写入到主题的哪个分区（hash指定），拥有相同键的消息将被写到同一个分区</li>
</ul>
<h3 id="生产者Python代码示例"><a href="#生产者Python代码示例" class="headerlink" title="生产者Python代码示例"></a>生产者Python代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">from kafka import KafkaProducer</span><br><span class="line"></span><br><span class="line">producer &#x3D; KafkaProducer(bootstrap_servers&#x3D;[&quot;99.99.99.99:9092&quot;,&quot;99.99.99.98:9092&quot;,&quot;99.99.99.97:9092&quot;], retries&#x3D;5, client_id&#x3D;&quot;1&quot;, acks&#x3D;1)</span><br><span class="line"></span><br><span class="line">topic &#x3D; &quot;test&quot;</span><br><span class="line"></span><br><span class="line">for number in range(100):</span><br><span class="line">   time.sleep(1)</span><br><span class="line">   message &#x3D; &quot;Hello &#123;0&#125;&quot;.format(number)</span><br><span class="line">   future &#x3D; producer.send(topic,  json.dumps(message).encode(&#39;utf-8&#39;))</span><br><span class="line">   result &#x3D; future.get(timeout&#x3D;10)</span><br><span class="line">   print (result.topic)</span><br><span class="line">   print (result.partition)</span><br><span class="line">   print (result.offset)</span><br></pre></td></tr></table></figure>
<p>以上Kafka生产者中，有几个重要参数，说明如下：</p>
<ul>
<li>acks参数制定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的</li>
<li>buffer.memory设置生产者内存缓冲区的大小</li>
<li>comperssion.type指定消息压缩方式</li>
<li>retries重试机制</li>
<li>batch.size每一批次发送消息的大小</li>
</ul>
<h2 id="Kafka消费者"><a href="#Kafka消费者" class="headerlink" title="Kafka消费者"></a>Kafka消费者</h2><h3 id="消费者和消费者群组"><a href="#消费者和消费者群组" class="headerlink" title="消费者和消费者群组"></a>消费者和消费者群组</h3><p>Kafka消费者经常会做一些高延迟的操作，比如把数据写到数据库或HDFS，或者使用数据进行比较耗时的计算。在这些情况下，单个消费者无法跟上数据生成的速度，所以可以增加更多的消费者，让它们分担负载，每个消费者只处理部分分区的消息。我们有必要为主题创建大量的分区，在负载增长时可以加入更多的消费者。不过不要让消费者的数量超过主题分区的数量。<br><img src="/Kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%BE%A4.png" alt="消费者与消费者群" title="消费者与消费者群"></p>
<h3 id="提交与偏移量"><a href="#提交与偏移量" class="headerlink" title="提交与偏移量"></a>提交与偏移量</h3><ul>
<li>一个消费者关闭或者崩溃则离开消费者群组，原本应该被它读取的消息由其它消费者接收，前提是他们属于同一个消费者群组。</li>
<li>分区的所有权从一个消费者转移到另一个消费者称之为<font color ="red">再均衡（rebalance）</font>。这个过程中，消费者群组无法处理消息。</li>
<li>分区的所有权通过消费者向broker发送心跳来维持，同时消费者的心跳行为也用来维持和群组的从属关系。如果消费者停止发送心跳的时间足够长，导致会话过期，则群组协调器认为它已经死亡，触发再均衡。<br>注:Kafka的再均衡机制会导致一定程度的重复消费问题，解决办法是将消费者与分区绑定。<br>以下详细说明Kafka的再均衡过程<br><img src="/Kafka/rebalance.png" alt="rebalance" title="rebalance"></li>
</ul>
<h3 id="消费者Python代码示例"><a href="#消费者Python代码示例" class="headerlink" title="消费者Python代码示例"></a>消费者Python代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from kafka import KafkaConsumer</span><br><span class="line">import time</span><br><span class="line">topic &#x3D; &quot;test&quot;</span><br><span class="line">consumer &#x3D; KafkaConsumer(topic, group_id&#x3D;&quot;consumer1&quot;, client_id&#x3D;&quot;2&quot;, bootstrap_servers&#x3D;[&quot;99.99.99.99:9092&quot;,&quot;99.99.99.98:9092&quot;,&quot;99.99.99.97:9092&quot;])</span><br><span class="line">for message in consumer:</span><br><span class="line">print (message.topic, message.partition, message.offset, message.key, message.value)</span><br></pre></td></tr></table></figure>
<p>以上Kafka消费者中，有几个重要参数，说明如下：</p>
<ul>
<li>group.id属性，它指定了消费者所属群组的名字</li>
<li>消费者根据消费者群组id来唯一区分和隔离</li>
<li>如果多个消费者进程属于同一个消费群组（groupid）他们之间不会重复消费数据。</li>
</ul>
<h2 id="Kafka-Streams"><a href="#Kafka-Streams" class="headerlink" title="Kafka Streams"></a>Kafka Streams</h2><p>Kafka Streams是Kafka的流式计算的API，Kafka利用这类API可以进行简单的类似于Storm和Flink一样的流式计算处理。流式计算对每一条消息，一共有如下三种处理方式：</p>
<ul>
<li>最多一次（at most once）：消息可能丢失，但不会被重复处理</li>
<li>最小一次（at least once）：消息不会丢失，但可能被处理多次</li>
<li>精确一次（exactly once）：消息一定会被处理且只会被处理一次</li>
</ul>
<p>水印（watermark）通常被用在流式处理领域（Storm、Flink等），以表征元素或事件在基于时间层面上的进度。一个比较经典的表述为：流式系统保证水印t时刻，事件时间（event time）= t’ 且 t’ &lt;= t的所有事件都已经到达或被观测到。</p>
<p>利用Kafka Streams演示word count示例程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个文件数据流</span><br><span class="line">echo -e &quot;all streams lead to kafka\nhello kafka streams\njoin kafka summit&quot; &gt; file-input.txt</span><br><span class="line"># 创建一个Topic</span><br><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper 99.99.99.99:2181 --replication-factor 1 --partitions 3 --topic streams-file-input</span><br><span class="line"># 启动流式计算的处理程序</span><br><span class="line">bin&#x2F;kafka-run-class.sh org.apache.kafka.streams.examples.wordcount.WordCountDemo</span><br><span class="line"># 将文件数据流发送到创建的Topic中，此时流式计算会显示各个单词的数目</span><br><span class="line">bin&#x2F;kafka-console-producer.sh --broker-list 99.99.99.99:9092 --topic streams-file-input &lt; file-input.txt</span><br></pre></td></tr></table></figure>

<h2 id="Kafka-Connect"><a href="#Kafka-Connect" class="headerlink" title="Kafka Connect"></a>Kafka Connect</h2><p>Kafka Connect使Kafka可以和各种数据对接，Kafka Connect与Flume的功能一样</p>
<ul>
<li>Source负责导入数据到Kafka</li>
<li>Sink负责从Kafka导出数据</li>
</ul>
<p>利用Kafka Connect演示从一个文件导入数据到另一个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过配置文件配置数据输入和输出源</span><br><span class="line">&#x2F;bin&#x2F;connect-standalone.sh config&#x2F;connect-standalone.properties config&#x2F;connect-file-source.properties config&#x2F;connect-file-sink.properties</span><br></pre></td></tr></table></figure>
<h2 id="Kafka集群的监控与运维"><a href="#Kafka集群的监控与运维" class="headerlink" title="Kafka集群的监控与运维"></a><a href="https://zhuanlan.zhihu.com/p/92590719" target="_blank" rel="noopener">Kafka集群的监控与运维</a></h2><ul>
<li>Kafka的监控:Kafka-Manager是用Scala语言写的。</li>
<li>Kafka提供了丰富的JMX指标用于实时监控集群运行的健康程度，Kafka-Manager的监控原理就是通过轮询JMX来实时获取这些指标，然后可视化的显示出整个集群的状态。但是在使用它们时，必须要在启动broker前先设置好JMX端口。如下所示：</li>
</ul>
<p>//直接在环境变量里面设置<br>export JMX_PORT=9999</p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Kafka</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis原理</title>
    <url>/2020/09/12/Spring-Mybtis%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://www.cnblogs.com/happyflyingpig/p/7739749.html" target="_blank" rel="noopener">mybatis一级缓存二级缓存</a></p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ安装与使用</title>
    <url>/2020/12/22/Spring-%E6%B6%88%E6%81%AFRabbitMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><ul>
<li>消息(Message)是指在应用间传送的数据。消息可以非常简单,比如：只包含文本字符串,JSON等,也可以很复杂,如内嵌对象。</li>
<li>消息队列中间件(Message Queue Middleware,简称为MQ)是指利用高效可靠消息传递机制进行与平台无关的数据交流,并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型,它可以在分布式环境下扩展进程间的通信。</li>
<li>消息队列中间件,也可以称为消息队列或者消息中间件。一般有两种模式：点对点(P2P)模式,发布/订阅(Pub/Sub)模式。点对点模式：基于队列,生产者发送消息到队列,消费者从队列中接受消息,队列的存在使得消息的异步传输称为可能。发布/订阅模式：定义了如何向一个内容节点(主题topic,可认为是消息传递中介)发布和订阅消息,消息发布者将消息发布到某个主题,而消息订阅者则从主题中订阅消息。主题使得消息的订阅者与消息的发布者保持独立,不需要进行接触即可保证消息的传递,发布/订阅模式在消息的一对多广播时采用。</li>
<li>目前开源的消息中间件,比较主流的有：RabbitMQ,Kafka,ActiveMQ,RocketMQ等。面向消息的中间件(简称为MOM)提供了松散耦合的灵活方式集成应用程序的一种机制。它们提供了基于存储和转发的应用程序中间的异步数据发送,即应用程序彼此不直接通信,而是与作为中介的消息中间件通信。消息中间件提供了有保证的消息发送。应用程序开发人员无须了解远程过程调用(RPC)和网络通信协议的细节</li>
</ul>
<h3 id="消息中间件的作用"><a href="#消息中间件的作用" class="headerlink" title="消息中间件的作用"></a>消息中间件的作用</h3><p>在不同的应用场景下可以展现不同的作用。</p>
<ul>
<li>解耦：在项目启动之初来预测会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的,基于数据的接口层,两边的处理过程都要实现这一接口,这允许你独立地扩展或修改两边的处理过程,只要确保它们遵守同样的皆苦约束即可。</li>
<li>削峰：在访问量剧增的情况下,应用仍然需要继续发挥作用,但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源,无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力,不会因为突发的超负荷请求而完全崩溃。MQ-client提供拉模式,定时或者批量拉取,可以起到削平流量,下游自我保护的作用(MQ需要做的);要想提升整体吞吐量,需要下游优化,例如批量处理等方式(消息接收方需要做的);如果并发量过高/请求量过高,需要通过MQ的队列来削峰</li>
<li>异步通信：在很多时候应用不想也不需要立即处理消息。消息中间件提供了异步处理机制,允许应用把一些消息放入消息中间件中,但并不立即处理它,在之后需要的时候再慢慢处理。</li>
<li>冗余(存储)：有些情况下,处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理,通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前,需要你的处理系统明确地指出改消息已经被处理完成,从而确保你的数据被安全地保存直到你使用完毕。</li>
<li>扩展性：因为消息中间件解耦了应用的处理过程,所以提高消息入队和处理的效率是很容易的,只要另外增加处理过程即可,不需要改变代码,也不需要调节参数。</li>
<li>可恢复性：当系统一部分组件失效时,不会影响到整个系统。消息中间件降低了进程间的耦合度,所以即使一个处理消息的进程挂掉,加入消息中间件中的消息仍然可以在系统恢复后进行处理。</li>
<li>顺序保证：在大多数使用场景下,数据处理的顺序很重要,大部分消息中间件支持一定程度上的顺序性。</li>
<li>缓冲：在任何重要的系统中,都会存在需要不同处理时间元素。消息中间件通过一个缓冲层来帮助任务高效率地执行,写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</li>
</ul>
<h2 id="RabbitMQ的安装及使用"><a href="#RabbitMQ的安装及使用" class="headerlink" title="RabbitMQ的安装及使用"></a>RabbitMQ的安装及使用</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ是基于AMQP协议的,通过使用通用协议就可以做到在不同语言之间传递,RabbitMQ时采用Erlang语言实现AMQP的消息中间件,它最初起源于金融系统,用于在分布式系统中存储转发消息。</p>
<h3 id="RabbitMQ具体特点"><a href="#RabbitMQ具体特点" class="headerlink" title="RabbitMQ具体特点"></a>RabbitMQ具体特点</h3><ul>
<li>可靠性：RabbitMQ使用一些机制来保证可靠性,如持久化,传输确认及发布确认等。</li>
<li>灵活的路由：在消息进入队列之前,通过交换器来路由消息。对于典型的路由功能,RabbitMQ已经提供了一些内置的交换器来实现。针对更复杂的路由功能,可以将多个交换器绑定在一起,也可以通过插件机制来实现自己的交换器。</li>
<li>扩展性：多个RabbitMQ节点可以组成一个集群,也可以根据实际业务情况动态地扩展集群中节点。</li>
<li>高可用性：队列可以在集群中的机器上设置镜像,使得在部分节点出现问题的情况下队列仍然可用。</li>
<li>多种协议：RabbitMQ除了原生支持AMQP协议,还支持STOMP,MQTT等多种消息中间件协议。</li>
<li>多语言客户端：RabbitMQ几乎支持所有常用语言,比如Java,Python,Ruby,PHP,C#,JavaScript等。</li>
<li>管理界面：RabbitMQ提供了一易用的用户界面,使得用户可以监控和管理消息,集群中的节点等。</li>
<li>插件机制：RabbitMQ提供了许多插件,以实现从多方面扩展,当然也可以编写自己的插件。</li>
</ul>
<h3 id="安装Erlang环境"><a href="#安装Erlang环境" class="headerlink" title="安装Erlang环境"></a>安装Erlang环境</h3><h4 id="下载安装Erlang"><a href="#下载安装Erlang" class="headerlink" title="下载安装Erlang"></a>下载安装Erlang</h4><p>在安装RabbitMQ之前需要安装Erlang,建议使用较新版本Erlang,这样可以获得较多更新和改进,<a href="https://www.erlang.org/downloads" target="_blank" rel="noopener">点击进入官网下载</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@instance-5x tar.gz]# tar -zxvf otp_src_20.0.tar.gz -C &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">[root@instance-5x tar.gz]# cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;otp_src_20.0&#x2F;</span><br><span class="line">[root@instance-5x otp_src_20.0]# .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;erlang</span><br><span class="line">[root@instance-5x otp_src_20.0]# make</span><br><span class="line">[root@instance-5x otp_src_20.0]# make install</span><br></pre></td></tr></table></figure>
<p><font color="red">出现报错信息：No curses library functions found。需要安装ncurses</font><br>[root@instance-5x otp_src_20.0]# yum  install  ncurses-devel</p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@instance-5x otp_src_20.0]# vim &#x2F;etc&#x2F;profile</span><br><span class="line">export ERLANG_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;erlang</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$ERLANG_HOME&#x2F;bin</span><br><span class="line">[root@instance-5x otp_src_20.0]# . &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h4 id="验证Erlang是否安装成功"><a href="#验证Erlang是否安装成功" class="headerlink" title="验证Erlang是否安装成功"></a>验证Erlang是否安装成功</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输入erl命令来</span><br><span class="line">[root@instance-5x otp_src_20.0]# erl</span><br><span class="line">Erlang&#x2F;OTP 20 [erts-9.0] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:10] [hipe] [kernel-poll:false]</span><br><span class="line">Eshell V9.0  (abort with ^G)</span><br></pre></td></tr></table></figure>

<h3 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h3><h4 id="下载安装RabbitMQ"><a href="#下载安装RabbitMQ" class="headerlink" title="下载安装RabbitMQ"></a>下载安装RabbitMQ</h4><p><a href="https://www.rabbitmq.com/releases/rabbitmq-server/" target="_blank" rel="noopener">RabbitMQ官网下载地址</a><br>[root@instance-5x tar.gz]# tar -xvf rabbitmq-server-generic-unix-3.6.10.tar /usr/local/</p>
<h4 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export RABBITMQ_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;rabbitmq_server-3.6.10</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$ERLANG_HOME&#x2F;bin:$RABBITMQ_HOME&#x2F;sbin</span><br><span class="line">[root@instance-5x otp_src_20.0]# . &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<h4 id="运行RabbitMQ服务与验证"><a href="#运行RabbitMQ服务与验证" class="headerlink" title="运行RabbitMQ服务与验证"></a>运行RabbitMQ服务与验证</h4><p>[root@instance-5x otp_src_20.0]# rabbitmq-server  -detached</p>
<ul>
<li>rabbitmq-server 命令后面添加一个“-detached” 参数是为了能够让RabbitMQ服务以守护进程的方式在后台运行,这样就不会因为当前Shell窗口的关闭而影响服务</li>
</ul>
<h4 id="验证RabbitMQ是否正常"><a href="#验证RabbitMQ是否正常" class="headerlink" title="验证RabbitMQ是否正常"></a>验证RabbitMQ是否正常</h4><p>rabbitmqctl status 命令查看RabbitMQ是否正常启动</p>
<ul>
<li>[root@instance-5x tar.gz]# rabbitmqctl  status</li>
</ul>
<h3 id="Java配置RabbitMQ及其使用"><a href="#Java配置RabbitMQ及其使用" class="headerlink" title="Java配置RabbitMQ及其使用"></a>Java配置RabbitMQ及其使用</h3><h4 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;4.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="设置账户"><a href="#设置账户" class="headerlink" title="设置账户"></a>设置账户</h4><p>默认情况下,访问RabbitMQ服务的用户名和密码都是“guest”,这个账户有限制,默认只能通过本地网络(如 localhost)访问,远程网络访问受限,所以在实现生产和消费消息之前,需要另外添加一个用户,并设置相应的访问权限。<br>添加新用户,用户名为“root”,密码为“root123”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@instance-5x tar.gz]# rabbitmqctl add_user root root123</span><br><span class="line">[root@instance-5x tar.gz]# rabbitmqctl setpermissions -p &#x2F; root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">[root@instance-5x tar.gz]# rabbitmqctl set_user_tags root administrator</span><br></pre></td></tr></table></figure>

<h4 id="连接RabbitMQ工具类代码："><a href="#连接RabbitMQ工具类代码：" class="headerlink" title="连接RabbitMQ工具类代码："></a>连接RabbitMQ工具类代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class ConnectionUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static ConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        factory &#x3D; new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;a.x.y.z&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        factory.setUsername(&quot;username&quot;);</span><br><span class="line">        factory.setPassword(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Connection getConnection() throws IOException, TimeoutException &#123;</span><br><span class="line">        return factory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Productor-生产者代码"><a href="#Productor-生产者代码" class="headerlink" title="Productor(生产者代码)"></a>Productor(生产者代码)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.MessageProperties;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class RabbitMqProducer &#123;</span><br><span class="line">    private static String EXCHANGE_NAME &#x3D; &quot;exchage_demo&quot;;</span><br><span class="line">    private static String QUEUE_NAME &#x3D; &quot;queue_demo&quot;;</span><br><span class="line">    private static String ROUTING_KEY &#x3D; &quot;routingkey_demo&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line">        &#x2F;&#x2F;创建一个type&#x3D;&quot;direct&quot;,持久化,非自动删除得交换机</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, true, false, null);</span><br><span class="line">        &#x2F;&#x2F;创建一个持久化,非排他的,非自动删除队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line">        &#x2F;&#x2F;将交换机与队列通过路由键(其实是绑定键,只不过direct类型下绑定键(bindingkey)和路由键(routingkey)一致才可以到达)绑定</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line">        &#x2F;&#x2F;发送一条持久化的消息</span><br><span class="line">        String message &#x3D; &quot;hello world d!&quot;;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line">        &#x2F;&#x2F;关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;finished...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Consumer-消费者"><a href="#Consumer-消费者" class="headerlink" title="Consumer(消费者)"></a>Consumer(消费者)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class RabbitMqConsumer &#123;</span><br><span class="line"></span><br><span class="line">    private static String QUEUE_NAME &#x3D; &quot;queue_demo&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建连接</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建信道</span><br><span class="line">        final Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;设置客户端最多接受未被ack的消息个数</span><br><span class="line">        channel.basicQos(64);</span><br><span class="line"></span><br><span class="line">        Consumer consumer &#x3D; new DefaultConsumer(channel) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                super.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;recv message:&quot; + new String(body));</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, consumer);</span><br><span class="line">        &#x2F;&#x2F;等待回调资源执行完毕后关掉资源</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;finished...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="direct类型"><a href="#direct类型" class="headerlink" title="direct类型"></a>direct类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class ExchangeDirectConsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchange &#x3D; &quot;exchange_direct_test001&quot;;</span><br><span class="line">        String exchange_type &#x3D; &quot;direct&quot;;</span><br><span class="line">        String queue &#x3D; &quot;queue_test_001&quot;;</span><br><span class="line">        String routing_key &#x3D; &quot;routing_test001&quot;;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(exchange, exchange_type, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(queue, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(queue, exchange, routing_key);</span><br><span class="line"></span><br><span class="line">        QueueingConsumer consumer &#x3D; new QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queue, true, consumer);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery &#x3D; consumer.nextDelivery();</span><br><span class="line"></span><br><span class="line">            String msg &#x3D; new String(delivery.getBody());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;收到消息：&quot; + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="topic类型"><a href="#topic类型" class="headerlink" title="topic类型"></a>topic类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class ExchangeTopicConsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchange &#x3D; &quot;exchange_topic_test002&quot;;</span><br><span class="line"></span><br><span class="line">        String exchange_type &#x3D; &quot;topic&quot;;</span><br><span class="line"></span><br><span class="line">        String queue &#x3D; &quot;queue_topic_test002&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;切换的时候需要注意解绑</span><br><span class="line">        &#x2F;&#x2F;String routing_key &#x3D; &quot;routing_topic.#&quot;;</span><br><span class="line"></span><br><span class="line">        String routing_key &#x3D; &quot;routing_topic.*&quot;;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(exchange, exchange_type, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(queue, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(queue, exchange, routing_key);</span><br><span class="line"></span><br><span class="line">        QueueingConsumer consumer &#x3D; new QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queue, true, consumer);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery &#x3D; consumer.nextDelivery();</span><br><span class="line"></span><br><span class="line">            String msg &#x3D; new String(delivery.getBody());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;收到消息：&quot; + msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fanout类型"><a href="#fanout类型" class="headerlink" title="fanout类型"></a>fanout类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class ExchangeFanoutConsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException, TimeoutException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchange &#x3D; &quot;exchange_fanout_test003&quot;;</span><br><span class="line"></span><br><span class="line">        String exchange_type &#x3D; &quot;fanout&quot;;</span><br><span class="line"></span><br><span class="line">        String queue &#x3D; &quot;queue_fanout_test003&quot;;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(exchange, exchange_type, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(queue, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(queue, exchange, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        QueueingConsumer consumer &#x3D; new QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queue, true, consumer);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery &#x3D; consumer.nextDelivery();</span><br><span class="line"></span><br><span class="line">            String msg &#x3D; new String(delivery.getBody());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;收到消息：&quot; + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认交换机情况"><a href="#默认交换机情况" class="headerlink" title="默认交换机情况"></a>默认交换机情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String queue &#x3D; &quot;queue_default&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;没有声明绑定指定交换机,则选择默认交换机,当向默认交换机(direct类型)发送消息routingKey等于队列名称时,消息可以路由到当先队列</span><br><span class="line">        channel.queueDeclare(queue, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        QueueingConsumer consumer &#x3D; new QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queue, true, consumer);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery &#x3D; consumer.nextDelivery();</span><br><span class="line">            String msg &#x3D; new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot;收到消息：&quot; + msg);</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; headers &#x3D; delivery.getProperties().getHeaders();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;headers get my1 value:&quot; + headers.get(&quot;my1&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.AMQP;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String queue &#x3D; &quot;queue_default&quot;;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; headers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        headers.put(&quot;my1&quot;, &quot;val1&quot;);</span><br><span class="line">        headers.put(&quot;my2&quot;, &quot;val2&quot;);</span><br><span class="line">        AMQP.BasicProperties properties &#x3D; new AMQP.BasicProperties.Builder()</span><br><span class="line">                .deliveryMode(2)</span><br><span class="line">                .contentEncoding(&quot;utf-8&quot;)</span><br><span class="line">                .expiration(&quot;10000&quot;)</span><br><span class="line">                .headers(headers)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        String msg &#x3D; &quot;message info&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;默认交换机(direct类型,routingKey和队列名称相同即可路由到)</span><br><span class="line">        channel.basicPublish(&quot;&quot;, queue, properties, msg.getBytes());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;记得要关闭相关的连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用交换器和队列"><a href="#使用交换器和队列" class="headerlink" title="使用交换器和队列"></a>使用交换器和队列</h4><h5 id="exchangeDeclare方法详解"><a href="#exchangeDeclare方法详解" class="headerlink" title="exchangeDeclare方法详解"></a>exchangeDeclare方法详解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exchange.DeclareOk exchangeDeclare(String exchange, String type,boolean durable,boolean autoDelete,boolean internal,Map&lt;String, Object&gt; arguments) throws IOException;</span><br></pre></td></tr></table></figure>
<p>这个方法的返回值是Exchange.DeclareOK,用来标识成功声明了一个交换器。各个参数详细说明如下：</p>
<ul>
<li>exchange：交换器的名称。</li>
<li>type：交换器的类型,常见的如fanout,direct,topic等。</li>
<li>durable：设置是否持久化。durable设置true表示持久化,反之是非持久化。持久化可以将交换机存盘,在服务器重启的时候不会丢失相关信息。</li>
<li>autoDelete：设置是否自动删除。autoDelete设置true则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定,之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数 理解为：“当与此交换器连接的客户端都断开时,RabbitMQ会自动删除本交换器”。</li>
<li>internal：设置是否时内置的。如果设置为true,则表示是内置的交换器,客户端程序无法直接发送消息到这和交换器中,只能通过交换器路由到交换器这种方式。</li>
<li>arguments：其他一些结构化参数,比如alternate-exchange等。</li>
</ul>
<h5 id="queueDeclare方法详解"><a href="#queueDeclare方法详解" class="headerlink" title="queueDeclare方法详解"></a>queueDeclare方法详解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) throws IOException;</span><br></pre></td></tr></table></figure>
<ul>
<li>queue：队列的名称。</li>
<li>durable：设置是否持久化。为true则设置队列为持久化。持久化的队列会存盘,在服务器重启的时候可以保证不丢失相关信息。</li>
<li>exclusive：设置是否排他。为true则设置队列为排他的,如果一个队列被声明为排他队列,该队列仅对首次声明它的连接可见,并在连接断开时自动删除。<br>这里需要注意三点：</li>
</ul>
<ol>
<li>排他队列是基于连接(Connection)可见的,同一个连接的不同信道(Channel)是可以同时访问同一连接创建的排他队列；</li>
<li>“首次”是指如果一个连接已经声明了一个排他队列,其他连接是不允许建立同名的排他队列,这个与普通队列不同；</li>
<li>即使该队列是持久化的,一旦连接关闭或者客户端退出,该排他队列都会被自动删除,这种队列适用于一个客户端同时发送和读取消息的应用场景。</li>
</ol>
<ul>
<li>autoDelete：设置是否自动删除。为true则设置队列为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列,之后所有与这个队列连接的消费者都断开时,才会自动删除。不能把这个参数错误地理解为：“当连接到此队列的所有客户端断开时,这个队列自动删除”,因为生产者客户端创建这个队列,或者没有消费者客户端与这个队列连接时,都不会自动删除这个队列。</li>
<li>arguments：设置队列的其他一些参数,如x-message-ttl,x-expires,x-max-leanth,x-max-length-bytes,x-dead-letter-ecchange,x-dead-letter-routing-key,x-max-priority等。</li>
</ul>
<h5 id="queueBind方法详解"><a href="#queueBind方法详解" class="headerlink" title="queueBind方法详解"></a>queueBind方法详解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue.BindOk queueBind(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;</span><br></pre></td></tr></table></figure>
<ul>
<li>queue：队列名称。</li>
<li>exchange：交换器的名称。</li>
<li>routingKey：用来绑定队列和交换器的路由键。</li>
<li>arguments：定义绑定的一些参数。<br>不仅可以将队列和交换器绑定起来,也可以将已经被绑定的队列和交换器进行解绑。具体方法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue.UnbindOk queueUnbind(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="exchangeBind方法详解"><a href="#exchangeBind方法详解" class="headerlink" title="exchangeBind方法详解"></a>exchangeBind方法详解</h5><p>不仅可以将交换器与队列绑定,也可以将交换器与交换器绑定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exchange.BindOk exchangeBind(String destination, String source, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;</span><br></pre></td></tr></table></figure>
<p>绑定之后,消息从source交换器转发到destination交换器,某种程度上来说destination交换器可以看作一个队列。</p>
<h4 id="Productor端发送消息接口"><a href="#Productor端发送消息接口" class="headerlink" title="Productor端发送消息接口"></a>Productor端发送消息接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body)throws IOException;</span><br></pre></td></tr></table></figure>
<ul>
<li>exchange：交换器的名称,指明消息需要发送到哪个交换器中。如果设置为空字符串,则消息会被发送到RabbitMQ默认的交换器中。</li>
<li>routingKey：路由键,交换器根据路由键将消息存储到相应的队列之中。</li>
<li>body：消息体(payload),真正需要发送的消息。</li>
<li>mandatory：当mandatory参数设置为true时,交换器无法根据自身的类型和路由键找到一个符合条件的队列,那么RabbitMQ会调用Basic.Return命令将消息返回给生产者。当mandatory参数设置为false时,出现上述情形,则消息直接被丢弃。(mandatory参数告诉服务器至少将消息路由到一个队列中,否则将消息返回给生产者。)</li>
<li>immediate：immediate参数设置为true时,如果交换器在将消息路由到队列时发现队列上并不存在任何消费者,那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时,该消息会通过Basic.Return返回至生产者。(immediate参数告诉服务器,如果该消息关联的队列上有消费者,则立刻投递；如果所有匹配的队列上都没有消费者,则直接将消息返还给生产者,不用将消息存入队列而等待消费者了。)</li>
<li>props：消息的基本属性集<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String contentType;</span><br><span class="line">private String contentEncoding;</span><br><span class="line">private Map&lt;String,Object&gt; headers;</span><br><span class="line">private Integer deliveryMode;</span><br><span class="line">private Integer priority;</span><br><span class="line">private String correlationId;</span><br><span class="line">private String replyTo;</span><br><span class="line">private String expiration;</span><br><span class="line">private String messageId;</span><br><span class="line">private Date timestamp;</span><br><span class="line">private String type;</span><br><span class="line">private String userId;</span><br><span class="line">private String appId;</span><br><span class="line">private String clusterId;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="MQ端设置"><a href="#MQ端设置" class="headerlink" title="MQ端设置"></a>MQ端设置</h4><h5 id="mandatory参数-immediate参数-备份交换器"><a href="#mandatory参数-immediate参数-备份交换器" class="headerlink" title="mandatory参数/immediate参数/备份交换器"></a>mandatory参数/immediate参数/备份交换器</h5><ul>
<li>mandatory参数</li>
</ul>
<ol>
<li><p>当mandatory参数设置为true时,交换器无法根据自身的类型和路由键找到一个符合条件的队列,那么RabbitMQ会调用Basic.Return命令将消息返回给生产者。</p>
</li>
<li><p>当mandatory参数设置为false时,出现上述情形,则消息直接被丢弃。(mandatory参数告诉服务器至少将消息路由到一个队列中,否则将消息返回给生产者。)<br>那么生产者如何获取到没有被正确路由到合适队列的消息呢？这时候可以通过调用channel.addReturnListener来添加ReturnListener监视器实现。<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line">        String exchange &#x3D; &quot;exchange_test_return&quot;;</span><br><span class="line">        String routing_key &#x3D; &quot;return.save&quot;;</span><br><span class="line">        String routing_key_error &#x3D; &quot;abc.save&quot;;</span><br><span class="line"></span><br><span class="line">        channel.addReturnListener(new ReturnListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                System.out.println(&quot;---------handle  return----------&quot;);</span><br><span class="line">                System.out.println(&quot;replyCode: &quot; + replyCode);</span><br><span class="line">                System.out.println(&quot;replyText: &quot; + replyText);</span><br><span class="line">                System.out.println(&quot;exchange: &quot; + exchange);</span><br><span class="line">                System.out.println(&quot;routingKey: &quot; + routingKey);</span><br><span class="line">                System.out.println(&quot;properties: &quot; + properties);</span><br><span class="line">                System.out.println(&quot;body: &quot; + new String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发送一条消息</span><br><span class="line">        String msg &#x3D; &quot;message info return&quot;;</span><br><span class="line">        String msg_error &#x3D; &quot;message info error return&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;交换器无法根据自身的类型和路由键找到一个符合条件的队列 mandatory设置为true,消息才会返回给生产者,否则直接丢弃。</span><br><span class="line">        channel.basicPublish(exchange, routing_key, true,null, msg.getBytes());</span><br><span class="line">        channel.basicPublish(exchange, routing_key_error, true,null, msg_error.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;记得要关闭相关的连接</span><br><span class="line">        &#x2F;&#x2F;channel.close();</span><br><span class="line">        &#x2F;&#x2F;connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line">        String exchange &#x3D; &quot;exchange_test_return&quot;;</span><br><span class="line">        String queue &#x3D; &quot;queue_test_return&quot;;</span><br><span class="line">        String routing_key &#x3D; &quot;return.#&quot;;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(exchange, &quot;topic&quot;, false, false, false, null);</span><br><span class="line">        channel.queueDeclare(queue, true, false, false, null);</span><br><span class="line">        channel.queueBind(queue, exchange, routing_key);</span><br><span class="line"></span><br><span class="line">        com.rabbitmq.client.Consumer consumer &#x3D; new DefaultConsumer(channel) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                super.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(&quot;消费端:&quot; + new String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(queue, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>immediate：immediate参数设置为true时,如果交换器在将消息路由到队列时发现队列上并不存在任何消费者,那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时,该消息会通过Basic.Return返回至生产者。(immediate参数告诉服务器,如果该消息关联的队列上有消费者,则立刻投递；如果所有匹配的队列上都没有消费者,则直接将消息返还给生产者,不用将消息存入队列而等待消费者了。)<br>RabbitM</p>
</li>
<li><p>备份交换器,英文名称为 Alternate Exchange,简称AE,或者更直白地称之为“备胎交换器”。生产者在发送消息的时候如果不设置 mandatory参数,那么消息在未被路由的情况下将会丢失;如果设置了 mandatory参数,那么需要添加 Returnlistener的编程逻辑,生产者的代码将变得复杂。如果既不想复杂化生产者的编程逻辑,又不想消息丢失,那么可以使用备份交换器,这样可以将未被路由的消息存储在 RabbitMQ中,再在需要的时候去处理这些消息。可以通过在声明交换器(调用 channe1. exchange Declare方法)的时候添加alternate- exchange参数来实现,也可以通过策略( Policy)的方式实现。如果两者同时使用,则前者的优先级更高,会覆盖掉 Policy的设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;string,Object&gt; args&#x3D;new HashMap&lt;string,Object&gt;();</span><br><span class="line">args.put(&quot;alternate-exchange&quot;,&quot;myAe&quot;);</span><br><span class="line">channel.exchangeDeclare(&quot;normalExchange&quot;,direct&quot;, true, false, args);</span><br><span class="line">channel.exchangeDeclare(&quot;myAe&quot;,&quot;fanout&quot;, true, false, null);</span><br><span class="line">channel.queueDeclare(&quot;normalQueue&quot;, true, false, false, null);</span><br><span class="line">channel.queueBind(&quot;normal Queue&quot;,&quot;normalExchange&quot;,&quot;normalKey&quot;);</span><br><span class="line">channel.queueDeclare(&quot;unroutedQueue&quot;, true, false, false, null);</span><br><span class="line">channel.queueBind(&quot;unroutedQueue&quot;,&quot;myAe&quot;,&quot;&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/rabbitMq/%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E5%99%A8.png" alt="备份交换器" title="备份交换器"><br>对于备份交换器,总结了以下几种特殊情况:</p>
<ul>
<li>如果设置的备份交换器不存在,客户端和 RabbitMQ服务端都不会有异常出现,此时消息会丢失。</li>
<li>如果备份交换器没有绑定仼何队列,客户端和 RabbitMQ服务端都不会有异常出现,此时消息会丢失。</li>
<li>如果备份交换器没有任何匹配的队列,客户端和 RabbitMQ服务端都不会有异常出现,此时消息会丢失。</li>
<li>如果备份交换器和 mandatory参数一起使用,那么 mandatory参数无效。</li>
</ul>
<h5 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h5><ul>
<li><p>channel设置Qos的值<br>假设一个场景,首先,我们 RabbitMQ服务器有上万条未处理的消息,我们随便打开一个消费者客户端,会出现下面情况：巨量的消息瞬间全部推送过来,但是我们单个客户端无法同时处理这么多数据!<br>RabbitMQ提供了一种qos(服务质量保证)功能,即在非自动确认消息的前提下,如果一定数目的消息(通过基于 consume或者 channel设置Qos的值)未被确认前,不进行消费新的消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void basicQos(int prefetchCount) throws IOException;</span><br></pre></td></tr></table></figure></li>
<li><p>prefetchCount：prefetch Count:会告诉 RabbitMQ不要同时给一个消费者推送多于N个消息,即一旦有N个消息还没有ack,则该 consumer将 block掉,直到有消息ack。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      String exchangeName &#x3D; &quot;test_qos_exchange&quot;;</span><br><span class="line">String queueName &#x3D; &quot;test_qos_queue&quot;;</span><br><span class="line">String routingKey &#x3D; &quot;qos.#&quot;;</span><br><span class="line"></span><br><span class="line">channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);</span><br><span class="line">channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1 限流方式  第一件事就是 autoAck设置为 false</span><br><span class="line"></span><br><span class="line">channel.basicQos(0, 1, false);</span><br><span class="line">Boolean autoAck&#x3D;false;</span><br><span class="line">channel.basicConsume(queueName, autoAck, new MyConsumer(channel));</span><br></pre></td></tr></table></figure>
</li>
<li><p>弃用QueueingConsumer<br>QueueingConsumer本身有几个大缺陷,需要在使用时特别注意。首当其冲的就是内存溢出的问题,如果由于某些原因,队列之中堆积了比较多的消息,就可能导致消费者客户端内存溢出假死,于是发生恶性循环,队列消息不断堆积而得不到消化。<br>QueueingConsumer还包含(但不仅限于)以下一些缺陷:</p>
</li>
</ul>
<p>QueueingConsumer会拖累同一个 Connection下的所有信道,使其性能降低。<br>同步递归调用 QueueingConsumer会产生死锁。<br>RabbitMQ的自动连接恢复机制(automatic connection recovery)不支持 QueueingConsumer的这种形式。<br>QueueingConsumer不是事件驱动的。</p>
<h4 id="Consumer端消费消息接口"><a href="#Consumer端消费消息接口" class="headerlink" title="Consumer端消费消息接口"></a>Consumer端消费消息接口</h4><p>RabbitMQ的消费模式分为两种：推(Push)模式和拉(Pull)模式。推模式采用Basic.Consume进行消费,而拉模式则是调用Basic.Get进行消费</p>
<h5 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h5><p>接受消息一般通过实现Consumer接口或者继承DefaultConsumer类来实现。当调用与Consumer相关的API方法时,不同的订阅采用不同的消费者标签(consumerTag)来区分彼此,在同一个Channel中的消费者也需要通过唯一的消费者标签以作区分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Consumer consumer &#x3D; new DefaultConsumer(channel) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                super.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;recv message:&quot; + new String(body));</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        boolean autoAck &#x3D; false;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, autoAck, &quot;myConsumer&quot;, consumer);</span><br></pre></td></tr></table></figure>

<p>channel.basicConsume方法详解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String basicConsume(String queue, boolean autoAck, String consumerTag, boolean noLocal, boolean exclusive, Map&lt;String, Object&gt; arguments, Consumer callback) throws IOException;</span><br></pre></td></tr></table></figure>
<ul>
<li>queue：队列名称；</li>
<li>autoAck：设置是否自动确认。建议设置成false,即不自动确认。</li>
<li>consumerTag：消费者标签,用来区分多个消费者。</li>
<li>noLocal：设置为true则表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者。</li>
<li>exclusive：设置是否排他。</li>
<li>arguments：设置消费者的其他参数。</li>
<li>callback：设置消费者的回调函数。用来处理RabbitMQ推送过来的消息,比如DefaultConsumer,使用时需要客户端重写(override)其中的方法。<br>和生产者一样,消费者客户端同样需要考虑线程安全问题。消费者客户端的这些callback会被分配到与Channel不同的线程池上,这意味着消费者客户端可以安全地调用这些阻塞方法,比如channel.queueDeclare,channel.basicCancel等。每个channel都拥有自己独立的线程。最常用的做法是一个Channel对应一个消费者,也就是意味着消费者都彼此之间没有任何关联。当然也可以在一个Channel中维持多个消费者,但是需要注意一个问题,如果Chanel中的一个消费者一直在运行,那么其他消费者的callback会被”耽搁“</li>
</ul>
<h5 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h5><p>通过channel.basicGet方法可以单条地获取消息,其返回值是GetRespone。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetResponse basicGet(String queue, boolean autoAck) throws IOException;</span><br></pre></td></tr></table></figure>
<p>Basic.Consume将信道(Channel)置为接收模式,直到取消队列的订阅为止.在接收模式期间,RabbitMQ会不断的推送消息给消费者,消息数量受Basic.Qos限制.如果只想从队列获取单条消息而不是持续订阅,建议还是使用Basic.get进行消费。但是不能将Basic.Get放在一个循环里代替Basic.Consume,这样会严重影响RabbitMQ的性能.如果实现高吞吐量,消费者理使用Basic.Consume方法</p>
<h2 id="如何确保消息不丢失"><a href="#如何确保消息不丢失" class="headerlink" title="如何确保消息不丢失"></a>如何确保消息不丢失</h2><h3 id="Productor端-生产确认"><a href="#Productor端-生产确认" class="headerlink" title="Productor端:生产确认"></a>Productor端:生产确认</h3><p>在使用RabbitMQ的时候,可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失,除此之外,还会遇到一个问题,当消息的生产者将消息发送出去之后,消息到底有没有正确地到达服务器呢？如果不进行特殊配置,默认情况下发送消息的操作是不会返回任何信息给生产者的,也就是默认情况下生产者是不知道消息有没有正确地到服务器。如果在消息到达服务器之前已经丢失,持久化操作也解决不了这个问题。</p>
<ul>
<li>RabbitMQ针对这个问题,提供了两种解决方式：</li>
<li>同步方式:通过事务机制实现。</li>
<li>异步方式:通过发送方确认(publisher confirm)机制实现。</li>
</ul>
<h4 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h4><p>RabbitMQ客户端中与事务机制相关的方法有三个：</p>
<ul>
<li>channel.txSelect：用于将当前信道设置成事务模式。</li>
<li>channel.txRollback：用于提交事务。</li>
<li>channel.txRollback：用于事务回滚。</li>
</ul>
<p>开启事务机制与不开启相比多了四个步骤：</p>
<ul>
<li>客户端发送Tx.Select,将信道设置为事务模式。</li>
<li>Broker回复Tx.Select-Ok,确认已将信道设置为事务模式。</li>
<li>在发送完消息之后,客户端发送Tx.COmmit提交事务。</li>
<li>Broker回复Tx-Commit-Ok,确认事务提交。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    channel.basicPublish(&quot;exchange_name&quot;, &quot;routing_key&quot;, null, &quot;msg info&quot;.getBytes());</span><br><span class="line">    int result &#x3D; 1 &#x2F; 0;</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
事务确实能够解决消息发送方和RabbitMQ之间消息确认的问题,只有消息成功被RabbitMQ接收,事务才能提交成功,否则便可以在捕获异常之后进行事务回滚,与此同时可以进行消息重发。当时使用事务机制会“吸干”RabbitMQ的性能。</li>
</ul>
<h4 id="发送方确认机制"><a href="#发送方确认机制" class="headerlink" title="发送方确认机制"></a>发送方确认机制</h4><p>生产者将信道设置成confirm(确认)模式,一旦信道进入confirm模式,所有在该信道上面发布的消息都会被指派一个唯一的ID(从1开始),一旦消息被投递到所有匹配的队列之后。RabbitMQ就会发送一个确认(Basic.Ack)给生产者(包含消息的唯一ID),这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的,那么确认消息会在消息写入磁盘之后发出。RabbitMQ回传给生产者的确认消息中的deliveryTag包含了确认消息的序号,此外RabbitMQ也可以设置channel.basicAck方法中的multiple参数,表示到这个序号之前的所有消息都已经得到了处理。<br>发送方确认机制最大的好处在于它是异步的,相比事务机制在一条消息发送之后会使发送端阻塞。</p>
<p>如何实现Confirm确认消息：</p>
<ul>
<li>在channel上开启确认模式：channel.confirmSelect()。</li>
<li>在channel上添加监听：addConfirmListener,监听成功和失败的返回结果,根据具体的结果对消息进行重新发送,或记录日志等后续处理。</li>
</ul>
<p>生产端代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.AMQP;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.ConfirmListener;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line">        String exchange &#x3D; &quot;exchange_test_confirm&quot;;</span><br><span class="line">        String routing_key &#x3D; &quot;confirm.save&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定我们的消息投递模式: 消息的确认模式</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发送一条消息</span><br><span class="line">        String msg &#x3D; &quot;message info confirm&quot;;</span><br><span class="line">        channel.basicPublish(exchange, routing_key, null, msg.getBytes());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;添加一个确认监听</span><br><span class="line">        channel.addConfirmListener(new ConfirmListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123;</span><br><span class="line">                System.out.println(&quot;-----------------ack-------------------&quot;);</span><br><span class="line">                System.out.println(&quot;deliveryTag:&quot; + deliveryTag);</span><br><span class="line">                System.out.println(&quot;multiple:&quot; + multiple);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;handleNack(no ack)出现情况有：磁盘写满,队列到达上限等</span><br><span class="line">            @Override</span><br><span class="line">            public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123;</span><br><span class="line">                System.out.println(&quot;-----------------no ack-------------------&quot;);</span><br><span class="line">                System.out.println(&quot;deliveryTag:&quot; + deliveryTag);</span><br><span class="line">                System.out.println(&quot;multiple:&quot; + multiple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;记得要关闭相关的连接</span><br><span class="line">        &#x2F;&#x2F;channel.close();</span><br><span class="line">        &#x2F;&#x2F;connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费端代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.mine.rabbitmq.rabbitmqbegin.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        Connection connection &#x3D; ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchange &#x3D; &quot;exchange_test_confirm&quot;;</span><br><span class="line"></span><br><span class="line">        String queue &#x3D; &quot;queue_test_confirm&quot;;</span><br><span class="line"></span><br><span class="line">        String routing_key &#x3D; &quot;confirm.#&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(exchange, &quot;topic&quot;, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(queue, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(queue, exchange, routing_key);</span><br><span class="line"></span><br><span class="line">        com.rabbitmq.client.Consumer consumer &#x3D; new DefaultConsumer(channel) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                super.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;消费端:&quot; + new String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(queue, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MQ端设置-持久化"><a href="#MQ端设置-持久化" class="headerlink" title="MQ端设置(持久化)"></a>MQ端设置(持久化)</h3><ul>
<li>交换器的持久化与队列持久化<br>交换器的持久化是通过声明队列时,将durable参数设置为true实现的。如果交换器不设置持久化,那么rabbitmq服务重启之后,相关的交换器元数据(代表交换机的结构数据)将会丢失,不过消息不会丢失,只是不能将消息发送到这个交换器中了,建议将交换器设置为持久化<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queueDeclare(queue, durable, exclusive, autoDelete,  arguments)</span><br><span class="line">channel.queueDeclare(q_name, true, false, false, map);</span><br></pre></td></tr></table></figure>
元数据： 表示数据的数据,例如数据的类型,长度,存放位置等关于数据的信息用来管理和维护数据；例如：书的文本就是书的数据,而书名、作者、版权数据都是书的元数据。元数据并不一定就是用来检索的,也可用于内部的管理,如图书馆系统可以为书定义被借次数这个元数据,以了解书的被借阅情况,确定是否要增加副本数。元数据的使用,可以大大提高系统的检索和管理的效率</li>
<li>消息的持久化<br>队列的持久化只能保证其队列本身的元数据不会被丢失,但是不能保证消息不会被丢失。所以消息本身也需要被持久化,可以在投递消息前设置AMQP.BasicProperties的属性deliveryMode为2即可：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AMQP.BasicProperties low &#x3D; new AMQP.BasicProperties.Builder().deliveryMode(2).build();</span><br></pre></td></tr></table></figure>
设置了队列和消息的持久化,当 RabbitS服务重启之后,消息依旧存在。单单只设置队列持久化,重启之后消息会丢失;单单只设置消息的持久化,重启之后队列消失,继而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。<h3 id="Consumer端-消费确认与拒绝"><a href="#Consumer端-消费确认与拒绝" class="headerlink" title="Consumer端:消费确认与拒绝"></a>Consumer端:消费确认与拒绝</h3>为了保证消息从队列可靠地达到消费者,RabbitMQ提供了消息确认机制(message acknowledgment)。消费者在订阅队列时,可以指定autoAck参数,</li>
<li>当autoAck等于false时,RabbitMQ会等待消费者显示地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记,之后再删除)。</li>
<li>当autoAck等于true时,RabbitMQ会自动把发送出去的消息设置为确认,然后从内存(或者磁盘)中删除,而不管消费者是否真正地消费到了这些消息。</li>
</ul>
<p>采用消息确认机制后,只有设置autoAck参数为false,消费者 就有足够的时间处理消息(任务),不用担心处理消息过程中消费者进程挂掉后消息丢失的问题,因为RabbitMQ会一直等待持有消息直到消费者显示调用Basic.Ack命令为止。当autoAck参数置为false,对于RabbitMQ服务器而言,队列中的消息分为两个部分：一部分时等待投递给消费者的消息；一部分时已经投递给消费者,但是还没有收到消费者确认信号的消息。如果RabbitMQ一直没有收到消费者的确认信号,并且消费此消息的消费者已经断开连接,则RabbitMQ 会安排该消息重新进入队列,等待投递给下一个消费者,当然也有可能还是原来的那个消费者。RabbitMQ不会为未确认的消息设置过期时间,它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开,这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</p>
<p><font color="red">在消费者接收到消息后,如果想明确拒绝当前的消息而不是确认,那么应该怎么做呢？RabbitMQ在2.0.0版本开始引入了Basic.Reject这个命令,消费者客户端可以调用与其对应的channel.basicReject方法来告诉RabbitMQ拒绝这个消息</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void basicReject(long deliveryTag, boolean requeue) throws IOException;</span><br></pre></td></tr></table></figure>

<ul>
<li>deliveryTag：可以看作消息的编号,它是一个64位的长整型值。</li>
<li>requeue：设置为true时,RabbitMQ会重新将这条消息存入队列,以便可以发送给下一个订阅的消费者；如果设置为false,则RabbitMQ会立即把消息从队列中移除,而不会把它发送给新的消费者。<br><font color="blue">Basic.Reject命令一次只能拒绝一条消息,如果想要批量拒绝消息,则可以使用Basic.Nack这个命令</font></li>
</ul>
<h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><h4 id="设置消息的TTL-过期时间"><a href="#设置消息的TTL-过期时间" class="headerlink" title="设置消息的TTL(过期时间)"></a>设置消息的TTL(过期时间)</h4><p>设置消息TTL的两种方法：</p>
<ul>
<li>通过队列属性设置,队列中所有消息都有相同的过期时间。</li>
<li>对消息本身进行单独设置,每条消息的TTL可以不同。</li>
</ul>
<p>如果两种方法一起使用,则消息的TTL以两者之间较小的那个数值为准。<br>消息在队列中的生存时间一旦超时设置的TTL值时,就会变成“死信”(Dead Message),消息者将无法再收到该消息(不绝对,可通过配置“死信”交换器路由到相应的队列)</p>
<ul>
<li><p>队列属性设置<br>通过队列属性设置消息TTL的方法是在channel.queueDeclare方法中加入x-message-ttl参数实现的,单位是毫秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;设置队列消息过期时间为6s</span><br><span class="line">arguments.put(&quot;x-message-ttl&quot;, 6000);</span><br><span class="line">channel.queueDeclare(&quot;queue_name&quot;, true, false, false, arguments);</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息单独设置<br>针对每条消息设置TTL的方法是再channel.basicPublish方法中加入expiration的属性参数,单位是毫秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AMQP.BasicProperties properties &#x3D; new AMQP.BasicProperties.Builder().deliveryMode(2).contentEncoding(&quot;utf-8&quot;).expiration(&quot;10000&quot;).headers(headers).build();</span><br><span class="line">String msg &#x3D; &quot;message info&quot;;</span><br><span class="line">channel.basicPublish(&quot;exchange_name&quot;, &quot;queue_name&quot;, properties, msg.getBytes());</span><br></pre></td></tr></table></figure>
<p>对于第一种设置队列TTL属性的方法,一旦消息过期,就会从队列中抹去,而在第二种方法中,即使消息过期,也不会马上从队列中抹去,因为每条消息是否过期是在即将投递到消费者之前判断的。</p>
</li>
<li><p>为什么这两种方法处理的方式不一样？<br>第一种方法里,队列中已过期的消息肯定在队列头部,RabbitMQ只要定期从队头开始扫描是否有过期的消息即可。<br>第二种方法里,每条消息的过期时间不同,如果要删除所有过期消息势必要扫描整个队列,所以不如等到此消息即将被消费时再判定是否过期,如果过期再进行删除即可。</p>
</li>
</ul>
<h4 id="设置队列的TTL-过期时间"><a href="#设置队列的TTL-过期时间" class="headerlink" title="设置队列的TTL(过期时间)"></a>设置队列的TTL(过期时间)</h4><p>通过channel.queueDeclare方法中的x-expires参数可以控制队列被自动删除前处于未使用状态的时间。未使用的意思是队列上没有任何的消费者,队列也没有被重新声明,并且在过期时间段内也未调用过Basic.Get命令。<br>RabbitMQ会确保在过期时间到达后将队列删除,但是不保障删除的动作有多及时。在RabbitMQ重启后,持久化的队列的过期时间会被重新计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;创建一个过期时间为1分钟的队列(表示如果1分钟之内未使用则会被删除)</span><br><span class="line">arguments.put(&quot;x-expires&quot;, 60000);</span><br><span class="line">channel.queueDeclare(&quot;queue_name&quot;, true, false, false, arguments);</span><br></pre></td></tr></table></figure>

<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>DLX,全称为Dead-Letter-Exchange,可以称为死信交换器,当消息在一个队列中变成死信(dead message)之后,它能被重新发送到另一个交换器中,这个交换器就是DLX,绑定DLX的队列就称为死信队列。<br>消息变成死信一般是由于这几种情况：</p>
<ul>
<li>消息被拒绝(Basic.Reject/Basic.Nack),并且设置requeue参数为false。  </li>
<li>消息过期。</li>
<li>队列达到最大长度。<br>DLX也是一个正常的交换器,和一般交换器没有区别,它能在任何的队列上被指定,实际上就是设置某个队列的属性。当这个队列中存在死信时,RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去,进而被路由到另一个队列,即死信队列。可以监听这个队列中的消息以进行相应的处理,这个特性与将消息的TTL设置为0配合使用可以弥补immediate参数的功能。<br>通过channel.queueDeclare方法中设置x-dead-letter-exchange参数来为这个队列添加DLX：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建DLX：dlx_exchange</span><br><span class="line">channel.exchangeDeclare(&quot;dlx_exchange&quot;, &quot;direct&quot;);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; arguments &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;为队列添加DLX</span><br><span class="line">arguments.put(&quot;x-dead-letter-exchange&quot;, &quot;dlx_exchange&quot;);</span><br><span class="line">&#x2F;&#x2F;也可以为这个DLX指定路由键，如果没有特殊指定，则使用原队列的路由键</span><br><span class="line">arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;dlx-routing-key&quot;);</span><br><span class="line"></span><br><span class="line">channel.queueDeclare(&quot;queue_name&quot;, false, false, false, arguments);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Send &#123;</span><br><span class="line">    final static String NOREMAL_EXCHANGE &#x3D; &quot;normal_exchange&quot;;</span><br><span class="line">    final static String NOREMAL_QUEUE&#x3D; &quot;normal_queue&quot;;</span><br><span class="line">    final static String DLX_EXCHANGE&#x3D; &quot;dlx_exchange&quot;;</span><br><span class="line">    final static String DLX_QUEUE&#x3D; &quot;dlx_queue&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection connection &#x3D; null;</span><br><span class="line">        Channel channel;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection &#x3D; ConnectionUtils.getConnection();</span><br><span class="line">            channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;正常交换器</span><br><span class="line">            channel.exchangeDeclare(NOREMAL_EXCHANGE, BuiltinExchangeType.DIRECT, true);</span><br><span class="line">            &#x2F;&#x2F;创建死信交换器</span><br><span class="line">            channel.exchangeDeclare(DLX_EXCHANGE, BuiltinExchangeType.DIRECT, true);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;设置正常队列参数，添加死信队列</span><br><span class="line">            Map&lt;String, Object&gt; arguments &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;队列消息过期时间</span><br><span class="line">            arguments.put(&quot;x-message-ttl&quot;, 1000);</span><br><span class="line">            &#x2F;&#x2F;设置死信队列</span><br><span class="line">            arguments.put(&quot;x-dead-letter-exchange&quot;, DLX_EXCHANGE);</span><br><span class="line">            &#x2F;&#x2F;设置DLX路由键，不设置，则使用原队列的路由键</span><br><span class="line">            arguments.put(&quot;x-dead-letter-routing-key&quot;, DLX_QUEUE);</span><br><span class="line">            channel.queueDeclare(NOREMAL_QUEUE, true, false, false, arguments);</span><br><span class="line">            channel.queueBind(NOREMAL_QUEUE, NOREMAL_EXCHANGE, NOREMAL_QUEUE);</span><br><span class="line"></span><br><span class="line">            channel.queueDeclare(DLX_QUEUE, true, false, false, null);</span><br><span class="line">            channel.queueBind(DLX_QUEUE,DLX_EXCHANGE,DLX_QUEUE);</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(NOREMAL_EXCHANGE, NOREMAL_QUEUE, MessageProperties.PERSISTENT_TEXT_PLAIN, &quot;死信队列&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (connection !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>实上手动提交的时候，basicNack的最后一个参数requeue = true时，消息会被无限次的放入消费队列重新消费，直至回送ACK。<br>channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);<br>但是当requeue = false 的时候，此时消息就会立马进入到死信队列。<br>channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);</p>
<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。<br>RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过DLX(死信队列)和TTL(过期时间)模拟出延迟队列的功能。<br><img src="/rabbitMq/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.png" alt="延迟队列" title="延迟队列"></p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>具有高优先级的队列具有高的优先权，优先级高的消息具备优先被消费的特权<br>可以通过设置队列的x-max-priority参数来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">arguments.put(&quot;x-max-priority&quot;, 10);</span><br><span class="line">channel.queueDeclare(&quot;queue_name&quot;, false, false, false, arguments);</span><br></pre></td></tr></table></figure>
<p>上面代码配置一个队列的最大优先级。在此之后，需要在发送消息中设置消息当前的优先级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AMQP.BasicProperties properties &#x3D; new AMQP.BasicProperties.Builder().priority(5).build();</span><br><span class="line">String msg &#x3D; &quot;message info&quot;;</span><br><span class="line">channel.basicPublish(&quot;exchange_name&quot;, &quot;queue_name&quot;, properties, msg.getBytes());</span><br></pre></td></tr></table></figure>
<p>上面的代码中设置消息的优先级为5.默认最低为0，最高为队列设置的最大优先级。优先级高的消息可以被优先消费，这个这个也是有前提的：如果在消费者的消费速度大于生产者的速度且Broker中没有消息堆积的情况下，对发送的消息设置优先级也就没有上面实际意义。</p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ基本原理</title>
    <url>/2020/12/22/Spring-%E6%B6%88%E6%81%AFRabbitM%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><a href="https://mp.weixin.qq.com/s/c_o5HIsQKVQmC6aiCtU8bg" target="_blank" rel="noopener">RabbitMQ 七战 Kafka</a><br><a href="https://mp.weixin.qq.com/s/G-DbD3F6gbJY_ubXyfg5DA" target="_blank" rel="noopener">发送邮件+SpringBoot+ RabbitMQ+定时任务复发</a></p>
<h2 id="RabiitMQ"><a href="#RabiitMQ" class="headerlink" title="RabiitMQ"></a>RabiitMQ</h2><p><img src="/rabbitMq/RabbitMq.png" alt="RabbitMq" title="RabbitMq"></p>
<ul>
<li>Exchange：生产者将消息发送到Exchange,由交换器将消息路由到一个或者多个队列中。如果路由不到,或许会返回给生产者,或许直接丢弃。</li>
<li>Binding：RabbitMQ中通过绑定将交换器与队列关联起来,在绑定Queuen的时候一般会指定一个绑定键(BindingKey),这个过程相当给Queue命名,这样RabbitMQ就知道如何正确地将消息路由到队列了。<br><img src="/rabbitMq/BindligKey.png" alt="BindligKey" title="BindligKey"></li>
<li>RoutingKey：生产者将消息发给交换器的时候,一般会指定一个RountingKey,用来指定这个消息的路由规则,而这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键(BindingKey)固定的情况下,生产者可以在发送消息给交换器时,通过指定RoutingKey来决定消息流向哪里。</li>
</ul>
<p>生产者将消息发送给交换器时,需要一个RoutingKey,当BindingKey和RoutingKey相匹配时,消息会被路由到对应的队列中。在绑定多个队列到同一个交换器时候,这些绑定允许使用相同的BindingKey。BindingKey并不是在所有的情况下都生效,它依赖于交换器类型,比如fanout类型的交换器就会无视BindingKey,而是将消息路由到所有绑定到该交换器的队列中。<br> 举例理解：交换器相当于投递包裹的邮箱,RoutingKey相当于填写在包裹上的地址,BindingKey相当于包裹的目的地,当填写在包裹上的地址和实际想要投递的地址相匹配时,那么这个包裹就会被正确投递到目的地。如果填写的地址出错,邮递员不能正确投递到目的地。包裹可能会会退给寄件人,也有可能被丢弃。</p>
<h3 id="交换器类型4种"><a href="#交换器类型4种" class="headerlink" title="交换器类型4种"></a>交换器类型4种</h3><p>RabbitMQ常用的交换器类型有fanout,direct,topic,headers这四种。</p>
<ul>
<li>fanout：它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li>
<li>direct：direct类型的交换器路由规则也很简单,它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。</li>
<li>topic：topic类型的交换器在匹配规则上进行了扩展,它与direct类型的交换器相似,也是将消息路由到BindingKey和RoutingKey相匹配的队列中,但匹配规则有些不同<br>  RoutingKey为一个点号“.”分隔的字符串(被点号“.”分隔开的每一段独立的字符串称为一个单词),如“com.rabbitmq.client”,“java.util.concurrent”,“com.hidden.client”；<br>  BindingKey和RoutingKey一样也是点号“.”分隔的字符串；<br>  BindingKey中可以存在两种特殊字符串“<em>”和“#”,用于做模糊匹配,符号“#”匹配路由键的一个或多个词,符号“</em>”匹配路由键的一个词</li>
<li>headers：headers类型的交换器不依赖于路由键的匹配规则来路由消息,而是根据发送的消息内容中的headers属性来进行匹配。(不实用,基本上不会看到它的存在)</li>
</ul>
<h3 id="RabbitMQ运转流程"><a href="#RabbitMQ运转流程" class="headerlink" title="RabbitMQ运转流程"></a>RabbitMQ运转流程</h3><ul>
<li><p>Productor在发送消息的时候：</p>
<ol>
<li>生产者连接到RabbitMQ Broker,建立一个连接(Connection),开启一个信道(Channel)。</li>
<li>生产者声明一个交换器,并设置相关属性,比如交换器类型,是否持久化等。</li>
<li>生产者声明一个队列并设置相关属性,比如是否排他是否持久化,是否自动删除等。</li>
<li>生产者通过路由键将交换器和队列绑定起来。</li>
<li>生产者发送消息至RabbitMQ Broker,其中包含路由键,交换器等信息。</li>
<li>相应的交换器根据接收到的路由键查找相匹配的队列。</li>
<li>如果找到,则将从生产者发送过来的消息存入相应的队列中。</li>
<li>如果没有找到,则根据生产者配置的属性选择丢弃还是回退给生产者。</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ol>
</li>
<li><p>Consumer接受消息的过程：</p>
<ol>
<li>消费者连接到RabbitMQ Broker,建立一个连接(Connection),开启一个信道(Channel)。</li>
<li>消费者向RabbitMQ Broker请求消费相应队列中的消息,可能会设置相应的回调函数,以及做一些准备工作。</li>
<li>等待RabbitMQ Broker回应并投递相应队列中的消息,消费者接受消息。</li>
<li>消费者确认(ack)接受到的消息。</li>
<li>RabbitMQ从队列中删除相应已经被确认的消息。</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ol>
</li>
</ul>
<h2 id="加入中间件三大缺陷"><a href="#加入中间件三大缺陷" class="headerlink" title="加入中间件三大缺陷"></a>加入中间件三大缺陷</h2><ol>
<li>系统高可用性:需要考虑MQ挂掉的风险</li>
<li>系统复杂度提高: <ul>
<li>消息丢失问题</li>
<li>消息有序性问题</li>
<li>消息重复消费问题</li>
</ul>
</li>
<li>数据一致性问题 </li>
</ol>
<h3 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h3><h4 id="如何确保消息不丢失"><a href="#如何确保消息不丢失" class="headerlink" title="如何确保消息不丢失"></a>如何确保消息不丢失</h4><p>保证消息不丢失 = 保证高可用(High Available)</p>
<ul>
<li>Productor存在丢失问题:保障消息的成功发出。</li>
<li>RabbitMQ存在丢失问题:保障MQ节点的成功接收。</li>
<li>Consumer存在丢失问题:发送端收到MQ节点(Broker)确认应答</li>
</ul>
<h5 id="Productor丢失问题"><a href="#Productor丢失问题" class="headerlink" title="Productor丢失问题"></a>Productor丢失问题</h5><p>解决方案:</p>
<ol>
<li>同步提交模式:A.channel.txselect 开启事务  B.channel commit提交  —-&gt;降低吞吐量,一般不用</li>
<li>异步提交模式(confirm模式): 生产者设置,MQ成功接受返回ack;若MQ没接受消息,可以重复发(限制重复次数),存在批量提交模式</li>
</ol>
<h5 id="MQ消息丢失问题"><a href="#MQ消息丢失问题" class="headerlink" title="MQ消息丢失问题"></a>MQ消息丢失问题</h5><p>解决方案:</p>
<ul>
<li>创建Queue时设置持久化,这样的持久化MQ元数据,不持久化消息</li>
<li>将消息deliveryMode 设置为2,将消息设置持久化,设置后持久化成功后,才有返回confirm中ack<h5 id="Consumer丢失问题"><a href="#Consumer丢失问题" class="headerlink" title="Consumer丢失问题"></a>Consumer丢失问题</h5></li>
<li>消费默认机制:消费者到数据,MQ会删除数据,以为消费成功</li>
<li>解决办法:关闭自动提交机制ack,在消费者消费完成后手动提交</li>
</ul>
<h3 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h3><p>幂等性是什么？简单来说就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的。<br>我们可以借鉴数据库的乐观锁机制来保障幂等性,或者函数f(n),只要n不变,执行的结果就一样</p>
<h4 id="什么情况下会出现重复消费？"><a href="#什么情况下会出现重复消费？" class="headerlink" title="什么情况下会出现重复消费？"></a>什么情况下会出现重复消费？</h4><p>当消费者消费完消息时,在给生产端返回ack时由于网络中断,导致生产端未收到确认信息,该条消息会重新发送并被消费者消费,但实际上该消费者已成功消费了该条消息,这就是重复消费问题。</p>
<h4 id="如何避免消息的重复消费问题？"><a href="#如何避免消息的重复消费问题？" class="headerlink" title="如何避免消息的重复消费问题？"></a>如何避免消息的重复消费问题？</h4><p>消费端实现幂等性,就意味着,我们的消息永远不会消费多次,即使我们收到了多条一样的消息<br>业界主流的幂等性操作：</p>
<ul>
<li>唯一ID + 指纹码机制,利用数据库主键去重</li>
<li>利用Redis的原子性去实现</li>
</ul>
<h5 id="唯一ID-指纹码机制"><a href="#唯一ID-指纹码机制" class="headerlink" title="唯一ID+指纹码机制"></a>唯一ID+指纹码机制</h5><ul>
<li>唯一ID + 指纹码机制,插入数据,利用数据库主键去重</li>
<li>好处：实现简单</li>
<li>坏处：高并发下有数据库写入的性能瓶颈</li>
<li>解决方案：跟进ID进行分库分表进行算法路由</li>
</ul>
<p>整个思路就是首先我们需要根据消息生成一个全局唯一的ID,然后还需要加上一个指纹码。这个指纹码它并不一定是系统去生成的,而是一些外部的规则或者内部的业务规则去拼接,它的目的就是为了保障这次操作是绝对唯一的。<br>对于高并发下的数据库性能瓶颈,可以跟进ID进行分库分表策略,采用一些路由算法去进行分压分流。应该保证ID通过这种算法,消息即使投递多次都落到同一个数据库分片上,这样就由单台数据库幂等变成多库的幂等。</p>
<h5 id="利用Redis的原子性去实现"><a href="#利用Redis的原子性去实现" class="headerlink" title="利用Redis的原子性去实现"></a>利用Redis的原子性去实现</h5><p>使用 redis 的原子性去实现主要需要考虑两个点</p>
<ul>
<li>第一：我们是否要进行数据落库,如果落库的话,关键解决的问题是数据库和缓存如何做到原子性？</li>
<li>第二：如果不进行落库,那么都存储到缓存中,如何设置定时同步的策略(同步到关系型数据库)？缓存又如何做到数据可靠性保障呢</li>
</ul>
<p>关于不落库,定时同步的策略,目前主流方案有两种,第一种为双缓存模式,异步写入到缓存中,也可以异步写到数据库,但是最终会有一个回调函数检查,这样能保障最终一致性,不能保证100%的实时性。第二种是定时同步,比如databus同步。</p>
<h3 id="消息顺序问题"><a href="#消息顺序问题" class="headerlink" title="消息顺序问题"></a>消息顺序问题</h3><p>尽量做到Queue对应一个consumer,保持不出现竞争消费,防止一个queue对多个cosumer</p>
<h3 id="消息落库补偿机制-互联网大厂的解决方案"><a href="#消息落库补偿机制-互联网大厂的解决方案" class="headerlink" title="消息落库补偿机制(互联网大厂的解决方案)"></a>消息落库补偿机制(互联网大厂的解决方案)</h3><h4 id="消息进行打标"><a href="#消息进行打标" class="headerlink" title="消息进行打标"></a>消息进行打标</h4><p><img src="/rabbitMq/%E5%AF%B9%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81%E8%BF%9B%E8%A1%8C%E8%BE%BE%E6%A0%87.png" alt="对消息状态进行达标" title="对消息状态进行达标"></p>
<ul>
<li>Step1：业务数据落库(BIZ DB)(如订单数据),消息落库(MSG DB init:status = 0)。</li>
<li>Step2：分布式定时任务查询待发送消息发送至MQ Broker。</li>
<li>Step3：MQ Broker confirm 机制回调Producer Listener。(如果步骤3出现断连,会出现重复投递问题,需要消费端自己去做幂等)</li>
<li>Step4：更新消息发送状态(success status = 1)。</li>
<li>Step5：分布式定时任务查询发送失败(未被confirm)的消息,query the status = 0。</li>
<li>Step6：重新发送发送失败的消息,count++。</li>
<li>Step7：重复发送次数达到指定次数(count &gt; 3次,set status =2),不进行再次投递,人工接入处理。</li>
</ul>
<p>优缺点:<br>step5可能比step4快,因此在step1需要防止重复存入数据(count &gt; 0),同时消费端要防止消息重复消费<br>将消息存入数据库,记录消息的状态。可以通过轮询不断获取消息的状态,从而保证消息的成功投递。如下图示所示,这样做有一个很严重的问题就是要多次操作数据库,对于一些高并发、对性能要求较高的业务,这种方式是不太合适的。因为频繁操作数据库会带来严重的性能问题。</p>
<h4 id="消息的延迟投递-做二次确认-回调检查"><a href="#消息的延迟投递-做二次确认-回调检查" class="headerlink" title="消息的延迟投递,做二次确认,回调检查"></a>消息的延迟投递,做二次确认,回调检查</h4><p><img src="/rabbitMq/%E7%94%9F%E4%BA%A7%E7%AB%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92.png" alt="生产端可靠性投递" title="生产端可靠性投递"></p>
<ul>
<li>Step1：业务上游业务数据落库成功后,发送一条消息M1。</li>
<li>Step2：一定时间延迟后(延迟时间根据业务需求而定)发送一条延迟消息M2用于追溯M1(可在M1发送得同时发送至延迟队列中)。</li>
<li>Step3：业务下游接收M1消息之后,完成下游业务逻辑。</li>
<li>Step4：发送消息M3至MQ Broker(新的得队列)。</li>
<li>Step5：CallBack端监听M3消息,落入消息库。</li>
<li>Step6：同时CallBack监听延时到达得M2消息,与MSG DB 中的M3比对。若对比结果M3不存在,则消息补偿(重新发送M1消息)。此时下游业务端可能会消费重复消息(M3消息发送失败),因此需要保证幂等性。</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点:"></a>优缺点:</h4><ul>
<li>优点:<br>这种方法可以有效的避免对数据库的频繁操作,从而提高性能；同时业务DB和消息DB之间解耦；改方案对比上述方案上游业务端减少一次数据库持久化,并发压力提高,补偿消息机制略差。</li>
<li>缺点:<br>生产端会发送两次消息：<ol>
<li>生产端首先会将业务数据存入DB,之后会向MQ发送一个消息,消费端收到消息后发送确认消息(这里的确认消息不是指ack,而是重新编辑发送一条新消息),回调服务监听到确认消息后将消息存入DB；</li>
<li>在第一条消息发送出去后一段时间,生产端会再发送一条check消息,回调服务监听到check消息后会检查第一条消息的执行情况,如果消息未能按照预期结果执行的话,回调服务会给生产端发送一条指令让生产端重新发送消息</li>
</ol>
</li>
</ul>
<h2 id="RabbitMQ高可用"><a href="#RabbitMQ高可用" class="headerlink" title="RabbitMQ高可用"></a>RabbitMQ高可用</h2><h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><p>即在多个服务器上部署多个MQ实例, 每台机器一个实例. 创建的每一个queue,只会存在一个MQ实例上. 但是每一个实例都会同步queue的元数据(即queue的标识信息). 当在进行消费的时候, 就算 连接到了其他的MQ实例上, 其也会根据内部的queue的元数据,从该queue所在实例上拉取数据过来.</p>
<p><img src="/rabbitMq/%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4.png" alt="普通集群" title="普通集群"></p>
<ul>
<li>当用户向服务注册一个队列，该队列会随机保存到某一个服务节点上，然后将对应的元数据同步到各个不同的服务节点上</li>
<li>RabbitMQ的普通集群模式中，每个RabbitMQ都保存有相同的元数据</li>
<li>用户只需要链接到任一一个服务节点中，就可以监听消费到对应队列上的消息数据</li>
<li>但是RabbitMQ的实际数据却不是保存在每个RabbitMQ的服务节点中，这就意味着用户可能联系的是RabbitMQ服务节点C，但是C上并没有对应的实际数据，也就是说RabbitMQ服务节点C，并不能提供消息供用户来消费，那么RabbitMQ的普通集群模式如何解决这个问题呢？</li>
<li>RabbitMQ服务节点C发现自己本服务节点并没有对应的实际数据后，因为每个服务节点上都会保存相同的元数据，所以服务节点C会根据元数据，向服务节点B（该服务节点上有实际数据可供消费）请求实际数据，然后提供给用户进行消费</li>
<li>这样给用户的感觉就是，在RabbitMQ的普通集群模式中，用户连接任一服务节点都可以消费到消息</li>
</ul>
<h4 id="普通集群模式优缺点"><a href="#普通集群模式优缺点" class="headerlink" title="普通集群模式优缺点"></a>普通集群模式优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>  普通集群模式的原理比较简单，提高消费的吞吐量,但是并不能真正意义上的实现高可用</p>
<h5 id="缺点-存在问题"><a href="#缺点-存在问题" class="headerlink" title="缺点(存在问题)"></a>缺点(存在问题)</h5><ul>
<li>服务在高并发情况下很容易出现性能瓶颈，进而影响整个系统的运行</li>
<li>为了请求RabbitMQ的实际数据以提供给用户，可能会在RabbitMQ内部服务节点之间进行频繁的进行数据交互，这样的交互比较耗费资源</li>
<li>当其中一个RabbitMQ的服务节点宕机了，那么该节点上的实际数据就会丢失，用户再次请求时，就会请求不到数据，系统的功能就会出现异常</li>
</ul>
<h3 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h3><p><img src="/rabbitMq/%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4.png" alt="镜像集群" title="镜像集群"></p>
<ul>
<li>生产者向任一服务节点注册队列，该队列相关信息会同步到其他节点上</li>
<li>任一消费者向任一节点请求消费，可以直接获取到消费的消息，因为每个节点上都有相同的实际数据</li>
<li>任一节点宕机，不影响消息在其他节点上进行消费</li>
</ul>
<h4 id="开启镜像模式"><a href="#开启镜像模式" class="headerlink" title="开启镜像模式"></a>开启镜像模式</h4><p>这里简单说下，在普通集群模式的基础上，我们可以通过web控制端来配置数据的同步策略，可以配置同步所有的节点，也可以配置同步到指定数量的服务节点</p>
<h4 id="镜像模式优缺点"><a href="#镜像模式优缺点" class="headerlink" title="镜像模式优缺点"></a>镜像模式优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>虽然镜像集群模式能够解决普通集群模式的缺点，当任一节点宕机了，不能正常提供服务了，也不影响该消息的正常消费，但是其本身也有相应的缺点：</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>性能开销大:因为要同步消息到对应的节点，这个会造成网络之间的数据量的频繁交互，对于网络带宽的消耗和压力都是比较重的,没有扩展可言，rabbitMQ是集群，不是分布式的，所以当某个Queue负载过重，我们并不能通过新增节点来缓解压力，因为所以节点上的数据都是相同的，这样就没办法进行线性扩展了</li>
<li>无法线性扩容:对于镜像集群而言，当某个queue负载过重，可能会导致集群雪崩，那么如何来减少集群雪崩呢？我们可以通过HA的同步策略来实现<h3 id="高可用-HA-的同步策略"><a href="#高可用-HA-的同步策略" class="headerlink" title="高可用(HA)的同步策略"></a>高可用(HA)的同步策略</h3>对于镜像集群而言，当某个queue负载过重，可能会导致集群雪崩，那么如何来减少集群雪崩呢？我们可以通过HA的同步策略来实现</li>
</ul>
<table>
<thead>
<tr>
<th>HA-mode</th>
<th>HA-params</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>空</td>
<td>镜像队列将会在整个集群中复制。当一个新的节点加入后，也会在这个节点上复制一份</td>
</tr>
<tr>
<td>exactly</td>
<td>count</td>
<td>镜像队列将会在集群上复制count份。如果集群数量少于count时候，队列会复制到所有节点上。<br>如果大于Count集群，有一个节点crash后，新进入节点也不会做新的镜像。（可以阻止集群雪崩）</td>
</tr>
<tr>
<td>nodes</td>
<td>node name</td>
<td>镜像队列会在node name中复制。如果这个名称不是集群中的一个，这不会触发错误。<br>如果在这个node list中没有一个节点在线，那么这个queue会被声明在client连接的节点。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列-RocketMQ</title>
    <url>/2020/09/12/Spring-%E6%B6%88%E6%81%AFRocketMQ/</url>
    <content><![CDATA[<p>进阶必看的 RocketMQ ，就这篇了<br><a href="https://mp.weixin.qq.com/s/Lb1Sm0G0BRofRJ51tpqT1Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Lb1Sm0G0BRofRJ51tpqT1Q</a></p>
]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>消息队列</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot配置文件路径及路径问题</title>
    <url>/2021/01/07/Spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot配置文件可以使用yml格式和properties格式<br>分别的默认命名为：application.yml. application.properties</p>
<h3 id="默认存放存放目录"><a href="#默认存放存放目录" class="headerlink" title="默认存放存放目录"></a>默认存放存放目录</h3><p>SpringBoot配置文件默认可以放到以下目录中，可以自动读取到：</p>
<ol>
<li>项目根目录下</li>
<li>项目根目录中config目录下</li>
<li>项目的resources目录下</li>
<li>项目resources目录中config目录下</li>
</ol>
<h3 id="默认读取顺序"><a href="#默认读取顺序" class="headerlink" title="默认读取顺序"></a>默认读取顺序</h3><p>如果在不同的目录中存在多个配置文件，它的读取顺序是：</p>
<ol>
<li>config/application.properties（项目根目录中config目录下）</li>
<li>config/application.yml</li>
<li>application.properties（项目根目录下）</li>
<li>application.yml</li>
<li>resources/config/application.properties（项目resources目录中config目录下）</li>
<li>resources/config/application.yml</li>
<li>resources/application.properties（项目的resources目录下）</li>
<li>resources/application.yml</li>
</ol>
<p>注：</p>
<ol>
<li>如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。</li>
<li>如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。</li>
<li>创建SpringBoot项目时，一般的配置文件放置在“项目的resources目录下”</li>
</ol>
<p>springboot启动会扫描一下位置的application.properties或者application.yml作为默认的配置文件<br>工程根目录:./config/<br>工程根目录：./<br>classpath:/config/<br>classpath:/</p>
<p>加载的优先级顺序是从上向下加载，并且所有的文件都会被加载，高优先级的内容会覆盖底优先级的内容，形成互补配置<br>也可以通过指定配置spring.config.location来改变默认配置，一般在项目已经打包后，我们可以通过指令<br>　　java -jar xxxx.jar –spring.config.location=D:/kawa/application.yml来加载外部的配置</p>
<h2 id="classpath具体指哪个路径"><a href="#classpath具体指哪个路径" class="headerlink" title="classpath具体指哪个路径"></a>classpath具体指哪个路径</h2><ol>
<li>src 路径下的文件 在编译后都会放到 WEB-INF/classes 路径下。默认classpath 就是指这里</li>
<li>用maven构建 项目时，resources 目录就是默认的classpath</li>
</ol>
<h3 id="classpath与classpath-的区别"><a href="#classpath与classpath-的区别" class="headerlink" title="classpath与classpath* 的区别"></a>classpath与classpath* 的区别</h3><h4 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h4><ol>
<li>classpath 是指web-inf 下classes目录</li>
<li>classes 是一个定位资源入口， 目录下用来存放：<ul>
<li>各种资源配置文件，eg.init.properties, log4j.properties, struts.xml</li>
<li>存放模板文件 eg.actionerror.ftl</li>
<li>编译后的class文件，对应的是项目开发时src目录编译文件</li>
</ul>
</li>
</ol>
<h4 id="classpath-1"><a href="#classpath-1" class="headerlink" title="classpath*"></a>classpath*</h4><p>仅包含class路径，还包括jar文件中(class路径)进行查找.<br>一般java项目中 classpath存在与 WEB-INFO/目录。 当我们需要某个class时，系统会自动在CLASSPATH里面搜索，如果是jar，就自动从jar里面查找，如果是普通的目录，则在目录下面按照package进行查找.但与PATH不同的是，默认的CLASSPATH是不包含当前目录的，这也是CLASSPATH里面要包含一个点的道理了。</p>
<h4 id="Tomcat的classpath"><a href="#Tomcat的classpath" class="headerlink" title="Tomcat的classpath"></a>Tomcat的classpath</h4><p>Tomcat下的Web应用有两个预置的classpath : WEB-INF/classes 和WEB-INF/lib启动项目，项目就会加载这两个目录里的数据。这是war包的规范.要改变预置的classpath比较麻烦，在Tomcat的配置文件里没有发现类似的配置，要实现自己的classloader才能达到目的。</p>
<p>一个在tomcat中运行的web应用.它的classpath都包括如下目录:<br>我知道的有: </p>
<ol>
<li>%tomcat%/lib </li>
<li>web-inf/lib </li>
<li>web-inf/classes </li>
<li>环境变量里的classpath<br>总结：classpath这是一个定位资源的入口.classpath下 lib的优先级大于classes</li>
</ol>
<h2 id="spring-boot默认加载文件的路径"><a href="#spring-boot默认加载文件的路径" class="headerlink" title="spring boot默认加载文件的路径"></a>spring boot默认加载文件的路径</h2><ul>
<li>/META-INF/resources/</li>
<li>/resources/</li>
<li>/static/</li>
<li>/public/</li>
</ul>
<p>从spring boot源码也可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123;  </span><br><span class="line">        &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, </span><br><span class="line">        &quot;classpath:&#x2F;resources&#x2F;&quot;,  </span><br><span class="line">        &quot;classpath:&#x2F;static&#x2F;&quot;, </span><br><span class="line">        &quot;classpath:&#x2F;public&#x2F;&quot; &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring&amp;SpringBoot全家桶技术框架</title>
    <url>/2021/01/10/SpringBoot-%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="Sping技术栈所包含的技术框架图"><a href="#Sping技术栈所包含的技术框架图" class="headerlink" title="Sping技术栈所包含的技术框架图"></a>Sping技术栈所包含的技术框架图</h2><p><img src="/springBoot/001.png" alt="001" title="001"></p>
<h2 id="Spring-Boot的一些知识点"><a href="#Spring-Boot的一些知识点" class="headerlink" title="Spring Boot的一些知识点"></a>Spring Boot的一些知识点</h2><p><img src="/springBoot/002.png" alt="002" title="002"></p>
<h2 id="Spring-Boot-推荐的基础-POM-文件"><a href="#Spring-Boot-推荐的基础-POM-文件" class="headerlink" title="Spring Boot 推荐的基础 POM 文件"></a>Spring Boot 推荐的基础 POM 文件</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>spring-boot-starter</td>
<td>核心 POM，包含自动配置支持、日志库和对 YAML 配置文件的支持</td>
</tr>
<tr>
<td>spring-boot-starter-amqp</td>
<td>通过 spring-rabbit 支持 AMQP。</td>
</tr>
<tr>
<td>spring-boot-starter-aop</td>
<td>包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。</td>
</tr>
<tr>
<td>spring-boot-starter-batch</td>
<td>支持 Spring Batch，包含 HSQLDB。</td>
</tr>
<tr>
<td>spring-boot-starter-data-jpa</td>
<td>包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。</td>
</tr>
<tr>
<td>spring-boot-starter-data-mongodb</td>
<td>包含 spring-data-mongodb 来支持 MongoDB。</td>
</tr>
<tr>
<td>spring-boot-starter-data-rest</td>
<td>通过 spring-data-rest-webmvc 支持以 REST 方式暴露 Spring Data 仓库。</td>
</tr>
<tr>
<td>spring-boot-starter-jdbc</td>
<td>支持使用 JDBC 访问数据库。</td>
</tr>
<tr>
<td>spring-boot-starter-security</td>
<td>包含 spring-security。</td>
</tr>
<tr>
<td>spring-boot-starter-test</td>
<td>包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。</td>
</tr>
<tr>
<td>spring-boot-starter-velocity</td>
<td>支持使用 Velocity 作为模板引擎。</td>
</tr>
<tr>
<td>spring-boot-starter-web</td>
<td>支持 Web 应用开发，包含 Tomcat 和 spring-mvc。</td>
</tr>
<tr>
<td>spring-boot-starter-websocket</td>
<td>支持使用 Tomcat 开发 WebSocket 应用。</td>
</tr>
<tr>
<td>spring-boot-starter-ws</td>
<td>支持 Spring Web Services。</td>
</tr>
<tr>
<td>spring-boot-starter-actuator</td>
<td>添加适用于生产环境的功能，如性能指标和监测等功能。</td>
</tr>
<tr>
<td>spring-boot-starter-remote-shell</td>
<td>添加远程 SSH 支持。</td>
</tr>
<tr>
<td>spring-boot-starter-jetty</td>
<td>使用 Jetty 而不是默认的 Tomcat 作为应用服务器。</td>
</tr>
<tr>
<td>spring-boot-starter-log4j</td>
<td>添加 Log4j 的支持。</td>
</tr>
<tr>
<td>spring-boot-starter-logging</td>
<td>使用 Spring Boot 默认的日志框架 Logback。</td>
</tr>
<tr>
<td>spring-boot-starter-tomcat</td>
<td>使用 Spring Boot 默认的 Tomcat 作为应用服务器。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>任务调度-Task</title>
    <url>/2020/09/12/SpringCloud-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>任务调度</tag>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统ID生产方案</title>
    <url>/2020/12/22/SpringCloud-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FID%E7%94%9F%E4%BA%A7%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/JtxOvPoIIpGHhaXbz_Ii9A" target="_blank" rel="noopener">一文搞定分布式系统 ID 生成方案</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁-Redis</title>
    <url>/2020/09/12/SpringCloud-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81Redis/</url>
    <content><![CDATA[<p><a href="https://www.processon.com/view/link/5f4c871d079129356ec6f4d7" target="_blank" rel="noopener">Redis分布式锁(ReentrantLock + RedissonRedLock)</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁-Zookeeper</title>
    <url>/2020/09/12/SpringCloud-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81Zookeeper/</url>
    <content><![CDATA[<p><a href="https://www.imooc.com/article/284956?block_id=tuijian_wz" target="_blank" rel="noopener">【七张图】彻底讲清楚ZooKeeper分布式锁的实现原理</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>文件-Stream</title>
    <url>/2020/09/12/SpringCloud-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86Stream/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Stream</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>日志管理-Kibana</title>
    <url>/2020/09/12/SpringCloud-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86Kibana/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>日志管理</tag>
        <tag>Kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>服务跟踪-Jaeger</title>
    <url>/2020/09/12/SpringCloud-%E6%9C%8D%E5%8A%A1%E8%B7%9F%E8%B8%AAJaeger/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>服务跟踪</tag>
        <tag>Jaeger</tag>
      </tags>
  </entry>
  <entry>
    <title>服务跟踪-Sleuth</title>
    <url>/2020/09/12/SpringCloud-%E6%9C%8D%E5%8A%A1%E8%B7%9F%E8%B8%AASleuth/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u013039300/article/details/79577356" target="_blank" rel="noopener">spring-cloud之服务跟踪篇</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>服务跟踪</tag>
        <tag>Sleuth</tag>
      </tags>
  </entry>
  <entry>
    <title>注册中心-Dubbo</title>
    <url>/2020/09/12/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Dubbo/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/rmxd/p/11531989.html" target="_blank" rel="noopener">SpringCloud与Dubbo对比</a><br><a href="https://www.cnblogs.com/iisme/p/10620125.html" target="_blank" rel="noopener">dubbo和zookeeper的关系</a></p>
<h2 id="Dubbo分布式服务框架特点"><a href="#Dubbo分布式服务框架特点" class="headerlink" title="Dubbo分布式服务框架特点"></a>Dubbo分布式服务框架特点</h2><ul>
<li>Dubbo缺省协议:采用基于单一长连接和netty框架Reactor模型NIO异步通信，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况<h3 id="Dubbo框架3大功能"><a href="#Dubbo框架3大功能" class="headerlink" title="Dubbo框架3大功能"></a>Dubbo框架3大功能</h3></li>
<li>Dubbo:是一个RPC框架,高性能和透明化的RPC远程服务调用方案,同时也是SOA框架,SOA服务治理方案<h4 id="作为RPC"><a href="#作为RPC" class="headerlink" title="作为RPC"></a>作为RPC</h4>支持各种传输协议,如dubbo,hession,json,fastjson,底层采用mina,netty长连接进行传输!典型的provider和cusomer模式<h4 id="作为SOA"><a href="#作为SOA" class="headerlink" title="作为SOA"></a>作为SOA</h4>具有服务治理功能,提供服务的注册和发现!用zookeeper实现注册中心!启动时候服务端会把所有接口注册到注册中心,并且订阅configurators,服务消费端订阅provide，configurators,routers,订阅变更时,zk会推送providers,configuators，routers,启动时注册长连接,进行通讯!proveider和provider启动后,后台启动定时器,发送统计数据到monitor(监控中心)提供各种容错机制和负载均衡策略</li>
</ul>
<p>注:</p>
<ul>
<li>netty:一个基于nio的客户、服务器端编程框架,netty提供异步的,事件驱动的网络应用程序框架和工具,可以快速开发高可用的客户端和服务器</li>
<li>长连接与短连接：长连接：client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于P2P通信。短连接：Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯</li>
</ul>
<h2 id="Dubbo架构图"><a href="#Dubbo架构图" class="headerlink" title="Dubbo架构图"></a>Dubbo架构图</h2><p><img src="/img/dubbo%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="dubbo基本原理图" title="dubbo基本原理图"><br>1.Consumer服务消费者，Provider服务提供者。Container服务容器。消费当然是invoke提供者了，invoke这条实线按照图上的说明当然同步的意思了，多说一句，在实际调用过程中，Provider的位置对于Consumer来说是透明的，上一次调用服务的位置(IP地址)和下一次调用服务的位置，是不确定的。这个地方就是实现了软负载<br>2.服务提供者先启动start，然后注册register服务<br>3.消费订阅subscribe服务，如果没有订阅到自己想获得的服务，它会不断的尝试订阅。新的服务注册到注册中心以后，注册中心会将这些服务通过notify到消费者<br>4.Monitor这是一个监控，图中虚线表明Consumer 和Provider通过异步的方式发送消息至Monitor，Consumer和Provider会将信息存放在本地磁盘，平均1min会发送一次信息。Monitor在整个架构中是可选的(图中的虚线并不是可选的意思)，Monitor功能需要单独配置，不配置或者配置以后，Monitor挂掉并不会影响服务的调用</p>
<h2 id="Dubbo远程调用架构"><a href="#Dubbo远程调用架构" class="headerlink" title="Dubbo远程调用架构"></a>Dubbo远程调用架构</h2><p>下面我们用一个精简的图来说明最重要的两种Invoker：服务提供Invoker和服务消费Invoker<br><img src="/img/dubbo%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%AE%80%E5%9B%BE.png" alt="dubbo远程调用简图" title="dubbo远程调用简图"></p>
<h3 id="Dubbo远程调用源代码基本原理-7步"><a href="#Dubbo远程调用源代码基本原理-7步" class="headerlink" title="Dubbo远程调用源代码基本原理(7步):"></a>Dubbo远程调用源代码基本原理(7步):</h3><p>1.client一个线程调用远程接口，生成一个唯一的ID（比如一段随机字符串，UUID等），Dubbo是使用AtomicLong从0开始累计数字的<br>2.将打包的方法调用信息（如调用的接口名称，方法名称，参数值列表等），和处理结果的回调对象callback，全部封装在一起，组成一个对象object<br>3.向专门存放调用信息的全局ConcurrentHashMap里面put(ID, object)<br>4.将ID和打包的方法调用信息封装成一对象connRequest，使用IoSession.write(connRequest)异步发送出去<br>5.当前线程再使用callback的get()方法试图获取远程返回的结果，在get()内部，则使用synchronized获取回调对象callback的锁， 再先检测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。<br>6.服务端接收到请求并处理后，将结果（此结果中包含了前面的ID，即回传）发送给客户端，客户端socket连接上专门监听消息的线程收到消息，分析结果，取到ID，再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里。<br>7.监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()，那个线程已释放callback的锁了），再notifyAll()，唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果了），至此，整个过程结束</p>
<h2 id="Dubbo原理细节"><a href="#Dubbo原理细节" class="headerlink" title="Dubbo原理细节"></a>Dubbo原理细节</h2><h3 id="初始化过程细节"><a href="#初始化过程细节" class="headerlink" title="初始化过程细节"></a>初始化过程细节</h3><p>上图中的第一步start，就是将服务装载容器中，然后准备注册服务。和Spring中启动过程类似，spring启动时，将bean装载进容器中的时候，首先要解析bean。所以dubbo也是先读配置文件解析服务。 </p>
<h3 id="解析服务"><a href="#解析服务" class="headerlink" title="解析服务"></a>解析服务</h3><ul>
<li>基于dubbo.jar内的Meta-inf/spring.handlers配置，spring在遇到dubbo名称空间时，会回调DubboNamespaceHandler类。 </li>
<li>所有的dubbo标签，都统一用DubboBeanDefinitionParser进行解析，基于一对一属性映射，将XML标签解析为Bean对象。<br>在ServiceConfig.export 或者ReferenceConfig.get 初始化时，将Bean对象转会为url格式，将所以Bean属性转成url的参数。<br>然后将URL传给Protocol扩展点，基于扩展点的Adaptive机制，根据URL的协议头，进行不同协议的服务暴露和引用。</li>
</ul>
<h4 id="只暴露服务端口"><a href="#只暴露服务端口" class="headerlink" title="只暴露服务端口"></a>只暴露服务端口</h4><p>在没有使用注册中心的情况，这种情况一般适用在开发环境下，服务的调用这和提供在同一个IP上，只需要打开服务的端口即可。<br>即，当配置 or ServiceConfig解析出的URL的格式为:Dubbo：//service-host/com.xxx.TxxService?version=1.0.0<br>基于扩展点的Adaptiver机制，通过URL的“dubbo：//”协议头识别，直接调用DubboProtocol的export（）方法，打开服务端口。</p>
<h4 id="向注册中心暴露服务："><a href="#向注册中心暴露服务：" class="headerlink" title="向注册中心暴露服务："></a>向注册中心暴露服务：</h4><p>和上一种的区别：需要将服务的IP和端口一同暴露给注册中心。<br>ServiceConfig解析出的url格式为:registry://registry-host/com.alibaba.dubbo.registry.RegistryService?export=URL.encode(“dubbo://service-host/com.xxx.TxxService?version=1.0.0”)<br>基于扩展点的Adaptive机制，通过URL的“registry://”协议头识别，调用RegistryProtocol的export方法，将export参数中的提供者URL先注册到注册中心，再重新传给Protocol扩展点进行暴露： Dubbo：//service-host/com.xxx.TxxService?version=1.0.0</p>
<h2 id="服务暴露和消费的详细过程"><a href="#服务暴露和消费的详细过程" class="headerlink" title="服务暴露和消费的详细过程"></a>服务暴露和消费的详细过程</h2><h3 id="服务提供者暴露一个服务的详细过程"><a href="#服务提供者暴露一个服务的详细过程" class="headerlink" title="服务提供者暴露一个服务的详细过程"></a>服务提供者暴露一个服务的详细过程</h3><p>服务提供者暴露服务的主过程：<br><img src="/img/dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%B8%BB%E8%BF%87%E7%A8%8B.png" alt="服务提供者暴露服务的主过程"><br>首先ServiceConfig类拿到对外提供服务的实际类ref(如：HelloWorldImpl),然后通过ProxyFactory类的getInvoker方法使用ref生成一个AbstractProxyInvoker实例,到这一步就完成具体服务到Invoker的转化。接下来就是Invoker转换到Exporter的过程。<br>Dubbo处理服务暴露的关键就在Invoker转换到Exporter的过程(如上图中的红色部分)，下面我们以Dubbo和RMI这两种典型协议的实现来进行说明：<br>Dubbo的实现：Dubbo协议的Invoker转为Exporter发生在DubboProtocol类的export方法，它主要是打开socket侦听服务，并接收客户端发来的各种请求，通讯细节由Dubbo自己实现。<br>RMI的实现：<br>RMI协议的Invoker转为Exporter发生在RmiProtocol类的export方法,它通过Spring或Dubbo或JDK来实现RMI服务，通讯细节这一块由JDK底层来实现，这就省了不少工作量。</p>
<h3 id="服务消费者消费一个服务的详细过程"><a href="#服务消费者消费一个服务的详细过程" class="headerlink" title="服务消费者消费一个服务的详细过程"></a>服务消费者消费一个服务的详细过程</h3><p>服务消费的主过程<br><img src="/img/dubbo%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E7%9A%84%E4%B8%BB%E8%BF%87%E7%A8%8B.png" alt="dubbo服务消费的主过程" title="dubbo服务消费的主过程"></p>
<p>首先ReferenceConfig类的init方法调用Protocol的refer方法生成Invoker实例(如上图中的红色部分)，这是服务消费的关键。<br>接下来把Invoker转换为客户端需要的接口(如：HelloWorld)。</p>
<h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>1.当前线程怎么让它“暂停”，等结果回来后，再向后执行?</p>
<p>答:首先生成一个对象obj，在一个全局map里put(ID,obj)存放起来，再用synchronized获取obj锁，再调用obj.wait()让当前线程处于等待状态，然后另一消息监听线程等到服 务端结果来了后，再map.get(ID)找到obj，再用synchronized获取obj锁，再调用obj.notifyAll()唤醒前面处于等待状态的线程。</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>2.正如前面所说，Socket通信是一个全双工的方式，如果有多个线程同时进行远程方法调用，这时建立在client server之间的socket连接上会有很多双方发送的消息传递，前后顺序也可能是乱七八糟的，server处理完结果后，将结果消息发送给client，client收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的?</p>
<p>答:使用一个ID，让其唯一，然后传递给服务端，再服务端又回传回来，这样就知道结果是原先哪个线程的了。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>注册中心</tag>
      </tags>
  </entry>
  <entry>
    <title>注册中心-Eureka基础知识</title>
    <url>/2020/09/12/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Eureka/</url>
    <content><![CDATA[<h2 id="Eurka工作原理流程"><a href="#Eurka工作原理流程" class="headerlink" title="Eurka工作原理流程"></a>Eurka工作原理流程</h2><p><img src="/img/Eureka%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Eureka原理图" title="Eureka原理图"><br>Eureka Server：提供服务注册和发现,多个Eureka Server之间会同步数据,做到状态一致（最终一致性）<br>Service Provider：服务提供方,将自身服务注册到Eureka,从而使服务消费方能够找到<br>Service Consumer：服务消费方,从Eureka获取注册服务列表,从而能够消费服务; Eureka Server 节点都宕掉,服务消费者依然可以使用缓存中的信息找到服务提供者,但是当服务有更改的时候会出现信息不一致。<br>　　本篇文章讲了 Eureka 核心概念、Eureka 自我保护机制和 Eureka 集群原理。通过分析 Eureka 工作原理,通过一些列的机制,完美地解决了注册中心的稳定性和高可用性。Eureka 为了保障注册中心的高可用性,容忍了数据的非强一致性,服务节点间的数据可能不一致, Client-Server 间的数据可能不一致。比较适合跨越多机房、对注册中心服务可用性要求较高的使用场景。</p>
<h2 id="Eureka比ZooKeeper比较"><a href="#Eureka比ZooKeeper比较" class="headerlink" title="Eureka比ZooKeeper比较"></a>Eureka比ZooKeeper比较</h2><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP定义:一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)<br>CAP原则又称CAP定理,指的是在一个分布式系统中,这三个要素最多只能同时实现两点,不可能三者兼顾。</p>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>Zookeeper保证CP 当向注册中心查询服务列表时,我们可以容忍注册中心返回的是几分钟以前的注册信息,但不能接受服务直接down掉不可用。也就是说,服务注册功能对可用性的要求要高于一致性。<font color='red'>但是zk会出现这样一种情况,当master节点因为网络故障与其他节点失去联系时,剩余节点会重新进行leader选举。问题在于,选举leader的时间太长,30 ~ 120s, 且选举期间整个zk集群都是不可用的,这就导致在选举期间注册服务瘫痪。(这就是失去可用性(Availability))</font>在云部署的环境下,因网络问题使得zk集群失去master节点是较大概率会发生的事,虽然服务能够最终恢复,但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p>
<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>Eureka保证AP Eureka看明白了这一点,因此在设计时就优先保证可用性。Eureka各个节点都是平等的,几个节点挂掉不会影响正常节点的工作,剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败,则会自动切换至其它节点,只要有一台Eureka还在,就能保证注册服务可用(保证可用性),只不过查到的信息可能不是最新的(不保证强一致性)。除此之外,Eureka还有一种自我保护机制,如果在15分钟内超过85%的节点都没有正常的心跳,那么Eureka就认为客户端与注册中心出现了网络故障,进入自我保护模式</p>
<h3 id="自我保护护模"><a href="#自我保护护模" class="headerlink" title="自我保护护模"></a>自我保护护模</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在默认配置中EurekaServer服务在一定时间（默认为90秒）没接受到某个服务的心跳连接后,EurekaServer会注销该服务。但是会存在当网络分区发生故障,导致该时间内没有心跳连接,但该服务本身还是健康运行的情况。Eureka通过“自我保护模式”来解决这个问题。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>EurekaServer在运行期间会去统计心跳,如果在15分钟内超过85%的节点都没有正常的心跳,会将这些实例保护起来,让这些实例不会过期,但是在保护期内如果服务刚好这个服务提供者非正常下线了,此时服务消费者就会拿到一个无效的服务实例,此时会调用失败,对于这个问题需要服务消费者端要有一些容错机制,如重试,断路器等。</p>
<ul>
<li>Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li>
<li>Eureka 仍然能够接受新服务的注册和查询请求,但是不会被同步到其它节点上(即保证当前节点依然可用)</li>
<li>当网络稳定时,当前实例新的注册信息会被同步到其它节点中</li>
</ul>
<h3 id="Eureka不足的地方："><a href="#Eureka不足的地方：" class="headerlink" title="Eureka不足的地方："></a>Eureka不足的地方：</h3><p>1.Eureka consumer本身有缓存,服务状态更新滞后,最常见的状况就是,服务下线了但是服务消费者还未及时感知,此时调用到已下线服务会导致请求失败,只能依靠consumer端的做容错机制来保证。如重试,断路器等</p>
<h2 id="Eureka集群原理"><a href="#Eureka集群原理" class="headerlink" title="Eureka集群原理"></a>Eureka集群原理</h2><p><img src="/img/Eureka%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86.png" alt="Eureka集群原理" title="Eureka集群原理"><br>　　看看Eureka集群的工作原理。我们假设有三台 Eureka Server 组成的集群,第一台 Eureka Server 在北京机房,另外两台 Eureka Server 在深圳和西安机房。这样三台 Eureka Server 就组建成了一个跨区域的高可用集群,只要三个地方的任意一个机房不出现问题,都不会影响整个架构的稳定性。<br>　　从图中可以看出 Eureka Server 集群相互之间通过 Replicate 来同步数据,相互之间不区分主节点和从节点,所有的节点都是平等的。在这种架构中,节点通过彼此互相注册来提高可用性,每个节点需要添加一个或多个有效的 serviceUrl 指向其他节点。如果某台 Eureka Server 宕机,Eureka Client 的请求会自动切换到新的 Eureka Server 节点。当宕机的服务器重新恢复后,Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时,所有的操作都会进行节点间复制,将请求复制到其它 Eureka Server 当前所知的所有节点中。<br>　　另外 Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接,就可以进行信息传播与同步。所以,如果存在多个节点,只需要将节点之间两两连接起来形成通路,那么其它注册中心都可以共享信息。每个 Eureka Server 同时也是 Eureka Client,多个 Eureka Server 之间通过 P2P 的方式完成服务注册表的同步。<br>　　Eureka Server 集群之间的状态是采用异步方式同步的,所以不保证节点间的状态一定是一致的,不过基本能保证最终状态是一致的。<br>　　注:在Eureka高可用架构中，Eureka Server也可以作为Client向其他server注册，多节点相互注册组成Eureka集群，集群间相互视为peer。Eureka Client向Server注册、续约、更新状态时，接受节点更新自己的服务注册信息后，逐个同步至其他peer节点。<br>　　Piont to Point(P2P):如果server-A向server-B节点单向注册，则server-A视server-B为peer节点，server-A接受的数据会同步给server-B，但server-B接受的数据不会同步给server-A。</p>
<h3 id="Eureka分区"><a href="#Eureka分区" class="headerlink" title="Eureka分区"></a>Eureka分区</h3><p>Eureka 提供了 Region 和 Zone 两个概念来进行分区,这两个概念均来自于亚马逊的 AWS:<br>region：可以理解为地理上的不同区域,比如亚洲地区,中国区或者深圳等等。没有具体大小的限制。根据项目具体的情况,可以自行合理划分 region。<br>zone：可以简单理解为 region 内的具体机房,比如说 region 划分为深圳,然后深圳有两个机房,就可以在此 region 之下划分出 zone1、zone2 两个 zone。<br>上图中的 us-east-1c、us-east-1d、us-east-1e 就代表了不同的 Zone。Zone 内的 Eureka Client 优先和 Zone 内的 Eureka Server 进行心跳同步,同样调用端优先在 Zone 内的 Eureka Server 获取服务列表,当 Zone 内的 Eureka Server 挂掉之后,才会从别的 Zone 中获取信息。</p>
<h3 id="Eureka保证AP"><a href="#Eureka保证AP" class="headerlink" title="Eureka保证AP"></a>Eureka保证AP</h3><p>　Eureka Server 各个节点都是平等的,几个节点挂掉不会影响正常节点的工作,剩余的节点依然可以提供注册和查询服务。而 Eureka Client 在向某个 Eureka 注册时,如果发现连接失败,则会自动切换至其它节点。只要有一台 Eureka Server 还在,就能保证注册服务可用(保证可用性),只不过查到的信息可能不是最新的(不保证强一致性)。</p>
<h2 id="Eureka缓存机制"><a href="#Eureka缓存机制" class="headerlink" title="Eureka缓存机制"></a><a href="https://www.cnblogs.com/yixinjishu/p/10871243.html" target="_blank" rel="noopener">Eureka缓存机制</a></h2><p><img src="/img/Eureka%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.png" alt="Eureka缓存机制" title="Eureka缓存机制"></p>
<h3 id="Eureka-Server缓存机制"><a href="#Eureka-Server缓存机制" class="headerlink" title="Eureka Server缓存机制"></a>Eureka Server缓存机制</h3><p>Eureka Server存在三个变量：(registry、readWriteCacheMap、readOnlyCacheMap)保存服务注册信息，默认情况下定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，每60s清理超过90s未续约的节点，Eureka Client每30s从readOnlyCacheMap更新服务注册信息，而UI则从registry更新服务注册信息</p>
<table>
<thead>
<tr>
<th>缓存</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>registry</td>
<td>ConcurrentHashMap</td>
<td>实时更新，类AbstractInstanceRegistry成员变量，UI端请求的是这里的服务注册信息</td>
</tr>
<tr>
<td>readWriteCacheMap</td>
<td>Guava Cache/LoadingCache</td>
<td>实时更新，类ResponseCacheImpl成员变量，缓存时间180秒</td>
</tr>
<tr>
<td>readOnlyCacheMap</td>
<td>ConcurrentHashMap</td>
<td>周期更新，类ResponseCacheImpl成员变量，默认每30s从readWriteCacheMap更新，Eureka client默认从这里更新服务注册信息，可配置直接从readWriteCacheMap更新</td>
</tr>
</tbody></table>
<h4 id="缓存相关配置"><a href="#缓存相关配置" class="headerlink" title="缓存相关配置"></a>缓存相关配置</h4><table>
<thead>
<tr>
<th>配置</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eureka.server.useReadOnlyResponseCache</td>
<td>true</td>
<td>Client从readOnlyCacheMap更新数据，false则跳过readOnlyCacheMap直接从readWriteCacheMap更新</td>
</tr>
<tr>
<td>eureka.server.responsecCacheUpdateIntervalMs</td>
<td>30000</td>
<td>readWriteCacheMap更新至readOnlyCacheMap周期，默认30s</td>
</tr>
<tr>
<td>eureka.server.evictionIntervalTimerInMs</td>
<td>60000</td>
<td>清理未续约节点(evict)周期，默认60s</td>
</tr>
<tr>
<td>eureka.instance.leaseExpirationDurationInSeconds</td>
<td>90</td>
<td>清理未续约节点超时时间，默认90s</td>
</tr>
</tbody></table>
<h4 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h4><table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>com.netflix.eureka.registry.AbstractInstanceRegistry</td>
<td>保存服务注册信息，持有registry和responseCache成员变量</td>
</tr>
<tr>
<td>com.netflix.eureka.registry.ResponseCacheImpl</td>
<td>持有readWriteCacheMap和readOnlyCacheMap成员变量</td>
</tr>
</tbody></table>
<h3 id="Eureka-Client缓存机制"><a href="#Eureka-Client缓存机制" class="headerlink" title="Eureka Client缓存机制"></a>Eureka Client缓存机制</h3><p>Eureka Client存在两种角色：服务提供者和服务消费者，作为服务消费者一般配合Ribbon或Feign（Feign内部使用Ribbon）使用。Eureka Client启动后，作为服务提供者立即向Server注册，默认情况下每30s续约(renew)；作为服务消费者立即向Server全量更新服务注册信息，默认情况下每30s增量更新服务注册信息；Ribbon延时1s向Client获取使用的服务注册信息，默认每30s更新使用的服务注册信息，只保存状态为UP的服务。</p>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><table>
<thead>
<tr>
<th>缓存</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>localRegionApps</td>
<td>AtomicReference</td>
<td>周期更新，类DiscoveryClient成员变量，Eureka Client保存服务注册信息，启动后立即向Server全量更新，默认每30s增量更新</td>
</tr>
<tr>
<td>upServerListZoneMap</td>
<td>ConcurrentHashMap</td>
<td>周期更新，类LoadBalancerStats成员变量，Ribbon保存使用且状态为UP的服务注册信息，启动后延时1s向Client更新，默认每30s更新</td>
</tr>
</tbody></table>
<h4 id="缓存相关配置-1"><a href="#缓存相关配置-1" class="headerlink" title="缓存相关配置"></a>缓存相关配置</h4><table>
<thead>
<tr>
<th>配置</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eureka.instance.leaseRenewalIntervalInSeconds</td>
<td>30</td>
<td>Eureka Client 续约周期，默认30s</td>
</tr>
<tr>
<td>eureka.client.registryFetchIntervalSeconds</td>
<td>30</td>
<td>Eureka Client 增量更新周期，默认30s(正常情况下增量更新，超时或与Server端不一致等情况则全量更新)</td>
</tr>
<tr>
<td>ribbon.ServerListRefreshInterval</td>
<td>30000</td>
<td>Ribbon 更新周期，默认30s</td>
</tr>
</tbody></table>
<h4 id="关键类-1"><a href="#关键类-1" class="headerlink" title="关键类"></a>关键类</h4><table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>com.netflix.discovery.DiscoveryClient</td>
<td>Eureka Client 负责注册、续约和更新，方法initScheduledTasks()分别初始化续约和更新定时任务</td>
</tr>
<tr>
<td>com.netflix.loadbalancer.PollingServerListUpdater</td>
<td>Ribbon 更新使用的服务注册信息，start初始化更新定时任务</td>
</tr>
<tr>
<td>com.netflix.loadbalancer.LoadBalancerStats</td>
<td>Ribbon，保存使用且状态为UP的服务注册信息</td>
</tr>
</tbody></table>
<h4 id="默认配置下服务消费者-Eureka-Client-最长感知时间"><a href="#默认配置下服务消费者-Eureka-Client-最长感知时间" class="headerlink" title="默认配置下服务消费者(Eureka Client)最长感知时间"></a>默认配置下服务消费者(Eureka Client)最长感知时间</h4><p><img src="/img/Eureka%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4.png" alt="Eureka缓存时间" title="Eureka缓存时间"><br><img src="/img/Eureka%E6%9C%80%E5%A4%A7%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4.png" alt="Eureka最大缓存时间" title="Eureka最大缓存时间"><br>考虑如下情况<br>0s时服务未通知Eureka Client直接下线；<br>29s时第一次过期检查evict未超过90s；<br>89s时第二次过期检查evict未超过90s；<br>149s时第三次过期检查evict未续约时间超过了90s，故将该服务实例从registry和readWriteCacheMap中删除；<br>179s时定时任务从readWriteCacheMap更新至readOnlyCacheMap;<br>209s时Eureka Client从Eureka Server的readOnlyCacheMap更新；<br>239s时Ribbon从Eureka Client更新。<br>因此，极限情况下服务消费者最长感知时间将无限趋近240s。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>注册中心</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>注册中心-ZooKeeper</title>
    <url>/2020/09/12/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83ZooKeeper/</url>
    <content><![CDATA[<h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p><a href="https://www.douban.com/note/208430424/" target="_blank" rel="noopener">Zookeeper全解析——Paxos作为灵魂</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>注册中心</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2022/06/03/SpringCloud-%E6%B5%B7%E9%87%8F%E6%90%9C%E7%B4%A2ElasticSearch/</url>
    <content><![CDATA[<ol>
<li>ES 安装 设置配置</li>
<li></li>
<li>集群 及配置</li>
</ol>
<h1 id="ES-ik中文分词器的安装"><a href="#ES-ik中文分词器的安装" class="headerlink" title="ES ik中文分词器的安装"></a>ES ik中文分词器的安装</h1><h1 id="es-head-x-pack-安装"><a href="#es-head-x-pack-安装" class="headerlink" title="es head x-pack 安装"></a>es head x-pack 安装</h1><h1 id="kibana安装"><a href="#kibana安装" class="headerlink" title="kibana安装"></a>kibana安装</h1><h1 id="logstash同步"><a href="#logstash同步" class="headerlink" title="logstash同步"></a>logstash同步</h1>]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ActiveMQ</title>
    <url>/2020/12/13/SpringCloud-%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BFActiveMQ/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>PluginTool</category>
      </categories>
      <tags>
        <tag>Plugin</tag>
        <tag>消息中间件</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>消息总线Bus</title>
    <url>/2020/12/23/SpringCloud-%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BFBus/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/bdddca222c63" target="_blank" rel="noopener">微服务之消息总线</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>消息总线</tag>
      </tags>
  </entry>
  <entry>
    <title>熔断器-Hystrix</title>
    <url>/2020/09/12/SpringCloud-%E7%86%94%E6%96%AD%E5%99%A8Hytrix/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>熔断器</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>管理-Admin</title>
    <url>/2020/09/12/SpringCloud-%E7%AE%A1%E7%90%86Admin/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>管理</tag>
        <tag>Admin</tag>
      </tags>
  </entry>
  <entry>
    <title>网关-GetWay</title>
    <url>/2020/09/12/SpringCloud-%E7%BD%91%E5%85%B3GetWay/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>GetWay</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title>网关-Zuul</title>
    <url>/2020/09/12/SpringCloud-%E7%BD%91%E5%85%B3Zuul/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/977b291e1247" target="_blank" rel="noopener">微服务之服务网关</a></p>
<p><a href="https://blog.csdn.net/u010681191/article/details/99656413" target="_blank" rel="noopener">微服务网关Zuul和Gateway的区别</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>网关</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC-Feign</title>
    <url>/2020/09/12/SpringCloud-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AERPC/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/b0343bfd216e" target="_blank" rel="noopener">RPC简介及框架选择</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>配置中心-Apollo</title>
    <url>/2020/09/12/SpringCloud-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Apollo/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Apollo</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus搭建</title>
    <url>/2021/06/27/java-Mybatis-plus%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>Mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>java的内部类和静态内部类(嵌套类)</title>
    <url>/2021/05/08/java-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>可以将一个类的定义放在另一个类的定义内部,这就是内部类；</li>
<li>嵌套类(内部类)是其封闭类(外部类)的成员。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>非静态内部类里不能拥有静态变量或方法,因为内部类只是外部类的一个成员;<font color='red'>从某种意义上来说不是一个完整的类</font></li>
<li>不能使用new获取内部类对象,只能通过实例化外部类后再实例化内部类：new outerClass().new innerClass()</li>
<li>由于内部类是外部类的成员，因此可以使用外部类的private等成员属性</li>
</ol>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul>
<li>再一个普通类里面，给内部类加上static关键字的修饰；</li>
<li>与类方法和变量一样，静态嵌套类与其外部类相关联。与静态类方法一样，静态嵌套类不能直接引用其封闭类(外部类)中定义的实例变量或方法：它只能通过对象引用来使用它们。（就和两个普通不同的类之间的使用）非静态嵌套类(内部类)可以访问封闭类(外部类)的其他成员，即使非静态嵌套类(内部类)???被声明为私有的也是如此。静态嵌套类无权访问封闭类的其他成员(包括静态？？)为一体的一个部件OuterClass，</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>静态内部类里能拥有静态变量或方法;<font color='red'>从某种意义上来说是一个完整独立的类</font></li>
<li>可以直接使用new获取内部对象,或者直接使用内部类获取静态变量:innerClass.xxx</li>
<li>由于内部类是外部类的成员，因此可以使用外部类的private等成员属性</li>
</ol>
<h2 id="内部类3种作用"><a href="#内部类3种作用" class="headerlink" title="内部类3种作用"></a>内部类3种作用</h2><ul>
<li>这是一种对仅在一个地方使用的类进行逻辑分组的方法：如果一个类仅对另一个类有用，那么将其嵌入该类并将两者保持在一起是合乎逻辑的。嵌套此类“帮助程序类”可使它们的程序包更加简化。 </li>
<li>它增加了封装：考虑两个顶级类A和B，其中B需要访问A的成员，否则将对其进行声明private。通过将类B隐藏在类A中，可以将A的成员声明为私有，而B可以访问它们。另外，B本身可以对外界隐藏。 </li>
<li>这可能会导致代码更具可读性和可维护性：在顶级类中嵌套小类会使代码更靠近使用位置。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>序列化强烈建议不要对内部类（包括 本地和 匿名类）进行序列化。当Java编译器编译某些构造（例如内部类）时，它会创建综合构造。 </li>
<li>这些是类，方法，字段以及其他在源代码中没有相应构造的构造。合成构造使Java编译器无需更改JVM就可以实现新的Java语言功能。但是，合成构造在不同的Java编译器实现中可能有所不同，这意味着.class文件在不同的实现中也可能有所不同。因此，如果序列化一个内部类，然后使用其他JRE实现对其进行反序列化，则可能会遇到兼容性问题。 </li>
</ul>
<h2 id="内部类和静态修饰符static"><a href="#内部类和静态修饰符static" class="headerlink" title="内部类和静态修饰符static"></a>内部类和静态修饰符static</h2><p>1）首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。<br>2）静态都是用来修饰类的内部成员的。比如静态方法，静态成员变量，静态常量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
      </tags>
  </entry>
  <entry>
    <title>日志架构演进</title>
    <url>/2021/06/20/java-%E6%97%A5%E5%BF%97%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><plugin>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
<!--                    <descriptor>src/main/assembly/assembly.xml</descriptor>-->
                    <appendAssemblyId>false</appendAssemblyId>
                </configuration>
                <executions>
                    <execution>
                        <id>make-assembly</id>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.0.0-M1</version>
                <configuration>
                    <skipTests>true</skipTests>
                </configuration>
            </plugin>]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>配置中心-Config</title>
    <url>/2020/09/12/SpringCloud-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83config/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/0f84f2c66cf5" target="_blank" rel="noopener">微服务之配置中心</a><br><a href="https://blog.csdn.net/u010681191/article/details/99656413" target="_blank" rel="noopener">微服务网关Zuul和Gateway的区别</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>配置中心</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j2日志使用</title>
    <url>/2022/03/09/java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6-Log4j2/</url>
    <content><![CDATA[<h2 id="Log4j2简介"><a href="#Log4j2简介" class="headerlink" title="Log4j2简介"></a>Log4j2简介</h2><p>Apache Log4j 2是 Log4j(1) 的升级版，比它的祖先 Log4j 1. x 有了很大的改进，和logback对比有很大的改进。除了内部设计的调整外，主要有以下几点的大升级：</p>
<ul>
<li>更简化的配置</li>
<li>更强大的参数格式化</li>
<li>最夸张的异步性能</li>
</ul>
<p>Log4j 2中，分为API(log4j-api） 和实现(log4j-core) 两个模块。API 和slf4j 是一个类型，属于日志抽象/门面，而实现部分，才是Log4j 2的核心。</p>
<ol>
<li>org.apache.logging.log4j » log4j-api</li>
<li>org.apache.logging.log4j » log4j-core</li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="异步性能"><a href="#异步性能" class="headerlink" title="异步性能"></a>异步性能</h3><p><img src="/springBoot/005.png" alt="性能对比" title="性能对比"><br>从图上可以看出，log4j2的异步（全异步，非混合模式）下的性能，远超log4j1和logback，简直吊打。压力越大的情况下，吞吐上的差距就越大。在64线程测试下，log4j2的吞吐达到了180w+/s，而logback/log4j1只有不到20w，相差近十倍</p>
<h3 id="零GC（Garbage-free）"><a href="#零GC（Garbage-free）" class="headerlink" title="零GC（Garbage-free）"></a>零GC（Garbage-free）</h3><p>从2.6版本开始（2016年），log4j2 默认就以零GC模式运行了。什么叫零GC呢？就是不会由于log4j2而导致GC。<br>log4j2 中各种Message对象，字符串数组，字节数组等全部复用 ，不重复创建，大大减少了无用对象的创建，从而做到“零GC”。</p>
<h3 id="更高性能-I-O-写入的支持"><a href="#更高性能-I-O-写入的支持" class="headerlink" title="更高性能 I/O 写入的支持"></a>更高性能 I/O 写入的支持</h3><p>log4j 还提供了一个MemoryMappedFileAppender，I/O 部分使用MemoryMappedFile来实现，可以得到极高的I/O性能。不过在使用MemoryMappedFileAppender之前，得确定你足够了解MemoryMappedFile的相关知识，否则不要轻易使用呦。</p>
<h3 id="使用-占位符格式化参数"><a href="#使用-占位符格式化参数" class="headerlink" title="使用{}占位符格式化参数"></a>使用{}占位符格式化参数</h3><p>在slf4j里，我们可以用{}的方式来实现“format”的功能（参数会直接toString替换占位符），<br>logger.debug(“Logging in user {} with birthday {}”, user.getName(), user.getBirthdayCalendar());</p>
<h3 id="使用String-format的形式格式化参数"><a href="#使用String-format的形式格式化参数" class="headerlink" title="使用String.format的形式格式化参数"></a>使用String.format的形式格式化参数</h3><p>public static Logger logger = LogManager.getFormatterLogger(“Foo”);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.debug(&quot;Logging in user %s with birthday %s&quot;, user.getName(), user.getBirthdayCalendar());</span><br><span class="line">logger.debug(&quot;Logging in user %1$s with birthday %2$tm %2$te,%2$tY&quot;, user.getName(), user.getBirthdayCalendar());</span><br><span class="line">logger.debug(&quot;Integer.MAX_VALUE &#x3D; %,d&quot;, Integer.MAX_VALUE);</span><br><span class="line">logger.debug(&quot;Long.MAX_VALUE &#x3D; %,d&quot;, Long.MAX_VALUE);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，如果想使用String.format的形式，需要使用LogManager.getFormatterLogger而不是LogManager.getLogger</li>
</ul>
<h3 id="使用logger-printf格式化参数"><a href="#使用logger-printf格式化参数" class="headerlink" title="使用logger.printf格式化参数"></a>使用logger.printf格式化参数</h3><p>log4j2 的 Logger接口中，还有一个printf方法，无需创建LogManager.getFormatterLogger，就可以使用String.format的形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.printf(Level.INFO, &quot;Logging in user %1$s with birthday %2$tm %2$te,%2$tY&quot;, user.getName(), user.getBirthdayCalendar());</span><br><span class="line"></span><br><span class="line">logger.debug(&quot;Opening connection to &#123;&#125;...&quot;, someDataSource);</span><br></pre></td></tr></table></figure>

<h3 id="“惰性”打日志（lazy-logging）"><a href="#“惰性”打日志（lazy-logging）" class="headerlink" title="“惰性”打日志（lazy logging）"></a>“惰性”打日志（lazy logging）</h3><p>log4j2 的 logger 对象，提供了一系列lambda的支持，通过这些接口可以实现“惰性”打日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void debug(String message, Supplier&lt;?&gt;... paramSuppliers);</span><br><span class="line">void info(String message, Supplier&lt;?&gt;... paramSuppliers);</span><br><span class="line">void trace(String message, Supplier&lt;?&gt;... paramSuppliers);</span><br><span class="line">void error(String message, Supplier&lt;?&gt;... paramSuppliers);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等同于下面的先判断，后打印</span><br><span class="line">logger.debug(&quot;入参报文：&#123;&#125;&quot;,() -&gt; JSON.toJSONString(policyDTO));</span><br><span class="line"></span><br><span class="line">if(logger.isDebugEnabled())&#123;</span><br><span class="line">    logger.debug(&quot;入参报文：&#123;&#125;&quot;,JSON.toJSONString(policyDTO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用log4j2的maven依赖"><a href="#引用log4j2的maven依赖" class="headerlink" title="引用log4j2的maven依赖"></a>引用log4j2的maven依赖</h2><p><font color =red>springboot默认是用logback的日志框架的，所以需要排除logback，不然会出现jar依赖冲突的报错。</font><br>日志框架：slf4j<br>日志实现：log4j2<br>桥接包：log4j-slf4j-impl</p>
<p>桥接包log4j-slf4j-impl起到适配的作用，因为市面上的日志实现互不兼容，日志框架slf4j要想适用于日志实现log4j2，就需要使用桥接包。slf4j使用LoggerFactory创建Logger进行日志打印，底层实际上调用了log4j-slf4j-impl的StaticLoggerBinder类创建一个Log4jLoggerFactory，然后再由这个Log4jLoggerFactory创建一个Log4j2的Logger对象，这个Logger封装在log4j-slf4j-impl中的Log4jLogger里面，最后将Log4jLogger返回给slf4j，每次slf4j进行日志打印，实际上是log4j-slf4j-impl中的Log4jLogger调用log4j2进行日志打印<br>如果没有 log4j-slf4j-impl桥接包，slf4j将创建一个对象，里面都是空方法，所以不会打印出日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;!-- 排除掉logging，不使用logback，改用log4j2 --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 日志实现 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.14.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 日志框架(门面) --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.14.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 日志桥接包   桥接包的版本须对应log4j2的版本 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-slf4j-impl&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>SpringBoot中引用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;!-- 排除掉logging，不使用logback，改用log4j2 --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-log4j2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
log4j-api在log4j-core中已经有依赖了，直接依赖core即可</li>
<li>注意，引用log4j2时，需要注意项目中是否有多套日志框架共存/冲突，需要适配的问题。细节请参考上面的与其他日志抽象/门面适配</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span><br><span class="line">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span><br><span class="line">&lt;configuration monitorInterval&#x3D;&quot;5&quot;&gt;</span><br><span class="line">    &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--变量配置--&gt;</span><br><span class="line">    &lt;Properties&gt;</span><br><span class="line">        &lt;!-- 控制台默认输出格式,&quot;%d&quot;:表示打印的时间 &quot;%5level&quot;:日志级别, %thread 表示打印日志的线程 &quot;%c&quot;:表示类 &quot;%L&quot;:表示行号 &quot;%msg&quot; 表示打印的信息  %n 换行  %throwable 表示错误信息</span><br><span class="line">        %style 和&#123;bright,green&#125; 结合表示展示颜色   %highlight 所以影响日志输出的性能 --&gt;</span><br><span class="line">        &lt;Property name&#x3D;&quot;LOG_PATTERN&quot;&gt;</span><br><span class="line">            [%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] | [%5level][%thread][%X&#123;traceId&#125;] -| %msg%n</span><br><span class="line">        &lt;&#x2F;Property&gt;</span><br><span class="line">        &lt;!-- 定义日志存储的路径，不要配置相对路径 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;FILE_PATH&quot; value&#x3D;&quot;&#x2F;logs&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!--加项目名称做前缀--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;FILE_NAME_PREFIX&quot; value&#x3D;&quot;temp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!--日志大小 MB or GB--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;LOG_SIZE&quot; value&#x3D;&quot;20MB&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;Properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;console name&#x3D;&quot;Console&quot; target&#x3D;&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;!--输出日志的格式2 pattern&#x3D;&quot;%highlight&#123;%d&#123;HH:mm:ss.SSS&#125; [%t]  %-5level %logger&#123;1.&#125;:%L - %msg%n&#125;&#123;%throwable&#123;short.fileName&#125;&#125;&#123;FATAL&#x3D;white,ERROR&#x3D;red,WARN&#x3D;blue, INFO&#x3D;black, DEBUG&#x3D;green, TRACE&#x3D;blue&#125;&quot;--&gt;</span><br><span class="line">            &lt;PatternLayout</span><br><span class="line">                    pattern&#x3D;&quot;[%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;&#125;&#123;bright,green&#125;] | [%highlight&#123;%5level&#125;][%thread][%style&#123;%c&#125;&#123;bright,yellow&#125;] [%style&#123;%L&#125;&#123;bright,blue&#125;] -| %msg%n%style&#123;%throwable&#125;&#123;red&#125;&quot;</span><br><span class="line">                    disableAnsi&#x3D;&quot;false&quot; noConsoleNoAnsi&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">            &lt;!--控制台只输出level及其以上级别的信息(onMatch),其他的直接拒绝(onMismatch)--&gt;</span><br><span class="line">            &lt;ThresholdFilter level&#x3D;&quot;info&quot; onMatch&#x3D;&quot;ACCEPT&quot; onMismatch&#x3D;&quot;DENY&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;console&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span><br><span class="line">        &lt;!--append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true --&gt;</span><br><span class="line">        &lt;File name&#x3D;&quot;Filelog&quot; fileName&#x3D;&quot;$&#123;FILE_PATH&#125;&#x2F;test.log&quot; append&#x3D;&quot;false&quot; &gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;$&#123;LOG_PATTERN&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;File&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;RollingFileInfo&quot; fileName&#x3D;&quot;$&#123;FILE_PATH&#125;&#x2F;$&#123;FILE_NAME_PREFIX&#125;_info.log&quot; filePattern&#x3D;&quot;$&#123;FILE_PATH&#125;&#x2F;$&#123;FILE_NAME_PREFIX&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt;</span><br><span class="line">            &lt;!--控制台只输出level及以上级别的信息(onMatch),其他的直接拒绝(onMismatch),由上面级别排序可以找到,info包括warn，error--&gt;</span><br><span class="line">            &lt;ThresholdFilter level&#x3D;&quot;info&quot; onMatch&#x3D;&quot;ACCEPT&quot; onMismatch&#x3D;&quot;DENY&quot;&#x2F;&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;$&#123;LOG_PATTERN&#125;&quot;&#x2F;&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;!--interval属性用来指定多久滚动一次，默认是1天--&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size&#x3D;&quot;100MB&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖保持最久那个--&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy max&#x3D;&quot;15&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;RollingFileWarn&quot; fileName&#x3D;&quot;$&#123;FILE_PATH&#125;&#x2F;$&#123;FILE_NAME_PREFIX&#125;_warn.log&quot; filePattern&#x3D;&quot;$&#123;FILE_PATH&#125;&#x2F;$&#123;FILE_NAME_PREFIX&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt;</span><br><span class="line">            &lt;!--控制台只输出level及以上级别的信息(onMatch),其他的直接拒绝(onMismatch)--&gt;</span><br><span class="line">            &lt;ThresholdFilter level&#x3D;&quot;warn&quot; onMatch&#x3D;&quot;ACCEPT&quot; onMismatch&#x3D;&quot;DENY&quot;&#x2F;&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;$&#123;LOG_PATTERN&#125;&quot;&#x2F;&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;!--interval属性用来指定多久滚动一次，默认是1天--&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size&#x3D;&quot;100M&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖保持最久那个--&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy max&#x3D;&quot;15&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;RollingFileError&quot; fileName&#x3D;&quot;$&#123;FILE_PATH&#125;&#x2F;$&#123;FILE_NAME_PREFIX&#125;_error.log&quot; filePattern&#x3D;&quot;$&#123;FILE_PATH&#125;&#x2F;$&#123;FILE_NAME_PREFIX&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt;</span><br><span class="line">            &lt;!--控制台只输出level及以上级别的信息(onMatch),其他的直接拒绝(onMismatch)--&gt;</span><br><span class="line">            &lt;ThresholdFilter level&#x3D;&quot;error&quot; onMatch&#x3D;&quot;ACCEPT&quot; onMismatch&#x3D;&quot;DENY&quot;&#x2F;&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;$&#123;LOG_PATTERN&#125;&quot;&#x2F;&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;!--interval属性用来指定多久滚动一次，默认是1天--&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size&#x3D;&quot;100M&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖保持最久那个--&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy max&#x3D;&quot;15&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;appenders&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;</span><br><span class="line">    &lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;</span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line">        &lt;!--若是additivity设为false，则子Logger只会在自己定义的appender里输出，而不会在 root Logger 的appender里输出。--&gt;</span><br><span class="line">        &lt;!--过滤掉mybatis的一些无用的DEBUG信息--&gt;</span><br><span class="line">        &lt;logger name&#x3D;&quot;org.mybatis&quot; level&#x3D;&quot;info&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            &lt;AppenderRef ref&#x3D;&quot;Console&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;logger&gt;</span><br><span class="line">        &lt;!--过滤掉spring的一些无用的DEBUG信息--&gt;</span><br><span class="line">        &lt;Logger name&#x3D;&quot;org.springframework&quot; level&#x3D;&quot;info&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            &lt;AppenderRef ref&#x3D;&quot;Console&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Logger&gt;</span><br><span class="line"></span><br><span class="line">        &lt;root level&#x3D;&quot;info&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;Console&quot;&#x2F;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;Filelog&quot;&#x2F;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;RollingFileInfo&quot;&#x2F;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;RollingFileWarn&quot;&#x2F;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;RollingFileError&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;root&gt;</span><br><span class="line">    &lt;&#x2F;loggers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="XML配置文件语法"><a href="#XML配置文件语法" class="headerlink" title="XML配置文件语法"></a>XML配置文件语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;;</span><br><span class="line">&lt;Configuration&gt;</span><br><span class="line">  &lt;Properties&gt;</span><br><span class="line">    &lt;Property name&#x3D;&quot;name1&quot;&gt;value&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;Property name&#x3D;&quot;name2&quot; value&#x3D;&quot;value2&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Properties&gt;</span><br><span class="line">  &lt;filter  ... &#x2F;&gt;</span><br><span class="line">  &lt;Appenders&gt;</span><br><span class="line">    &lt;appender ... &gt;</span><br><span class="line">      &lt;filter  ... &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;Appenders&gt;</span><br><span class="line">  &lt;Loggers&gt;</span><br><span class="line">    &lt;Logger name&#x3D;&quot;name1&quot;&gt;</span><br><span class="line">      &lt;filter  ... &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Logger&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Root level&#x3D;&quot;level&quot;&gt;</span><br><span class="line">      &lt;AppenderRef ref&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Root&gt;</span><br><span class="line">  &lt;&#x2F;Loggers&gt;</span><br><span class="line">&lt;&#x2F;Configuration&gt;</span><br></pre></td></tr></table></figure>
<p>log4j 2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本常用.xml后缀的文件进行配置，除此之外还包含.json和.jsn配置文件。log4j2虽然采用xml风格进行配置，依然包含三个组件,分别是 Logger(记录器)、Appender(输出目的地)、Layout(日志布局)。</p>
<ul>
<li>XML配置文件解析</li>
</ul>
<ol>
<li><p>根节点Configuration有两个属性:status和monitorinterval,有两个子节点:Appenders和Loggers(表明可以定义多个Appender和Logger).<br>status用来指定log4j本身的打印日志的级别.<br>monitorinterval为log4j 2.x新特点自动重载配置。指定自动重新配置的监测间隔时间，单位是s,最小是5s。</p>
</li>
<li><p>Appenders节点，常见的有三种子节点:Console、RollingFile、File.</p>
</li>
</ol>
<ul>
<li>Console节点用来定义输出到控制台的Appender.<br>　　 name:指定Appender的名字.<br>　　 target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT.<br>　　 PatternLayout:输出格式，不设置默认为:%m%n.</li>
<li>File节点用来定义输出到指定位置的文件的Appender.<br>　　name:指定Appender的名字.<br>　　fileName:指定输出日志的目的文件带全路径的文件名.<br>　　PatternLayout:输出格式，不设置默认为:%m%n.</li>
<li>RollingFile节点用来定义超过指定大小自动删除旧的创建新的的Appender.<br>　　name:指定Appender的名字.<br>　　fileName:指定输出日志的目的文件带全路径的文件名.<br>　　PatternLayout:输出格式，不设置默认为:%m%n.<br>　　filePattern:指定新建日志文件的名称格式.<br>　　Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志.<br>　　TimeBasedTriggeringPolicy:Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次．<br>　　SizeBasedTriggeringPolicy:Policies子节点，基于指定文件大小的滚动策略，size属性用来定义<br>　　每个日志文件的大小.<br>　　DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，<br>　　如果不做配置，默认是7</li>
</ul>
<p>通过在子节点中加入<PatternLayout pattern="自定义信息格式"/>进行日志布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#模式符号 - 用途(附加说明);&#123;可选附加选项&#125;(附加选项说明)</span><br><span class="line">#  %c     - 日志名称(通常是构造函数的参数);&#123;数字&#125;(&quot;a.b.c&quot; 的名称使用 %c&#123;2&#125; 会输出 &quot;b.c&quot;)</span><br><span class="line">#  %C     - 调用者的类名(速度慢,不推荐使用);&#123;数字&#125;(同上)</span><br><span class="line">#  %d     - 日志时间;&#123;SimpleDateFormat所能使用的格式&#125;</span><br><span class="line">#  %F     - 调用者的文件名(速度极慢,不推荐使用)</span><br><span class="line">#  %l     - 调用者的函数名、文件名、行号(速度极其极其慢,不推荐使用)</span><br><span class="line">#  %L     - 调用者的行号(速度极慢,不推荐使用)</span><br><span class="line">#  %m     - 日志</span><br><span class="line">#  %M     - 调用者的函数名(速度极慢,不推荐使用)</span><br><span class="line">#  %n     - 换行符号</span><br><span class="line">#  %p     - 日志优先级别(DEBUG, INFO, WARN, ERROR)</span><br><span class="line">#  %r     - 输出日志所用毫秒数</span><br><span class="line">#  %t     - 调用者的进程名</span><br><span class="line">#  %x     - Used to output the NDC (nested diagnostic context) associated with the thread that generated the logging event.</span><br><span class="line">#  %X     - Used to output the MDC (mapped diagnostic context) associated with the thread that generated the logging event.</span><br><span class="line">#</span><br><span class="line">#模式修饰符 - 对齐 - 最小长度 - 最大长度 - 说明</span><br><span class="line"># %20c        右      20         ~</span><br><span class="line"># %-20c      左       20         ~</span><br><span class="line"># %.30c       ~       ~          30</span><br><span class="line"># %20.30c     右      20         30</span><br><span class="line"># %-20.30c   左       20         30</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Loggers节点，常见的有两种:Root和Logger.</li>
</ol>
<ul>
<li>Root节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出<br>　　AppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity=”false”只在自定义的Appender中进行输出</li>
<li>Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。<br>　　name:用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点.</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Logger logger = LogManager.getLogger(Log4j2Test.class);<br>logger.error(…);<br>logger.warn(…);<br>logger.info(…);<br>logger.debug(…);<br>logger.trace(…);</p>
<p>如果是配合slf4j使用也是可以的，只需要按照前面说的，提前做好适配，然后使用slf4j的api即可。不过如果是新系统的话，建议直接上log4j2的api吧，可以享受所有log4j2的功能，使用slf4j之类的api时，上面说的参数格式化之类的功能就无法使用了。</p>
<h2 id="全异步配置-重点"><a href="#全异步配置-重点" class="headerlink" title="全异步配置(重点)"></a>全异步配置(重点)</h2><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><ol>
<li>启动类加入：<br> System.setProperty(“Log4jContextSelector”, “org.apache.logging.log4j.core.async.AsyncLoggerContextSelector”);</li>
<li>推荐配置log4j2 全异步（all async），在你的启动脚本中增加一个系统变量的配置：</li>
</ol>
<p>-Dlog4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</p>
<h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><ol>
<li><p>引入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--log4j2异步AsyncLogger需要这个依赖,否则AsyncLogger日志打印不出来--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.lmax&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;disruptor&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件引入</p>
<!--日志级别level以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->
<!--AsyncLogger 异步记录日志,Log4j2中的AsyncLogger的内部使用了Disruptor框架,所以需要添加依赖disruptor-3.3.4-->
<!--注意：includeLocation="true" 可以解决 AsyncLogger异步Logger输出appender中的日志 类方法和行数信息显示不出来问题，但是会降低性能(it can make logging 30 - 100 times slower)，所以呢 注重性能这里就不显示打印日志的行数和所在方法,把这里的includeLocation="true 去掉。AsyncLogger 的additivity属性需要设置为false，这个异步需要依赖disruptor3.4，如果没有disruptor3.4依赖包,AsyncLogger日志会打印不出来-->

</li>
</ol>
<AsyncLogger name="serverlogger" level="debug" additivity="false" includeLocation="true">
    <!--被当前Logger捕获到的日志信息level大于等于当前Logger的level属性时写入到 RollingFileInfo 里-->
    <!--每个Logger 可以设置多个appender ,如果有多个appender 会写入每个appender里-->
    <appender-ref ref="RollingFileInfo"/>
</AsyncLogger>

<h2 id="同步与异步的流程图"><a href="#同步与异步的流程图" class="headerlink" title="同步与异步的流程图"></a>同步与异步的流程图</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p><img src="/springBoot/006.png" alt="同步" title="同步"></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="/springBoot/007.png" alt="异步" title="异步"></p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>日志框架及slf4j+logback配置问题</title>
    <url>/2022/02/24/java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%8F%8Aslf4j+logback%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j:WARN No appenders could be found for logger (org.example.App).</span><br><span class="line">log4j:WARN Please initialize the log4j system properly.</span><br><span class="line">log4j:WARN See http:&#x2F;&#x2F;logging.apache.org&#x2F;log4j&#x2F;1.2&#x2F;faq.html#noconfig for more info.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;jiang&#x2F;.m2&#x2F;repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.2.3&#x2F;logback-classic-1.2.3.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;jiang&#x2F;.m2&#x2F;repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-log4j12&#x2F;1.7.30&#x2F;slf4j-log4j12-1.7.30.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]</span><br></pre></td></tr></table></figure>
<ol>
<li>DUBBO日志打印不正常的情况？</li>
<li>Mybatis SQL日志打印不出来的情况？</li>
<li>JPA/Hibernate SQL日志无法打印的情况？</li>
<li>复杂项目中，很多框架内部日志无法打印的情况？</li>
<li>Tomcat工程，日志文件打印了多份，catalina.out和其他文件？</li>
<li>SpringBoot项目，日志文件打印了多份的问题？</li>
<li>各种日志配置问题……</li>
</ol>
<h3 id="分析问题：日志框架的冲突"><a href="#分析问题：日志框架的冲突" class="headerlink" title="分析问题：日志框架的冲突"></a>分析问题：日志框架的冲突</h3><p>上面的这些问题，基本都是由于多套日志框架共存或配置错误导致的。那么为什么会出现共存或者冲突呢？<br>一般是以下几种原因：</p>
<ol>
<li>项目手动引用了各种日志框架的包 - 比如同时引用了log4j/log4j2/logback/jboss-logging/jcl等</li>
<li>包管理工具的传递依赖（Transitive Dependencies）导致，比如依赖了dubbo，但是dubbo依赖了zkclient，可zkclient又依赖了log4j，此时如果你的项目中还3有其他日志框架存在并有使用，那么就会导致多套共存</li>
<li>同一个日志框架多版本共存</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>Java 中的日志框架分为两种，分别为日志抽象/门面，日志实现</p>
<h4 id="日志抽象-门面"><a href="#日志抽象-门面" class="headerlink" title="日志抽象/门面"></a>日志抽象/门面</h4><p>日志抽象/门面，他们不负责具体的日志打印，如输出到文件、配置日志内容格式等。他们只是一套日志抽象，定义了一套统一的日志打印标准，如Logger对象，Level对象。</p>
<p>slf4j（Simple Logging Facade for Java）和jcl（Apache Commons Logging）这两个日志框架就是JAVA中最主流的日志抽象了。还有一个jboss-logging，主要用于jboss系列软件，比如hibernate之类。像 jcl已经多年不更新了（上一次更新时间还是14年），目前最推荐的是使用 slf4j</p>
<h4 id="日志实现"><a href="#日志实现" class="headerlink" title="日志实现"></a>日志实现</h4><p>Java 中的日志实现框架，主流的有以下几种：<br>log4j - Apache（老牌日志框架，不过多年不更新了，新版本为log4j2） log4j2 - Apache（log4j 的新版本，目前异步IO性能最强，配置也较简单） logback - QOS（slf4j就是这家公司的产品） jul（java.util.logging） - jdk内置 在程序中，可以直接使用日志框架，也可以使用日志抽象+日志实现搭配的方案。不过一般都是用日志抽象+日志实现，这样更灵活，适配起来更简单。<br>目前最主流的方案是slf4j+logback/log4j2，不过如果是jboss系列的产品，可能用的更多的还是jboss-logging，毕竟亲儿子嘛。像JPA/Hibernate这种框架里，内置的就是jboss-logging</p>
<h3 id="SpringBoot-Dubbo-日志框架冲突的例子"><a href="#SpringBoot-Dubbo-日志框架冲突的例子" class="headerlink" title="SpringBoot + Dubbo 日志框架冲突的例子"></a>SpringBoot + Dubbo 日志框架冲突的例子</h3><p>比如我有一个“干净的”spring-boot项目，干净到只有一个spring-boot-starter依赖，此时我想集成dubbo，使用zookeeper作为注册中心，此时我的依赖配置是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.9&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo-registry-zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.9&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>现在启动这个spring-boot项目，会发现一堆红色错误：<br>SLF4J: Class path contains multiple SLF4J bindings.<br>SLF4J: Found binding in [jar:file:/C:/Users/jiang/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]<br>SLF4J: Found binding in [jar:file:/C:/Users/jiang/.m2/repository/org/slf4j/slf4j-log4j12/1.7.30/slf4j-log4j12-1.7.30.jar!/org/slf4j/impl/StaticLoggerBinder.class]<br>SLF4J: See <a href="http://www.slf4j.org/codes.html#multiple_bindings" target="_blank" rel="noopener">http://www.slf4j.org/codes.html#multiple_bindings</a> for an explanation.<br>SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]<br>———————————-人肉分割线—————————————-<br>log4j:WARN No appenders could be found for logger (org.apache.dubbo.common.logger.LoggerFactory).<br>log4j:WARN Please initialize the log4j system properly.<br>log4j:WARN See <a href="http://logging.apache.org/log4j/1.2/faq.html#noconfig" target="_blank" rel="noopener">http://logging.apache.org/log4j/1.2/faq.html#noconfig</a> for more info.</p>
<p>从错误提示上看，错误内容分为两个部分：</p>
<ol>
<li>slf4j报错，提示找到多个slf4j的日志绑定</li>
<li>log4j报错，提示log4j没有appender配置</li>
</ol>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>出现这个错误，就是因为dubbo的传递依赖中含有log4j，但是spring-boot的默认配置是slf4j+logback。在依赖了dubbo相关包之后，现在项目中同时存在logback/jcl(apache commons-logging)/log4j/jul-to-slf4j/slf4j-log4j/log4j-to-slf4j</p>
<h4 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h4><p><img src="/springBoot/003.png" alt="日志依赖" title="日志依赖"></p>
<p>　　这个时候就乱套了，slf4j-log4j是log4j的slf4j实现，作用是调用slf4j api的时候使用log4j输出；而log4j-to-slf4j的作用是将log4j的实现替换为slf4j，这样一来不是死循环了，而且还有logback的存在，logback默认实现了slf4j的抽象，而slf4j-log4j也是一样实现了slf4j的抽象，logback，项目里共存了两套slf4j的实现，那么在使用slf4j接口打印的时候会使用哪个实现呢？<br>　　答案是“第一个”，也就是第一个被加载的Slf4j的实现类，但这种依靠ClassLoader加载顺序来保证的日志配置顺序是非常不靠谱的。如果想正常使用日志，让这个项目里所有的框架都正常打印日志，必须将日志框架统一。不过这里的统一并不是至强行修改，而是用“适配/中转”的方式。现在项目里虽然有slf4j-log4j的配置，但这个配置是适配log4j2用的，而我们的依赖了只有log4j1，实际上这个中转是无效的。但logback是有效的，而且是spring-boot项目的默认配置，这次就选择logback作为项目的统一日志框架吧。</p>
<h4 id="log4j报错解决"><a href="#log4j报错解决" class="headerlink" title="log4j报错解决"></a>log4j报错解决</h4><p>　　现在项目里存在log4j(1)的包，而且启动时又报log4j的错误，说明某些代码调用了log4j的api。但我们又不想用log4j，所以需要先解决log4j的问题。<br>由于有log4j代码的引用，所以直接删除log4j一定是不可行的。slf4j提供了一个log4j-over-slf4j的包，这个包复制了一份log4j1的接口类（Logger等），同时将实现类修改为slf4j了。<br>　　所以将log4j的（传递）依赖排除，同时引用log4j-over-slf4j，就解决了这个log4j的问题。现在来修改下pom中的依赖（查看依赖图可以使用maven的命令，或者是IDEA自带的Maven Dependencies Diagram，再或者Maven Helper之类的插件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;dubbo-registry-zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.9&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">  &lt;!--排除log4j--&gt;</span><br><span class="line">  &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">      &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;&#x2F;exclusion&gt;</span><br><span class="line">  &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--增加log4j-slf4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-over-slf4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.30&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="SLF4J报错解决"><a href="#SLF4J报错解决" class="headerlink" title="SLF4J报错解决"></a>SLF4J报错解决</h4><p>解决了log4j的问题之后，现在还有slf4j有两个实现的问题，这个问题处理就更简单了。由于我们计划使用logback，那么只需要排除/删除slf4j-log4j这个实现的依赖即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;dubbo-registry-zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.9&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">  &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">      &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">      &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;&#x2F;exclusion&gt;</span><br><span class="line">  &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>修改完成，再次启动就没有错误了，轻松解决问题</p>
<h3 id="日志框架适配大全图解"><a href="#日志框架适配大全图解" class="headerlink" title="日志框架适配大全图解"></a>日志框架适配大全图解</h3><p>上面只是介绍了一种转换的方式，但这么多日志框架，他们之间是可以互相转换的。不过最终目的都是统一一套日志框架，让最终的日志实现只有一套，这么多的日志适配/转换方式，全记住肯定是有点难。为此我画了一张可能是全网最全的日志框架适配图（原图尺寸较大，请点击放大查看），如果再遇到冲突，需要将一个日志框架转换到另一款的时候，只需要按照图上的路径，引入相关的依赖包即可<br><img src="/springBoot/004.png" alt="日志框架图解" title="日志框架图解"></p>
<p>比如想把slf4j，适配/转换到log4j2。按照图上的路径，只需要引用log4j-slf4j-impl即可。<br>如果想把jcl，适配/转换到slf4j，只需要删除jcl包，然后引用jcl-over-slf4j即可。<br>图上的箭头，有些标了文字的，是需要额外包进行转换的，有些没有标文字的，是内置了适配的实现。其实内置实现的这种会更麻烦，因为如果遇到共存基本都需要通过配置环境变量/配置额外属性的方式来指定一款日志实现。<br>目前slf4j是适配方案中，最核心的那个框架，算是这个图的中心枢纽。只要围绕slf4j做适配/转化，就没有处理不了的冲突</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决日志框架共存/冲突问题其实很简单，只要遵循几个原则：</p>
<ol>
<li>统一使用一套日志实现</li>
<li>删除多余的无用日志依赖</li>
<li>如果有引用必须共存的话，那么就移除原始包，使用“over”类型的包（over类型的包复制了一份原始接口，重新实现）</li>
<li>不能over的，使用日志抽象提供的指定方式，例如jboss-logging中，可以通过org.jboss.logging.provider环境变量指定一个具体的日志框架实现</li>
</ol>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>存储过程百万级别优化</title>
    <url>/2020/09/12/%E4%BC%98%E5%8C%96-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="存储过程优化步骤以及记录"><a href="#存储过程优化步骤以及记录" class="headerlink" title="存储过程优化步骤以及记录"></a>存储过程优化步骤以及记录</h2><h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><ul>
<li>定位并使用执行计划分析存储过程</li>
<li>查看表数据量和定义</li>
<li>改写sql查看执行计划<br>  考虑update开并行<br>  应用bulk collect优化</li>
</ul>
<h3 id="优化百万级别记录"><a href="#优化百万级别记录" class="headerlink" title="优化百万级别记录"></a>优化百万级别记录</h3><h4 id="取消游标使用bulk-collect优化"><a href="#取消游标使用bulk-collect优化" class="headerlink" title="取消游标使用bulk collect优化"></a>取消游标使用bulk collect优化</h4><p>1.定位并使用执行计划分析存储过程<br><img src="/img/procedure1.png" alt="procedure1" title="procedure1"><br><img src="/img/procedure2.png" alt="procedure2" title="procedure2"><br>执行计划分析存储<br><img src="/img/procedure3.png" alt="procedure3" title="procedure3"><br><font color="red">发现update部分耗时比较多</font><br>2.查看表数据量和定义<br>查看数量级为144万<br><img src="/img/procedure4.png" alt="procedure4" title="procedure4"><br>表定义如下：<br><img src="/img/procedure5.png" alt="procedure5" title="procedure5"></p>
<p>3.改写sql查看执行计划<br><font color="red">因为update部分耗时比较多，所以考虑改写成select看有没走索引</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;用了索引范围扫描</span><br><span class="line">select updatetime，sendtootm from Tab_TempDriverScan</span><br><span class="line"> where ScanWay &#x3D; &#39;1&#39; and ShipmentNumber &#x3D; v_shipmentnumber and LPN &#x3D; idx.LPN and SKU &#x3D; idx.SKU;</span><br></pre></td></tr></table></figure>
<p><img src="/img/procedure6.png" alt="procedure6" title="procedure6"></p>
<p>4.考虑update开并行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update &#x2F;*+ parallel(Tab_TempDriverScan,8) *&#x2F; Tab_TempDriverScan set UpdateTime &#x3D; SYSDATE, SendToOTM &#x3D; &#39;1&#39;</span><br><span class="line"> where ScanWay &#x3D; &#39;1&#39; and ShipmentNumber &#x3D; v_shipmentnumber and LPN &#x3D; idx.LPN and SKU &#x3D; idx.SKU;</span><br></pre></td></tr></table></figure>
<p><font color="red">减少了12秒，但是还不是很理想</font><br><img src="/img/procedure7.png" alt="procedure7" title="procedure7"></p>
<p>5.应用bulk collect优化<br>改写如图<br><img src="/img/procedure8.png" alt="procedure8" title="procedure8"><br>核心脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE Tab_TempDriverScan_rec_type IS RECORD --声明记录类型</span><br><span class="line"> (</span><br><span class="line"> v_shipmentnumber Tab_TempDriverScan.shipmentnumber%TYPE,</span><br><span class="line"> v_power_unit Tab_TempDriverScan.power_unit%TYPE,</span><br><span class="line"> v_IsSend Tab_TempDriverScan.IsSend%TYPE);</span><br><span class="line"> TYPE nested_Tab_TempDriverScan_type IS TABLE OF Tab_TempDriverScan_rec_type; --声明记录类型变量</span><br><span class="line"> Tab_TempDriverScan_tab nested_Tab_TempDriverScan_type;</span><br><span class="line">...................</span><br><span class="line">LOOP</span><br><span class="line"> fetch header1 BULK COLLECT</span><br><span class="line"> into Tab_TempDriverScan_tab; --应用bulk collect</span><br><span class="line"> EXIT WHEN header1%NOTFOUND;</span><br><span class="line">........................</span><br></pre></td></tr></table></figure>
<p>测试分析<br><img src="/img/procedure9.png" alt="procedure9" title="procedure9"><br><font color="red">这时候时间只需要0.06秒，性能获得了很大提升</font></p>
<h3 id="bulk-collect用法小结"><a href="#bulk-collect用法小结" class="headerlink" title="bulk collect用法小结"></a>bulk collect用法小结</h3><p>采用bulk collect可以将查询结果一次性地加载到collections中，而不是通过cursor一条一条地处理。<br>可以在select into,fetch into,returning into语句使用bulk collect。<br>注意：在使用bulk collect时，所有的into变量都必须是collections</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table t_test as</span><br><span class="line">  select object_id, object_name, object_type</span><br><span class="line">    from dba_objects</span><br><span class="line">   where wner &#x3D; &#39;TEST&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="在select-into语句中使用bulk-collect"><a href="#在select-into语句中使用bulk-collect" class="headerlink" title="在select into语句中使用bulk collect"></a>在select into语句中使用bulk collect</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">  type object_list is table of t_test.object_name%type;</span><br><span class="line">  objs object_list;</span><br><span class="line">begin</span><br><span class="line">  select object_name bulk collect</span><br><span class="line">    into objs</span><br><span class="line">    from t_test</span><br><span class="line">   where rownum &lt;&#x3D; 100;</span><br><span class="line">  for r in objs.first .. objs.last loop</span><br><span class="line">    dbms_output.put_line(&#39; objs(r)&#x3D;&#39; || objs(r));</span><br><span class="line">  end loop;</span><br><span class="line">end;</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="在fetch-into中使用bulk-collect"><a href="#在fetch-into中使用bulk-collect" class="headerlink" title="在fetch into中使用bulk collect"></a>在fetch into中使用bulk collect</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">  type objecttab is table of t_test%rowtype;</span><br><span class="line">  objs objecttab;</span><br><span class="line">  cursor cob is</span><br><span class="line">    select object_id, object_name, object_type</span><br><span class="line">      from t_test</span><br><span class="line">     where rownum &lt;&#x3D; 10;</span><br><span class="line">begin</span><br><span class="line">  open cob;</span><br><span class="line">  fetch cob bulk collect</span><br><span class="line">    into objs;</span><br><span class="line">  close cob;</span><br><span class="line">  for r in objs.first .. objs.last loop</span><br><span class="line">    dbms_output.put_line(&#39; objs(r)&#x3D;&#39; || objs(r).object_name);</span><br><span class="line">  end loop;</span><br><span class="line">end;</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure>
<p>以上为把结果集一次fetch到collect中，我们还可以通过limit参数，来分批fetch数据，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">  type objecttab is table of t_test%rowtype;</span><br><span class="line">  objs objecttab;</span><br><span class="line">  cursor cob is</span><br><span class="line">    select object_id, object_name, object_type</span><br><span class="line">      from t_test</span><br><span class="line">     where rownum &lt;&#x3D; 10000;</span><br><span class="line">begin</span><br><span class="line">  open cob;</span><br><span class="line">  loop</span><br><span class="line">    fetch cob bulk collect</span><br><span class="line">      into objs limit 1000;</span><br><span class="line">    exit when cob%notfound;</span><br><span class="line">    dbms_output.put_line(&#39;count:&#39; || objs.count || &#39; first:&#39; || objs.first ||</span><br><span class="line">                         &#39; last:&#39; || objs.last);</span><br><span class="line">    for r in objs.first .. objs.last loop</span><br><span class="line">      dbms_output.put_line(&#39; objs(r)&#x3D;&#39; || objs(r).object_name);</span><br><span class="line">    end loop;</span><br><span class="line">  end loop;</span><br><span class="line">  close cob;</span><br><span class="line">end;</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure>
<p>可以根据实际来调整limit参数的大小，来达到最优的性能。limit参数会影响到PGA的使用率。</p>
<h4 id="在returning-into中使用bulk-collect"><a href="#在returning-into中使用bulk-collect" class="headerlink" title="在returning into中使用bulk collect"></a>在returning into中使用bulk collect</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">  type id_list is table of t_test.object_id%type;</span><br><span class="line">  ids id_list;</span><br><span class="line">  type name_list is table of t_test.object_name%type;</span><br><span class="line">  names name_list;</span><br><span class="line">begin</span><br><span class="line">  delete from t_test</span><br><span class="line">   where object_id &lt;&#x3D; 87510 returning object_id, object_name bulk collect into ids,</span><br><span class="line">   names;</span><br><span class="line">  dbms_output.put_line(&#39;deleted &#39; || sql%rowcount || &#39; rows:&#39;);</span><br><span class="line">  for i in ids.first .. ids.last loop</span><br><span class="line">    dbms_output.put_line(&#39;object #&#39; || ids(i) || &#39;: &#39; || names(i));</span><br><span class="line">  end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h4 id="用于动态语句"><a href="#用于动态语句" class="headerlink" title="用于动态语句"></a>用于动态语句</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">v_query_sql   varchar2(500);</span><br><span class="line">type type_emp_table is table of emp%rowtype index by binary_integer;</span><br><span class="line">v_emp_table type_emp_table;</span><br><span class="line">begin</span><br><span class="line">   v_query_sql :&#x3D; &#39;select * from emp&#39;;</span><br><span class="line">   execute immediate v_query_sql bulk collect into v_emp_table;</span><br><span class="line">   forall i in 1..v_emp_table.count</span><br><span class="line">    insert into emp_bak values v_emp_table(i);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> declare</span><br><span class="line">v_query_sql   varchar2(500);</span><br><span class="line">type type_emp_table is table of emp%rowtype index by binary_integer;</span><br><span class="line">v_emp_table type_emp_table;</span><br><span class="line">type type_ename_table is table of emp.ename%type index by binary_integer;</span><br><span class="line">v_ename_table type_ename_table;</span><br><span class="line">begin</span><br><span class="line">   update emp set flag&#x3D;1 where deptno&#x3D;20 returning flag bulk collect into v_ename_table;   </span><br><span class="line">    for i in 1..v_ename_table.count loop</span><br><span class="line">       dbms_output.put_line(v_ename_table(i));</span><br><span class="line">   end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Procedure</tag>
        <tag>优化经验</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库规范</title>
    <url>/2021/02/19/%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="数据库命令规范"><a href="#数据库命令规范" class="headerlink" title="数据库命令规范"></a>数据库命令规范</h2><ul>
<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>
<li>所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过32个字符</li>
<li>临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低）</li>
</ul>
<h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h2><h3 id="所有表必须使用Innodb存储引擎"><a href="#所有表必须使用Innodb存储引擎" class="headerlink" title="所有表必须使用Innodb存储引擎"></a>所有表必须使用Innodb存储引擎</h3><p>没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</p>
<h3 id="数据库和表的字符集统一使用UTF8"><a href="#数据库和表的字符集统一使用UTF8" class="headerlink" title="数据库和表的字符集统一使用UTF8"></a>数据库和表的字符集统一使用UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效</p>
<h3 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h3><p>使用comment从句添加表和列的备注 从一开始就进行数据字典的维护</p>
<h3 id="尽量控制单表数据量的大小，建议控制在500万以内"><a href="#尽量控制单表数据量的大小，建议控制在500万以内" class="headerlink" title="尽量控制单表数据量的大小，建议控制在500万以内"></a>尽量控制单表数据量的大小，建议控制在500万以内</h3><p>500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题<br>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h3 id="谨慎使用MySQL分区表"><a href="#谨慎使用MySQL分区表" class="headerlink" title="谨慎使用MySQL分区表"></a>谨慎使用MySQL分区表</h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据</p>
<h3 id="尽量做到冷热数据分离，减小表的宽度"><a href="#尽量做到冷热数据分离，减小表的宽度" class="headerlink" title="尽量做到冷热数据分离，减小表的宽度"></a>尽量做到冷热数据分离，减小表的宽度</h3><p>MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）</p>
<h3 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h3><p>预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定</p>
<h3 id="禁止在数据库中存储图片，文件等大的二进制数据"><a href="#禁止在数据库中存储图片，文件等大的二进制数据" class="headerlink" title="禁止在数据库中存储图片，文件等大的二进制数据"></a>禁止在数据库中存储图片，文件等大的二进制数据</h3><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息</p>
<h3 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="禁止在线上做数据库压力测试"></a>禁止在线上做数据库压力测试</h3><h3 id="禁止从开发环境，测试环境直接连接生成环境数据库"><a href="#禁止从开发环境，测试环境直接连接生成环境数据库" class="headerlink" title="禁止从开发环境，测试环境直接连接生成环境数据库"></a>禁止从开发环境，测试环境直接连接生成环境数据库</h3><h2 id="数据库字段设计规范-优化数据库方法之一"><a href="#数据库字段设计规范-优化数据库方法之一" class="headerlink" title="数据库字段设计规范(优化数据库方法之一)"></a>数据库字段设计规范(优化数据库方法之一)</h2><h3 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li>将字符串转换成数字类型存储，如：将IP地址转换成整形数据。<br>mysql提供了两个方法来处理ip地址：<br><img src="/sql/9.png" alt="sql" title="sql9"><br>插入数据前，先用inet_aton把ip地址转为整型，可以节省空间。显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。</li>
<li>对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储<br>因为：无符号相对于有符号可以多出一倍的存储空间<br><img src="/sql/10.png" alt="sq10" title="sql10"><br>VARCHAR(N)中的N代表的是字符数，而不是字节数<br>使用UTF8存储255个汉字 Varchar(255)=765个字节。过大的长度会消耗更多的内存</li>
</ol>
<h3 id="避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据"><a href="#避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据" class="headerlink" title="避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据"></a>避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据</h3><ul>
<li>建议把BLOB或是TEXT列分离到单独的扩展表中<br>Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。<br>而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。<br>如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。</li>
<li>TEXT或BLOB类型只能使用前缀索引<br>因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。<h3 id="避免使用ENUM类型"><a href="#避免使用ENUM类型" class="headerlink" title="避免使用ENUM类型"></a>避免使用ENUM类型</h3></li>
<li>修改ENUM值需要使用ALTER语句</li>
<li>ENUM类型的ORDER BY操作效率低，需要额外操作</li>
<li>禁止使用数值作为ENUM的枚举值<h3 id="尽可能把所有列定义为NOT-NULL"><a href="#尽可能把所有列定义为NOT-NULL" class="headerlink" title="尽可能把所有列定义为NOT NULL"></a>尽可能把所有列定义为NOT NULL</h3></li>
<li>索引NULL列需要额外的空间来保存，所以要占用更多的空间；</li>
<li>进行比较和计算时要对NULL值做特别的处理<h3 id="使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间"><a href="#使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间" class="headerlink" title="使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间"></a>使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间</h3>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。<br>TIMESTAMP 占用4字节和INT相同，但比INT可读性高<br>超出TIMESTAMP取值范围的使用DATETIME类型存储。<br>经常会有人用字符串存储日期型的数据（不正确的做法）：</li>
<li>缺点1：无法用日期函数进行计算和比较</li>
<li>缺点2：用字符串存储日期要占用更多的空间<h3 id="同财务相关的金额类数据必须使用decimal类型"><a href="#同财务相关的金额类数据必须使用decimal类型" class="headerlink" title="同财务相关的金额类数据必须使用decimal类型"></a>同财务相关的金额类数据必须使用decimal类型</h3></li>
<li>非精准浮点：float,double</li>
<li>精准浮点：decimal<br>Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</li>
</ul>
<h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><h4 id="限制每张表上的索引数量，建议单张表索引不超过5个"><a href="#限制每张表上的索引数量，建议单张表索引不超过5个" class="headerlink" title="限制每张表上的索引数量，建议单张表索引不超过5个"></a>限制每张表上的索引数量，建议单张表索引不超过5个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。<br>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。<br>因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。</p>
<h4 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h4><p>5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好</p>
<h4 id="每个Innodb表必须有个主键"><a href="#每个Innodb表必须有个主键" class="headerlink" title="每个Innodb表必须有个主键"></a>每个Innodb表必须有个主键</h4><p>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。<br>每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。<br>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。<br>主键建议使用自增ID值。</p>
<h3 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h3><ul>
<li>出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列</li>
<li>包含在ORDER BY、GROUP BY、DISTINCT中的字段<br>并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好</li>
<li>多表join的关联列</li>
</ul>
<h3 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h3><p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。</li>
</ul>
<h3 id="避免建立冗余索引和重复索引"><a href="#避免建立冗余索引和重复索引" class="headerlink" title="避免建立冗余索引和重复索引"></a>避免建立冗余索引和重复索引</h3><p>因为这样会增加查询优化器生成执行计划的时间。</p>
<ul>
<li>重复索引示例： primary key(id)、index(id)、unique index(id)</li>
<li>冗余索引示例： index(a,b,c)、index(a,b)、index(a)</li>
</ul>
<h3 id="优先考虑覆盖索引"><a href="#优先考虑覆盖索引" class="headerlink" title="优先考虑覆盖索引"></a>优先考虑覆盖索引</h3><p>对于频繁的查询优先考虑使用覆盖索引。<br>覆盖索引： 就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引<br>覆盖索引的好处：</p>
<ul>
<li>避免Innodb表进行索引的二次查询<br>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，<br>如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。</li>
<li>可以把随机IO变成顺序IO加快查询效率<br>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</li>
</ul>
<h3 id="索引SET规范"><a href="#索引SET规范" class="headerlink" title="索引SET规范"></a>索引SET规范</h3><p>尽量避免使用外键约束</p>
<ul>
<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引；</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现；</li>
<li>外键会影响父表和子表的写操作从而降低性能</li>
</ul>
<h3 id="数据库SQL开发规范"><a href="#数据库SQL开发规范" class="headerlink" title="数据库SQL开发规范"></a>数据库SQL开发规范</h3><h4 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h4><p>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。</p>
<h4 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h4><p>隐式转换会导致索引失效。如：select name,phone from customer where id = ‘111’;</p>
<h4 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h4><ul>
<li>避免使用双%号的查询条件。<br>如a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）</li>
<li>一个SQL只能利用到复合索引中的一列进行范围查询<br>如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。<br>使用left join或 not exists来优化not in操作<br>因为not in 也通常会使用索引失效。<h4 id="数据库设计时，应该要对以后扩展进行考虑"><a href="#数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="数据库设计时，应该要对以后扩展进行考虑"></a>数据库设计时，应该要对以后扩展进行考虑</h4><h4 id="程序连接不同的数据库使用不同的账号，进制跨库查询"><a href="#程序连接不同的数据库使用不同的账号，进制跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，进制跨库查询"></a>程序连接不同的数据库使用不同的账号，进制跨库查询</h4></li>
<li>为数据库迁移和分库分表留出余地</li>
<li>降低业务耦合度</li>
<li>避免权限过大而产生的安全风险<h4 id="禁止使用SELECT-必须使用SELECT-lt-字段列表-gt-查询"><a href="#禁止使用SELECT-必须使用SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询"></a>禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询</h4>原因：</li>
<li>消耗更多的CPU和IO以网络带宽资源</li>
<li>无法使用覆盖索引</li>
<li>可减少表结构变更带来的影响<h4 id="禁止使用不含字段列表的INSERT语句"><a href="#禁止使用不含字段列表的INSERT语句" class="headerlink" title="禁止使用不含字段列表的INSERT语句"></a>禁止使用不含字段列表的INSERT语句</h4>如：insert into values (‘a’,’b’,’c’);<br>应使用insert into t(c1,c2,c3) values (‘a’,’b’,’c’);<h4 id="避免使用子查询，可以把子查询优化为join操作"><a href="#避免使用子查询，可以把子查询优化为join操作" class="headerlink" title="避免使用子查询，可以把子查询优化为join操作"></a>避免使用子查询，可以把子查询优化为join操作</h4>通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。<br>子查询性能差的原因：</li>
<li>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能       会受到一定的影响；</li>
<li>特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；</li>
<li>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。<h4 id="避免使用JOIN关联太多的表"><a href="#避免使用JOIN关联太多的表" class="headerlink" title="避免使用JOIN关联太多的表"></a>避免使用JOIN关联太多的表</h4>对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。<br>在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。<br>如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。<br>同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。<h4 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h4>数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率<h4 id="对应同一列进行or判断时，使用in代替or"><a href="#对应同一列进行or判断时，使用in代替or" class="headerlink" title="对应同一列进行or判断时，使用in代替or"></a>对应同一列进行or判断时，使用in代替or</h4>in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。<h4 id="禁止使用order-by-rand-进行随机排序"><a href="#禁止使用order-by-rand-进行随机排序" class="headerlink" title="禁止使用order by rand() 进行随机排序"></a>禁止使用order by rand() 进行随机排序</h4>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。<br>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式<h4 id="WHERE从句中禁止对列进行函数转换和计算"><a href="#WHERE从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE从句中禁止对列进行函数转换和计算"></a>WHERE从句中禁止对列进行函数转换和计算</h4>对列进行函数转换或计算时会导致无法使用索引。</li>
<li>不推荐<br><img src="/sql/11.png" alt="sql" title="sql11"></li>
<li>推荐<br><img src="/sql/12.png" alt="sql" title="sql12"><h4 id="在明显不会有重复值时使用UNION-ALL而不是UNION"><a href="#在明显不会有重复值时使用UNION-ALL而不是UNION" class="headerlink" title="在明显不会有重复值时使用UNION ALL而不是UNION"></a>在明显不会有重复值时使用UNION ALL而不是UNION</h4></li>
<li>UNION会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li>UNION ALL不会再对结果集进行去重操作<h4 id="拆分复杂的大SQL为多个小SQL"><a href="#拆分复杂的大SQL为多个小SQL" class="headerlink" title="拆分复杂的大SQL为多个小SQL"></a>拆分复杂的大SQL为多个小SQL</h4></li>
<li>大SQL：逻辑上比较复杂，需要占用大量CPU进行计算的SQL</li>
<li>MySQL：一个SQL只能使用一个CPU进行计算</li>
<li>SQL拆分后可以通过并行执行来提高处理效率</li>
</ul>
<h3 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h3><h4 id="超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"><a href="#超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作" class="headerlink" title="超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"></a>超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</h4><ul>
<li>大批量操作可能会造成严重的主从延迟<br>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</li>
<li>binlog日志为row格式时会产生大量的日志<br>大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。</li>
<li>避免产生大事务操作<br>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。<br>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。<h4 id="对于大表使用pt-online-schema-change修改表结构"><a href="#对于大表使用pt-online-schema-change修改表结构" class="headerlink" title="对于大表使用pt-online-schema-change修改表结构"></a>对于大表使用pt-online-schema-change修改表结构</h4></li>
<li>避免大表修改产生的主从延迟</li>
<li>避免在对表字段进行修改时进行锁表<br>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。<br>pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。<br>把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。<br>把原来一个DDL操作，分解成多个小的批次进行。<h4 id="禁止为程序使用的账号赋予super权限"><a href="#禁止为程序使用的账号赋予super权限" class="headerlink" title="禁止为程序使用的账号赋予super权限"></a>禁止为程序使用的账号赋予super权限</h4>当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。<h4 id="对于程序连接数据库账号，遵循权限最小原则"><a href="#对于程序连接数据库账号，遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号，遵循权限最小原则"></a>对于程序连接数据库账号，遵循权限最小原则</h4>程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限。</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>面试知识</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>目录分类</title>
    <url>/2021/03/29/%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="IDEA-Plugin-soft"><a href="#IDEA-Plugin-soft" class="headerlink" title="IDEA Plugin soft"></a>IDEA Plugin soft</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/Vs3ZDB60bI_WZ5GloGX-4Q" target="_blank" rel="noopener">使用 IDEA 解决 Java8 的数据流问题，极大提升生产力！！</a><br><a href="https://mp.weixin.qq.com/s/NbBAJW3jc8FBXpabGtHNXw" target="_blank" rel="noopener">排名前 16 的 Java 工具类，哪个你没用过？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/K2nbzDQmharfYhkBDvwQdw" target="_blank" rel="noopener"> Java 开发工具教程，Git/Maven！</a><br><a href="https://mp.weixin.qq.com/s/QRMNa_VEP3we3AAeYLV3vw" target="_blank" rel="noopener">太赞了！终于有人把怎么在 IDEA 中使用 Java 热部署插件 JRebel 讲清楚了。。。</a><br><a href="https://mp.weixin.qq.com/s/QjQ3OQRaZKpywwN-rOJIjA" target="_blank" rel="noopener">Spring Boot 五种热部署方式，再也不用老重启了！</a><br><a href="https://mp.weixin.qq.com/s/BKN29snpcWZs24y1Nt6IIw" target="_blank" rel="noopener">如何在Github上精准地找到想要的开源项目？</a><br><a href="https://mp.weixin.qq.com/s/7i9MBWG2SK9-BPyLxaqXog" target="_blank" rel="noopener">IntelliJ IDEA 2020.2.4款 神级超级牛逼插件推荐</a><br><a href="https://blog.csdn.net/linsongbin1/article/details/80211919" target="_blank" rel="noopener">Intellij IDEA神器居然还有这些小技巧</a><br><a href="https://mp.weixin.qq.com/s/IPgAZqubWeoKen6ImmCC_A" target="_blank" rel="noopener">别光埋头写代码，这100个网站比涨工资都重要！</a></p>
</li>
<li><p>chrome 插件<br> @@ ${}区别 maven build  —– &gt; deploy package<br>   dev ，pro  //@Profile({“dev”,”sit”,”uat”,”pre”,”pro”}) //一般生产环境不允许日志打印参数<br>  2.写日志演进blog—》 mybatis plus—&gt;测试异步log<br>  responebody—&gt;valid rusltmap<br>  test——&gt; jococo—&gt;sonalint —-&gt;<br>  多模块互用项目搭建<br>  1.衣服，鞋子 </p>
<p>  Kafka—-&gt;rabbit—&gt;</p>
<p>  <a href="https://www.cnblogs.com/orzlin/p/9717399.html" target="_blank" rel="noopener">https://www.cnblogs.com/orzlin/p/9717399.html</a>   SpringBoot+Mybatis多模块（module）项目搭建教程</p>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="搭建考虑"><a href="#搭建考虑" class="headerlink" title="搭建考虑"></a>搭建考虑</h3></li>
</ul>
<ol>
<li>目录管理<ol>
<li>对象目录<ol>
<li>规范：请求参数使用注解校验或(自定义注解),常量使用枚举类定义,Bean目录</li>
<li>创建实体对象，映射这张表 dto -&gt; pojo</li>
<li>创建API入参BO-&gt;entity/POJO</li>
<li>创建API出参 entity -&gt;VO </li>
</ol>
</li>
<li>创建Controller目录</li>
<li>创建Service目录</li>
<li>创建Dao目录</li>
<li>增加一张表</li>
<li>创建Mapper目录, xml或者JPA</li>
</ol>
</li>
<li>在mysql客户端，或者mongo客户端中写执行脚本语句，复制到代码中</li>
<li>反复重启，进行接口自测</li>
<li>编写API文档</li>
</ol>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构:"></a>项目结构:</h3><ol>
<li>规划项目目录管理，检查开发环境:JDK1.8—–&gt;lamda<br> <a href="https://mp.weixin.qq.com/s/iPCmVuUX6yRbaw2gD_zXxw" target="_blank" rel="noopener">是时候装逼了，试试 IDEA 解决 Maven 依赖冲突的高能神器！</a><br> <a href="https://mp.weixin.qq.com/s/_6A85AuOmF6TMJe6MaPVOA" target="_blank" rel="noopener">使用 Stream API 高逼格 优化 Java 代码！</a><br> <a href="https://blog.csdn.net/qq_32415063/article/details/105568986" target="_blank" rel="noopener">spring-boot打包成Jar 如何在linux系统上运行及重启，设置启动参数</a><br> <a href="https://mp.weixin.qq.com/s/-W6nR_pTTI4DfAwxiw6vCQ" target="_blank" rel="noopener">Java8 Stream：2 万字 20 个实例，玩转集合的筛选、归约、分组、聚合</a></li>
<li>代码规范<br> <a href="https://mp.weixin.qq.com/s/jnWvHN_-l3d8bS7gsDv-Mg" target="_blank" rel="noopener">腾讯 Code Review 规范出炉！你还敢乱写代码？？</a><br> <a href="https://mp.weixin.qq.com/s/XXENRFm7zMCydm6KRerIvA" target="_blank" rel="noopener">值得收藏：一份非常完整的 MySQL 规范</a></li>
<li>搭建mockserver<ol>
<li><a href="https://yapi.baidu.com/" target="_blank" rel="noopener">百度官网mock服务器</a></li>
<li><a href="https://hellosean1025.github.io/yapi/" target="_blank" rel="noopener">搭建YApi Mock接口</a></li>
<li><a href="https://blog.csdn.net/Feng_Leng/article/details/100990427" target="_blank" rel="noopener">YApi管理工具教程</a></li>
</ol>
</li>
<li>JUnit—-&gt;测试类命名规则<ol>
<li><a href="https://blog.csdn.net/qq_35448976/article/details/105748753" target="_blank" rel="noopener">Mockito工具的使用</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZRa6JrmEgo18Zjv_gapv0Q" target="_blank" rel="noopener">单元测试-如何去mock对象</a></li>
<li><a href="https://mp.weixin.qq.com/s/RT-KKT1BskUYEvYAXhms5A" target="_blank" rel="noopener">Java如何优雅地实现单元测试与集成测试</a></li>
<li><a href="https://mp.weixin.qq.com/s/uHYF3Klaq9f2N2C_OxOPIA" target="_blank" rel="noopener">小谈 Java 单元测试</a></li>
<li><a href="https://mp.weixin.qq.com/s/xY7sgp9gJQ1Fcl-ArmRHRg" target="_blank" rel="noopener">Spring Boot 集成 JUnit5，更优雅单元测试！</a></li>
<li><a href="https://mp.weixin.qq.com/s/EoKS-_-mRekuhYJV_iPYTw" target="_blank" rel="noopener">史上最轻量​！阿里新型单元测试 Mock 工具开源</a></li>
<li><a href="https://mp.weixin.qq.com/s/ezEEWGldspl0OqjSgQFI6Q" target="_blank" rel="noopener">Java 并发测试神器：基准测试神器-JMH</a></li>
<li><a href="https://blog.csdn.net/watson1360884839/article/details/86580350" target="_blank" rel="noopener">jacoco-单元测试覆盖率测试</a></li>
<li><a href="https://www.cnblogs.com/yjmyzz/p/mockito-and-jacoco-tutorial.html" target="_blank" rel="noopener">mock测试及jacoco覆盖率</a></li>
</ol>
</li>
<li>SonarLint<ol>
<li><a href="https://blog.csdn.net/qq_35981283/article/details/81080402" target="_blank" rel="noopener">编译时检查规范SonarLint</a></li>
</ol>
</li>
<li>Jacoco<ol>
<li><a href="https://blog.csdn.net/weixin_40514600/article/details/102583631" target="_blank" rel="noopener">覆盖率Jacoco</a></li>
<li><a href="https://www.jianshu.com/p/464a140b2c67" target="_blank" rel="noopener">基于 jacoco 的功能测试代码覆盖率实践/基于 jacoco + SonarQube + sonar-scanner 的集成实践</a></li>
<li><a href="https://blog.csdn.net/hello_jee/article/details/91891355" target="_blank" rel="noopener">代码测试覆盖率检查——jacoco</a></li>
</ol>
</li>
<li>请求校验<ol>
<li><a href="https://www.jianshu.com/p/2762f775fbf0" target="_blank" rel="noopener">Spring Boot使用JSR-380进行校验</a></li>
<li><a href="https://blog.csdn.net/qq_28867949/article/details/78922520" target="_blank" rel="noopener">@ControllerAdvice JSR-303 数据校验学习（一）</a></li>
<li><a href="https://blog.csdn.net/lklihaikunkun/article/details/80605425" target="_blank" rel="noopener">spring @Validated 注解开发中使用group分组校验</a></li>
<li><a href="https://blog.csdn.net/wwd0501/article/details/104422345" target="_blank" rel="noopener">validation自定义注解校验枚举类型：</a></li>
<li><a href="https://blog.csdn.net/weixin_41945228/article/details/97276847" target="_blank" rel="noopener">Validation分组校验</a></li>
<li><a href="https://www.cnblogs.com/myinspire/articles/7649027.html" target="_blank" rel="noopener">SpringMvc中的校验框架@valid和@validation的概念及相关使用</a></li>
</ol>
</li>
<li>定时任务<br><a href="https://mp.weixin.qq.com/s/3D0YPQ7TSa6UJXlm_5_4Eg" target="_blank" rel="noopener">Spring Boot 实现定时任务的动态增删启停</a><br><a href="https://mp.weixin.qq.com/s/BiXyIwpSBOGqXI3fTT7IcA" target="_blank" rel="noopener">国产最强分布式调度恢复更新！可调度 10000 级定时任务！</a><br><a href="https://mp.weixin.qq.com/s/3ueVSoQjOM1LSfP87zBG3w" target="_blank" rel="noopener">SpringBoot 整合 Quartz 实现 JAVA 定时任务的动态配置</a><br><a href="https://mp.weixin.qq.com/s/dreGHo_7fJwUQDdgBAnvag" target="_blank" rel="noopener">JAVA定时任务实现的几种方式</a><br><a href="https://mp.weixin.qq.com/s/1IKAbnaQJaN6AA91SYhQ1Q" target="_blank" rel="noopener">Java 实现定时任务的 4 种方式</a><br><a href="https://mp.weixin.qq.com/s/3_8yfRMzpJ5ZrRTiOOeP5w" target="_blank" rel="noopener">SpringBoot 整合 Quartz 实现 JAVA 定时任务的动态配置</a></li>
<li>Utils<br><a href="https://mp.weixin.qq.com/s/zRhndoENxYP1IMrHCDjgCQ" target="_blank" rel="noopener">不要再封装各种 Util 工具类了，这个神级框架值得拥有！</a><br><a href="https://mp.weixin.qq.com/s/DfJh74y_gLhXHNwy1eFGQg" target="_blank" rel="noopener">感受 Java Lambda 之美，推荐收藏，需要时查阅</a><br><a href="https://mp.weixin.qq.com/s/IGbGQwteJafn7JoKIOgkkw" target="_blank" rel="noopener">天天在用 Stream，那你知道如此强大的 Stream 的实现原理吗？</a><br><a href="https://www.v2ex.com/t/454137" target="_blank" rel="noopener">toString 模板</a></li>
<li>缓存<br><a href="https://blog.csdn.net/mafei6827/article/details/80868931" target="_blank" rel="noopener">缓存Guava/Caffeine加载</a><br><a href="https://blog.csdn.net/sinat_36553913/article/details/85837164" target="_blank" rel="noopener">缓存Guava/Caffeine加载</a><br><a href="https://albenw.github.io/posts/df42dc84/" target="_blank" rel="noopener">Guava cache原理</a><br><a href="https://www.cnblogs.com/rickiyang/p/11074159.html" target="_blank" rel="noopener">Guava cache使用总结</a><br><a href="https://mp.weixin.qq.com/s/cv3l8cK3POKGxT_ChxjRHg" target="_blank" rel="noopener">还在用 Guava Cache？它才是 Java 本地缓存之王！</a><br><a href="https://mp.weixin.qq.com/s/cAZdTyfM6D2GFFQmeoG-jg" target="_blank" rel="noopener">万字详解本地缓存之王 Caffeine，SpringBoot2.X 官方推荐</a><br><a href="https://mp.weixin.qq.com/s/O0FYwy547aexUhmve5zsmA" target="_blank" rel="noopener">贼厉害，手撸的 SpringBoot 缓存系统，性能杠杠的！</a></li>
<li>分页MybatisHepler  &amp;&amp; ORM<ol>
<li><a href="https://mp.weixin.qq.com/s/qlGjZ9Qni5930e8ZGkSVjA" target="_blank" rel="noopener">MyBatis动态SQL，写SQL更爽</a></li>
<li><a href="https://zhile.io/2019/04/23/mybatis-code-helper-pro-crack.html" target="_blank" rel="noopener">MyBatisCodeHelper-Pro插件破解版2.8.2</a></li>
<li><a href="https://mp.weixin.qq.com/s/ipfpM6rymhVEyRc832m5PQ" target="_blank" rel="noopener">如何让 Mybatis 自动生成代码</a></li>
<li><a href="https://mp.weixin.qq.com/s/sU4NBwmbpcohtjnKVtnH2A" target="_blank" rel="noopener">新技能 MyBatis 千万数据表，快速分页！</a></li>
</ol>
</li>
<li>MyBatis  sql日志打印<ol>
<li><a href="https://mp.weixin.qq.com/s/MIW7Z3P9EJTVZopK1vMwsw" target="_blank" rel="noopener">MyBatis Plus 常用 API 全套教程，看完没有不懂的</a></li>
<li><a href="https://www.cnblogs.com/it-deepinmind/p/11761616.html" target="_blank" rel="noopener">Mybatis-Plus和Mybatis的区别</a></li>
</ol>
</li>
<li>mysql 主键id用雪花算法<br><a href="https://mp.weixin.qq.com/s/JtxOvPoIIpGHhaXbz_Ii9A" target="_blank" rel="noopener">一文搞定分布式系统 ID 生成方案</a></li>
<li>算法<br><a href="https://www.cnblogs.com/rickiyang/p/13210830.html" target="_blank" rel="noopener">加密算法</a></li>
<li>devops搭建:jekins/编译时检查规范SonarLint<br><a href="http://www.lucienchen.xyz/2020/06/25/%E8%81%8A%E4%B8%80%E8%81%8ADevOps/" target="_blank" rel="noopener">聊一聊DevOps分享一些DevOps的理解和实践</a><br><a href="https://blog.csdn.net/yhmliunan/article/details/107927560" target="_blank" rel="noopener">jenkins+sonarQube+gitlab持续集成指南</a><br><a href="https://www.cnblogs.com/wangxu01/articles/11113875.html" target="_blank" rel="noopener">Jenkins和sonarqube集成</a><br><a href="https://blog.csdn.net/qq_37965741/article/details/107018297" target="_blank" rel="noopener">jenkins流水线整合jacoco与sonar（一）</a><br><a href="https://blog.csdn.net/fbb1995/article/details/80082119" target="_blank" rel="noopener">jenkins集成sonar、jacoco</a><br><a href="https://blog.51cto.com/damaicha/2118766" target="_blank" rel="noopener">持续集成与自动化部署 - jenkins与sonar、gitlab集成 （六）</a><br><a href="https://mp.weixin.qq.com/s/WhHsxyDSwA9px_60YllzGw" target="_blank" rel="noopener">Jenkins 日常维护之数据备份</a><br><a href="https://mp.weixin.qq.com/s/Sxplq3Jg3Ra6M5xcv_Tr5w" target="_blank" rel="noopener">某小型公司持续集成工具 Jenkins 实践</a></li>
<li>Echart/Hichart</li>
<li>pdf/excel<br><a href="https://mp.weixin.qq.com/s/yzoXPSIFqt0k5R4KLH5G-A" target="_blank" rel="noopener">Java实现pdf和Excel的生成及数据动态插入、导出 </a><br><a href="https://blog.csdn.net/weixin_30347009/article/details/96495054" target="_blank" rel="noopener">Java单元测试之代码覆盖率-JaCoCo</a><br><a href="https://mp.weixin.qq.com/s/2UdV_-ZfpYAOdW6ZTLB1Fw" target="_blank" rel="noopener">POI读写超大数据量Excel，解决超过几万行而导致内存溢出的问题（附源码）</a><br><a href="https://mp.weixin.qq.com/s/imIhHiPft0o_t8iUfzTMAQ" target="_blank" rel="noopener">EasyExcel，让 excel 导入导出更加简单</a><br><a href="https://mp.weixin.qq.com/s/Y1feFfn8VeZsxXw65NYoWQ" target="_blank" rel="noopener">100000 行级别数据的 Excel 导入优化之路</a><br><a href="https://mp.weixin.qq.com/s/zsJAZP25D_I25VmSfHiF7Q" target="_blank" rel="noopener">压缩 20M 文件从 30 秒到 1 秒的优化过程</a><br><a href="https://mp.weixin.qq.com/s/0eNwbA4Zzo8sgqgKWE7t_A" target="_blank" rel="noopener">Spring Boot 如何上传大文件？骚操作～</a></li>
</ol>
<h3 id="代码设计思想"><a href="#代码设计思想" class="headerlink" title="代码设计思想"></a>代码设计思想</h3><p><a href="https://mp.weixin.qq.com/s/yg4U-GM6JfzIwD-IX6Q5pA" target="_blank" rel="noopener">4 种主流的 API 架构风格对比</a><br><a href="https://mp.weixin.qq.com/s/H8OSeUaGIlU8OtojgT4W9Q" target="_blank" rel="noopener">《Spring设计思想》AOP设计思想与原理（图文并茂）</a><br><a href="https://mp.weixin.qq.com/s/nan90kHUUqq9GPBjelpLow" target="_blank" rel="noopener">SpringBoot 接口幂等性实现的 4 种方案！这个我真的服气了！</a><br><a href="https://mp.weixin.qq.com/s/OzxyHdyh6xm-Pi8AGak9rw" target="_blank" rel="noopener">阿里面试官：接口的幂等性怎么设计？</a><br><a href="https://mp.weixin.qq.com/s/YWIx-Ev8P0uSOqOc7yMNPw" target="_blank" rel="noopener">如何设计一个百万级用户的抽奖系统？</a><br><a href="https://mp.weixin.qq.com/s/y-84pTSt03SQzfY3tJOozQ" target="_blank" rel="noopener">打死都要记住！微服务架构的常用设计模式！</a><br><a href="https://mp.weixin.qq.com/s/7LiYhrBcnL9gro5BPE6jiA" target="_blank" rel="noopener">架构设计的本质：系统与子系统、模块与组件、框架与架构</a><br><a href="https://mp.weixin.qq.com/s/TwADpVS5aKyBFjLVzijZKA" target="_blank" rel="noopener">公司架构师常常提起的DNS负载均衡是个什么鬼？</a></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Ik6LvOrTX4fwg2VCIId7_Q" target="_blank" rel="noopener">Spring 中经典的 9 种设计模式，打死也要记住啊！</a><br><a href="https://mp.weixin.qq.com/s/y6Ybk4TTlaTxL2rrjBdZlA" target="_blank" rel="noopener">写一个通用的幂等组件，艿艿觉得很有必要</a></li>
</ul>
<h3 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/EcugQjYey8j6h99H4e-XOw" target="_blank" rel="noopener">Java 后端开发实践 - 项目模板</a><br><a href="https://mp.weixin.qq.com/s/lVumBSMAhldh1U974-CpVA" target="_blank" rel="noopener">支付宝支付加密规则梳理，写的太好了！</a><br><a href="https://mp.weixin.qq.com/s/85gINUycrhrovLLcK7tW1w" target="_blank" rel="noopener">SpringBoot 项目模板：摆脱步步搭建</a><br><a href="https://mp.weixin.qq.com/s/wYSwe56pop3RkK0BSRRy-g" target="_blank" rel="noopener">Spring Boot 实战：整合Redis、MyBatis，封装 RedisUtils 工具类</a><br><a href="https://mp.weixin.qq.com/s/_twQqmclPEmUJmhPjiqRcQ" target="_blank" rel="noopener">一份 Spring Boot 项目搭建模板:</a><br><a href="https://mp.weixin.qq.com/s/lHD8l6mz27JAsuFg3JUJOQ" target="_blank" rel="noopener">SpringBoot + Mybatis + Druid + PageHelper 实现多数据源并分页</a><br><a href="https://mp.weixin.qq.com/s/z3RaI9ZqhPYWk7RbeagMJw" target="_blank" rel="noopener">Jenkins + 钉钉 + SpringBoot 极简入门，一键打包部署项目</a><br><a href="https://mp.weixin.qq.com/s/1gSYL95pOtq4jgo4dfwXbw" target="_blank" rel="noopener">Spring MVC + Spring + Mybatis 实现支付宝支付功能（图文详解+完整代码）</a><br><a href="https://mp.weixin.qq.com/s/TsPyaAK74CV3A--_s3B4sA" target="_blank" rel="noopener">一份 Spring Boot 项目搭建模板</a><br><a href="https://mp.weixin.qq.com/s/yf3I8sjpOdKRbde7DLZ2lw" target="_blank" rel="noopener">开源一个SpringBoot + Mybatis + Vue的代码生成器</a><br><a href="https://mp.weixin.qq.com/s/JdTHgptv47rt2kORqyZWOg" target="_blank" rel="noopener">基于 Spring Boot 的车牌识别系统（附项目地址）ba</a><br><a href="https://mp.weixin.qq.com/s/xiNp2dvWJFLvjGSPa746eA" target="_blank" rel="noopener">Spring Boot 多模块项目实践（附打包方法）</a><br><a href="https://mp.weixin.qq.com/s/1B-bs61nG16k-lXR0qOfog" target="_blank" rel="noopener">Spring Boot + Mybatis 多模块（module）项目的完整搭建教程</a><br><a href="https://mp.weixin.qq.com/s/iWRa6Yk-ai4X3Nk1frjjlA" target="_blank" rel="noopener">Spring Boot 微信点餐开源系统</a><br><a href="https://mp.weixin.qq.com/s/uQJXkT_GTwL3yz5ClPAs9Q" target="_blank" rel="noopener">Spring Boot 整合微信小程序实现登录与增删改查</a><br><a href="https://mp.weixin.qq.com/s/pC0lWQii189f2BBlXTeFZQ" target="_blank" rel="noopener">SpringBoot + MyBatis + MySQL 读写分离实战</a><br><a href="https://mp.weixin.qq.com/s/39rL_i-Fa3k0lvVUZ3GHUg" target="_blank" rel="noopener">Spring Boot + Mybatis + Druid + PageHelper 实现多数据源并分页</a><br><a href="https://mp.weixin.qq.com/s/zv5T1UKAp7UstqXeZ48Mxg" target="_blank" rel="noopener">Spring Boot 骚操作 —— 多数据源 Service 层封装（MySQL + MongoDB + ES）</a></li>
<li><a href="https://mp.weixin.qq.com/s/ARtSvUHK4Io-cb7C8XxU0Q" target="_blank" rel="noopener">Spring Boot 接入支付宝，实战来了！</a></li>
</ul>
<h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><p><a href="https://mp.weixin.qq.com/s/-5HMaAEXV96DBzCVfxQIrg" target="_blank" rel="noopener">SpringBoot操作ES进行各种高级查询（值得收藏）：</a><br><a href="https://mp.weixin.qq.com/s/jMPtQ3vK3zzi9o5YTidKow" target="_blank" rel="noopener">SpringBoot 配置 ELK 环境</a><br><a href="https://mp.weixin.qq.com/s/NnFGwADp2TBkGzPeBerXWA" target="_blank" rel="noopener">ElasticSearch 面试 4 连炮，你顶得住么？</a><br><a href="https://mp.weixin.qq.com/s/nqFZrtHJvgima8EHFQuKoQ" target="_blank" rel="noopener">芋道 Spring Boot Elasticsearch 入门</a><br><a href="https://mp.weixin.qq.com/s/Ne-z24PDVsPIyJQcVb2QsA" target="_blank" rel="noopener">用图讲解 ElasticSearch 搜索原理，你就明白了！</a></p>
<h3 id="ES-Kibana"><a href="#ES-Kibana" class="headerlink" title="ES Kibana"></a>ES Kibana</h3><p><a href="https://mp.weixin.qq.com/s/Ky51TVhvDP0Mv1FlhNGycg" target="_blank" rel="noopener">你还在用命令看日志？快用 Kibana 吧，一张图片胜过千万行日志！:</a></p>
<h3 id="搭建deops平台"><a href="#搭建deops平台" class="headerlink" title="搭建deops平台"></a>搭建deops平台</h3><p><a href="https://mp.weixin.qq.com/s/TMEYuJOKXSSMfqpcjwZLbw" target="_blank" rel="noopener">Linux 最常用命令：简单易学，但能解决 95% 以上的问题</a></p>
<h4 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h4><p><a href="https://mp.weixin.qq.com/s/_Cd-fHIp0LjPuhFk1RkZ8w" target="_blank" rel="noopener">采用jenkins pipeline实现自动构建并部署至k8s</a><br><a href="https://mp.weixin.qq.com/s/_nVmzcWF5Owj4zZtMB93AQ" target="_blank" rel="noopener">实现一个全链路监控平台很难吗？Pinpoint、SkyWalking、Zipkin，哪个实现比较好？</a></p>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p><a href="https://mp.weixin.qq.com/s/NUUcNL99X9R7RLELghuDsA" target="_blank" rel="noopener">后端实践：Nginx日志配置（超详细）</a><br><a href="https://mp.weixin.qq.com/s/SOZcL8BTyXEa2Rf23FgPow" target="_blank" rel="noopener">Nginx + Spring Boot 实现负载均衡</a><br><a href="https://mp.weixin.qq.com/s/AH38y5TI3JHvq0e7n_ZsOg" target="_blank" rel="noopener">就是要让你搞懂 Nginx，这篇就够了！</a></p>
<h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p><a href="https://mp.weixin.qq.com/s/NVx4tLg2m3CjTnbN37YB8w" target="_blank" rel="noopener">牛逼！Docker从入门到上瘾</a><br><a href="https://mp.weixin.qq.com/s/UcTyEwYmWPQfv-Qdpjn-kg" target="_blank" rel="noopener">Docker 部署 SpringBoot 的两种方法，后一种一键部署超好用！</a><br><a href="https://mp.weixin.qq.com/s/-NOTxuFOFdbDtDV8oXhiiw" target="_blank" rel="noopener">真香，GitLab 和 Docker 自动化部署 Spring Boot 应用</a><br><a href="https://mp.weixin.qq.com/s/LvwsQXQjsZY5fcRKb6cJUw" target="_blank" rel="noopener">面试官：你知道 Docker 有哪些优缺点嘛？</a><br><a href="https://mp.weixin.qq.com/s/8pIx7z3lGsr30vhmSov5bw" target="_blank" rel="noopener">Docker+Jenkins+Nginx+Spring Boot 自动化部署项目</a><br><a href="https://mp.weixin.qq.com/s/3rKfsOyoAafJRcP63WvmIQ" target="_blank" rel="noopener">开发提升十倍生产力: IDEA 远程一键部署 Spring Boot 到 Docker</a><br><a href="https://mp.weixin.qq.com/s/OC_G4jL5j8ru78Ctdg66YA" target="_blank" rel="noopener">Docker 搭建「个人网盘」，放弃 Pandownload！</a><br><a href="https://mp.weixin.qq.com/s/0L0ZXI9L-nGkHzESjuO8LA" target="_blank" rel="noopener">Docker 为什么这么牛？</a></p>
<h4 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h4><p><a href="https://mp.weixin.qq.com/s/W8N8BqUsdOgi_oibwhftbQ" target="_blank" rel="noopener">如何从 0 到 1，搭建一个完整的 Kubernetes 集群？</a><br><a href="https://mp.weixin.qq.com/s/cyqxNKPrdp-x8q05PkeWlQ" target="_blank" rel="noopener">一个完整的、全面 k8s 化的集群稳定架构（值得借鉴）</a><br><a href="https://mp.weixin.qq.com/s/jtZ-3qZ2bqnqCxs3QqMOzw" target="_blank" rel="noopener">Kubernetes面试题超详细总结</a><br><a href="https://mp.weixin.qq.com/s/oE7is9KfPcSnGTWu0imFVg" target="_blank" rel="noopener">Kubernetes 集群部署 tomcat容器/Java web应用流程</a><br><a href="https://mp.weixin.qq.com/s/hxTw3c-bnUIQuicUpmjibA" target="_blank" rel="noopener">带着问题学 Kubernetes 架构</a><br><a href="https://mp.weixin.qq.com/s/eCZyeXJ3dLzydwDiKAqZZQ" target="_blank" rel="noopener">如何基于K8s构建下一代DevOps平台？</a></p>
<h3 id="搭建中央仓库"><a href="#搭建中央仓库" class="headerlink" title="搭建中央仓库"></a>搭建中央仓库</h3><p><a href="https://www.cnblogs.com/heyanan/p/10328653.html" target="_blank" rel="noopener">私服仓库的配置比较复杂</a></p>
<h3 id="灰度平台"><a href="#灰度平台" class="headerlink" title="灰度平台"></a>灰度平台</h3><p><a href="https://mp.weixin.qq.com/s/v-Le0OKq1J8RUkPYahLHsw" target="_blank" rel="noopener">手把手教你搭建一个灰度发布环境</a><br><a href="https://mp.weixin.qq.com/s/ZczpkbCt-_ACCg2F3QpBAQ" target="_blank" rel="noopener">灰度发布系统架构设计</a><br><a href="https://mp.weixin.qq.com/s/E-2x6Cfo5OBt4-wJj_qNwg" target="_blank" rel="noopener">CTO 点名要搞个灰度发布系统，不慌！</a><br><a href="https://mp.weixin.qq.com/s/7rVuPaZxANkzm2JD9sreJw" target="_blank" rel="noopener">灰度发布的系统架构设计</a></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a href="https://mp.weixin.qq.com/s/F11nMvdDw929kNS0U05lZA" target="_blank" rel="noopener">给你总结了这些对付幂等性的套路</a><br><a href="https://mp.weixin.qq.com/s/0kzisisJmEDDyEZiWebkVQ" target="_blank" rel="noopener">雪花算法的原理和 Java 实现</a><br><a href="https://mp.weixin.qq.com/s/RgfKawE_Ptyxt_g_KQqCdQ" target="_blank" rel="noopener">手把手带你实战 java.security框架之签名、加密、摘要及证书</a><br><a href="https://mp.weixin.qq.com/s/_NwW38cbpTsVkIqTdnwRtg" target="_blank" rel="noopener">使用雪花id或uuid作为Mysql主键，被老板怼了一顿！</a><br><a href="https://mp.weixin.qq.com/s/nkWPwvHZxfhr-4B3K34akQ" target="_blank" rel="noopener">理解Raft算法，轻松应对分布式容错和一致性：</a><br><a href="https://mp.weixin.qq.com/s/jy-AE7hLjBr53VMX4d9pjA" target="_blank" rel="noopener">分布式关键技术之一致性哈希和虚拟节点原理介绍</a><br><a href="https://mp.weixin.qq.com/s/8uBd7k9mTOCldAlDUg03zg" target="_blank" rel="noopener">韩信大招：一致性哈希</a><br><a href="https://mp.weixin.qq.com/s/v07D1jsVtcztzUb4P8Xd4w" target="_blank" rel="noopener">最短路径问题——迪杰斯特拉算法(Dijkstra)</a><br><a href="https://mp.weixin.qq.com/s/sgrHmuQlQlxIh-0Ska_yIA" target="_blank" rel="noopener">动态规划太难？刷题无数，不如掌握这些套路</a><br><a href="https://mp.weixin.qq.com/s/XR8IMFUOHYic9w_smGSDTw" target="_blank" rel="noopener">因为 BitMap，白白搭进去 8 台服务器。。。</a><br><a href="https://mp.weixin.qq.com/s/7LiYhrBcnL9gro5BPE6jiA" target="_blank" rel="noopener">牛逼哄哄的 BitMap，到底牛逼在哪？</a><br><a href="https://mp.weixin.qq.com/s/9zHxE1kEPMpPqGoCF9AUTA" target="_blank" rel="noopener">面试时写不出排序算法？看这篇就够了</a><br><a href="https://mp.weixin.qq.com/s/sgrHmuQlQlxIh-0Ska_yIA" target="_blank" rel="noopener">动态规划太难？刷题无数，不如掌握这些套路</a></p>
<h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><h3 id="分页处理"><a href="#分页处理" class="headerlink" title="分页处理"></a>分页处理</h3><p><a href="https://mp.weixin.qq.com/s/3miuZuhcXNiNQiYH0vh6Wg" target="_blank" rel="noopener">你还在用分页？试试 MyBatis 流式查询，真心强大！</a><br><a href="https://mp.weixin.qq.com/s/X9w4z0txFwuu_gmCWXB4Mg" target="_blank" rel="noopener">大数据量下 MyBatis PageHelper 分页查询性能问题的解决办法</a></p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p><a href="https://mp.weixin.qq.com/s/QMeogOcmG5TcOnTwvKRtkA" target="_blank" rel="noopener">别乱打日志了，这才是正确的打日志姿势！:</a><br><a href="https://mp.weixin.qq.com/s/uREvWMJ994zR9cIjubF2-w" target="_blank" rel="noopener">从零实现一个日志框架（带源码）：</a><br><a href="https://mp.weixin.qq.com/s/a4tp-YPQmoFfiMHiarkpiQ" target="_blank" rel="noopener">SQL 查找是否”存在”，别再 count 了，很耗费时间的！</a><br><a href="https://mp.weixin.qq.com/s/qGqamCIDJeoze-1GezPDRA" target="_blank" rel="noopener">爽！一个注解，搞定 SpringBoot 操作日志</a><br><a href="https://mp.weixin.qq.com/s/l3UtGejwd2qkZ48LXOVEgw" target="_blank" rel="noopener">可能是全网最全，JAVA日志框架适配、冲突解决方案，可以早点下班了！</a><br><a href="https://mp.weixin.qq.com/s/apXzGqHnWnHqha64oUxRRA" target="_blank" rel="noopener">最牛逼的 Java 日志框架，性能无敌，横扫所有对手！【文末送书】</a><br><a href="https://mp.weixin.qq.com/s/f52Af50h9xVBOztJD8IHdQ" target="_blank" rel="noopener">Slf4j 包老冲突，每次排查半天，是什么原因？怎么解决？</a><br><a href="https://mp.weixin.qq.com/s/cwIVRGzQtk_kD-nKbZrenQ" target="_blank" rel="noopener">日志框架选型，Logback 还是 Log4j2？</a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/z_iPIXRqDA9wFpCmNfRl9Q" target="_blank" rel="noopener">数据库连接池到底应该设多大？</a><br><a href="https://mp.weixin.qq.com/s/Jeqrw3mLpV2XU9K8t5aL4Q" target="_blank" rel="noopener">面试题：Java 8 中 HashMap 到底有啥不同？</a><br><a href="https://mp.weixin.qq.com/s/MSeHKctbw97XO2ZwozzbHA" target="_blank" rel="noopener">Synchronized 的一个点，面试官可能都记错了</a><br><a href="https://mp.weixin.qq.com/s/QlEM9WdxXfe-CRq6Akw0Pw" target="_blank" rel="noopener">面试：你知道 Java 中的回调机制吗？</a><br><a href="https://mp.weixin.qq.com/s/3JScRAiKF3hzE8u-vNNhXQ" target="_blank" rel="noopener">面试官：你能告诉我一个请求过来，Spring MVC 是如何找到正确的 Controller 的？</a><br><a href="https://mp.weixin.qq.com/s/NO19A_6Zg3v_Jz1wt-TSFg" target="_blank" rel="noopener">面试被问“红黑树”，我一脸懵逼。。。</a><br><a href="https://mp.weixin.qq.com/s/3oMxvO3mvSfIoj6kOX-ZyA" target="_blank" rel="noopener">Java面试必问：ThreadLocal终极篇 淦！</a></li>
</ul>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p><a href="https://mp.weixin.qq.com/s/qfpG4z3DRNjuzaWkMSrSvg" target="_blank" rel="noopener">说实话，Hibernate 和 MyBatis 哪个更好用？</a><br><a href="https://mp.weixin.qq.com/s/jg0Os6ZhiP7KwFd6LLkZ1A" target="_blank" rel="noopener">8张图，5大组件！了解MySQL查询语句执行过程。</a><br><a href="https://mp.weixin.qq.com/s/ci2CkKeh7H94ia8w9wYpNg" target="_blank" rel="noopener">MyBatis 动态 SQL（认真看看， 以后写 SQL 就爽多了）</a><br><a href="https://mp.weixin.qq.com/s/RjRzacdmx3DMHlhjj1GM3g" target="_blank" rel="noopener">超全MyBatis动态代理详解！（绝对干货）</a><br><a href="https://mp.weixin.qq.com/s/dU8a_hjQ9QsEaHEugBBsvg" target="_blank" rel="noopener">Spring Boot 中引入 MyBatis Plus 的常规流程</a><br><a href="https://mp.weixin.qq.com/s/a_FgCe-FJhRzW0sioANZzQ" target="_blank" rel="noopener">干掉mapper.xml！MyBatis新特性动态SQL真香！</a><br><a href="https://mp.weixin.qq.com/s/UqgXw0qOW1H1-Dqh5NtueA" target="_blank" rel="noopener">MyBatis 的执行流程，写得太好了！</a><br><a href="https://mp.weixin.qq.com/s/3JM0OftyZGVUBZyQoFRk4A" target="_blank" rel="noopener">如何让 Mybatis 自动生成代码，提升开发效率</a><br><a href="https://mp.weixin.qq.com/s/TfGINunRi_PLNDctw3VRjQ" target="_blank" rel="noopener">MyBatis Plus 为啥这么牛？</a><br><a href="https://mp.weixin.qq.com/s/et5KsFEOpC2Go_h33wsvdQ" target="_blank" rel="noopener">史上最全的SpringBoot 中引入 MyBatisPlus 的常规流程|干货</a><br><a href="https://mp.weixin.qq.com/s/fYrSQUjv30--kDxEG5SScA" target="_blank" rel="noopener">MyBatis PageHelper 最佳实践</a><br><a href="https://mp.weixin.qq.com/s/cplN0umHRonaXaJDI4LwCA" target="_blank" rel="noopener">浅谈 mybatis 如何半自动化解耦</a><br><a href="www.cnblogs.com/wangjiming/p/10384975.html">浅谈 mybatis 如何半自动化解耦</a><br><a href="https://mp.weixin.qq.com/s/sIMTK2JDqM4o06htPS981A" target="_blank" rel="noopener">一起来看看 Mybatis 中使用的 9 种设计模式！</a><br><a href="https://mp.weixin.qq.com/s/RWnmRhrmvK7_VJnygCSK7w" target="_blank" rel="noopener">Spring Boot Mybatis 搞反向工程，太方便咯。。</a><br><a href="https://mp.weixin.qq.com/s/YKoz4oTzoqVjo96l6vf5eA" target="_blank" rel="noopener">MyBatis 的工作原理，你了解过吗？</a><br><a href="https://mp.weixin.qq.com/s/hwbzbMz-Yavvq2CSDBr2Cg" target="_blank" rel="noopener">牛逼！在IDEA里搞Spring Boot Mybatis反向工程，太爽咯～</a><br><a href="https://mp.weixin.qq.com/s/D59V65phO_-KpxhF0px9qw" target="_blank" rel="noopener">Spring Boot Mybatis 搞反向工程，太方便咯。。</a><br><a href="https://mp.weixin.qq.com/s/TZ9-DY4q5E55Wi19VrSPoQ" target="_blank" rel="noopener">大佬的Mybatis-Plus使用技巧，带你避“坑”，实在太火了~</a><br><a href="https://mp.weixin.qq.com/s/PhMO7wufdyJP7b7_cWKrkg" target="_blank" rel="noopener">MyBatis Plus 常用 API 全套教程，看完没有不懂的</a></p>
<h3 id="Java-NIO-BIO"><a href="#Java-NIO-BIO" class="headerlink" title="Java NIO/BIO"></a>Java NIO/BIO</h3><p><a href="https://mp.weixin.qq.com/s/YIcXaH7AWLJbPjnTUwnlyQ" target="_blank" rel="noopener"> NIO模型演变及分析</a><br><a href="https://blog.csdn.net/zhangdx001/article/details/106737419" target="_blank" rel="noopener">浅谈过滤器与拦截器与切面</a><br><a href="https://mp.weixin.qq.com/s/341JER0azceY0b_J6lIuww" target="_blank" rel="noopener">一步一图，带你走进 Netty 的世界！</a><br><a href="https://mp.weixin.qq.com/s/Csgk3I6IvBU5Qr91XOkOPg" target="_blank" rel="noopener">虎牙二面：聊聊你对 Java “零拷贝”的理解？</a><br><a href="https://mp.weixin.qq.com/s/0XVkeR96rdpnaDU-WACbHw" target="_blank" rel="noopener">什么是NIO？NIO的原理是什么机制？</a><br><a href="https://mp.weixin.qq.com/s/CRd3-vRD7xwoexqv7xyHRw" target="_blank" rel="noopener">四图，读懂 BIO、NIO、AIO、多路复用 IO 的区别</a><br><a href="https://mp.weixin.qq.com/s/F8gHzHm-BruJzof2-NlONg" target="_blank" rel="noopener">面试官：什么是 NIO？NIO 的原理是什么机制？</a><br><a href="https://mp.weixin.qq.com/s/LnWyqknOIesC7bavfpIPQg" target="_blank" rel="noopener">为什么说Netty是性能之王，因为它用了 Reactor 模型啊</a><br><a href="https://mp.weixin.qq.com/s/v029YALohmHEZ-i55u-qyw" target="_blank" rel="noopener">图解 | 深入理解高性能网络开发路上的绊脚石 - 同步阻塞网络 IO</a><br><a href="https://mp.weixin.qq.com/s/Ok7SIROXu1THUbWsFu-UYw" target="_blank" rel="noopener">你管这破玩意叫 IO 多路复用？</a></p>
<h3 id="Kafka复习"><a href="#Kafka复习" class="headerlink" title="Kafka复习"></a>Kafka复习</h3><p><a href="https://mp.weixin.qq.com/s/Z2VWLTOOE9dy3XSG_p3k9w" target="_blank" rel="noopener">面试问：Kafka 为什么速度那么快？</a><br><a href="https://zhuanlan.zhihu.com/p/92590719" target="_blank" rel="noopener">从基础到深度，带你吃透Kafka</a><br><a href="https://www.cnblogs.com/rickiyang/category/1487719.html" target="_blank" rel="noopener">kafka消息系列</a><br><a href="https://mp.weixin.qq.com/s/oqfxAzZgccBqK0_4NQHmhQ" target="_blank" rel="noopener">Kafka都没整明白，还敢去面试？</a><br><a href="https://mp.weixin.qq.com/s/zCLlRcHGglfI_HagpyTEjg" target="_blank" rel="noopener">从面试角度一文学完 Kafka</a><br><a href="https://mp.weixin.qq.com/s/4sgw9GvmnDc4SGcTH_IIvA" target="_blank" rel="noopener">Kafka 事务实现原理</a><br><a href="https://mp.weixin.qq.com/s/kX0iuGAIr1sn5i2FN6O7TQ" target="_blank" rel="noopener">支持百万级TPS，Kafka是怎么做到的？答案藏在这10张图里</a><br><a href="https://mp.weixin.qq.com/s/lQS7ShqmB1pwmeJY5JyJLg" target="_blank" rel="noopener">面试官问：Kafka 会不会丢消息？怎么处理的?</a><br><a href="https://mp.weixin.qq.com/s/lVa9TVIhOKm7AfXPbvU6cA" target="_blank" rel="noopener">Netty、Kafka 中的零拷贝技术到底有多牛?</a><br><a href="https://mp.weixin.qq.com/s/cEDpK20RugVqfjJb-TNJYg" target="_blank" rel="noopener">原来这才是 Kafka！（多图+深入）</a><br><a href="https://www.cnblogs.com/rickiyang/p/13265043.html" target="_blank" rel="noopener">零拷贝(Zero-copy) 浅析及其应用</a><br><a href="https://mp.weixin.qq.com/s/cifu9h1GKYuColGmJ99q8w" target="_blank" rel="noopener">你能说出 Kafka 这些原理吗</a><br><a href="https://mp.weixin.qq.com/s/9vIy6R8IMRU2KoIMzhHHhw" target="_blank" rel="noopener">Kafka是靠什么机制保持高可靠，高可用的？</a><br><a href="https://mp.weixin.qq.com/s/KbQeseskB0YIfNLdSp0urg" target="_blank" rel="noopener">面试问：Kafka 为什么速度那么快？</a><br><a href="https://mp.weixin.qq.com/s/p_T7xCi67KEhtu5-4AwNIw" target="_blank" rel="noopener">仅需 3 分钟，你就能明白 Kafka 的工作原理，那是不可能的</a><br><a href="https://mp.weixin.qq.com/s/adoZJ5p0DkInmc2gSGR9Sg" target="_blank" rel="noopener">Kafka 基本原理（8000 字小结）</a><br><a href="https://mp.weixin.qq.com/s/2lQ9FVjeG2iwh_CgcW1syw" target="_blank" rel="noopener">大白话 + 13 张图解 Kafka</a><br><a href="https://mp.weixin.qq.com/s/5WBFKgBuY7hMX0yRkDIveg" target="_blank" rel="noopener">Kafka 为什么这么快？</a><br><a href="https://mp.weixin.qq.com/s/VfkngOymFgNhY77RQV_lbw" target="_blank" rel="noopener">如何基于 Canal 和 Kafka，实现 MySQL 的 Binlog 近实时同步？</a><br><a href="https://mp.weixin.qq.com/s/94lighg5iLmBl1CHJIsaKQ" target="_blank" rel="noopener">大白话认识 Kafka 背后优秀的架构设计</a><br><a href="https://mp.weixin.qq.com/s/t3XPzDRL8x7ljfMJHaaSBw" target="_blank" rel="noopener">Kafka如何做到1秒处理1500万条消息？</a><br><a href="https://mp.weixin.qq.com/s/YGQSEqzg54zZ9-nd823p3A" target="_blank" rel="noopener">面试官问：Kafka 会不会丢消息？怎么处理的?</a><br><a href="https://mp.weixin.qq.com/s/aElO_L2HpYvZRuxxbYlqJw" target="_blank" rel="noopener">我用kafka两年踩过的一些非比寻常的坑</a></p>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p><a href="https://mp.weixin.qq.com/s/9Vs7HiBfJnuNkeHDjrUafQ" target="_blank" rel="noopener">RocketMQ 消息丢失场景分析及如何解决！</a><br><a href="https://mp.weixin.qq.com/s/BaZxnOb5yed4C-qj7ii-ZA" target="_blank" rel="noopener">从年末生产故障解锁RocketMQ集群部署的最佳实践</a></p>
<h3 id="对比Mq"><a href="#对比Mq" class="headerlink" title="对比Mq"></a>对比Mq</h3><p><a href="https://mp.weixin.qq.com/s/CfqosfVTMqtCX3L4a1MDzQ" target="_blank" rel="noopener">Kafka 与 RocketMQ 的性能大对比！</a><br><a href="https://mp.weixin.qq.com/s/l_4XzAWFubTUcwpRjQ8Jig" target="_blank" rel="noopener">Redis、Kafka 和 Pulsar 消息队列对比</a></p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><a href="https://mp.weixin.qq.com/s/yZLUu6I1KefIm3kLx3Zsxg" target="_blank" rel="noopener">共享锁、排他锁、互斥锁、悲观锁、乐观锁、行锁、表锁、页面锁、不可重复读、丢失修改、读脏数据</a><br><a href="https://mp.weixin.qq.com/s/E8qOcBz5GbsUoIvyCf2qcw" target="_blank" rel="noopener">死磕 Synchronized 底层实现</a><br><a href="https://mp.weixin.qq.com/s/kPMCWckMXTjNhVgRWn7DvQ" target="_blank" rel="noopener">Spring 中的重试机制，简单、实用！</a><br><a href="https://mp.weixin.qq.com/s/IEd8oP7j_4IWZ0DShXiN4A" target="_blank" rel="noopener">这六个 MySQL 死锁案例，能让你理解死锁的原因！</a><br><a href="https://mp.weixin.qq.com/s/AZj4j0YOuacAmcS1RexkXg" target="_blank" rel="noopener">8000字 | 32 张图 | 一文搞懂事务+隔离级别+阻塞+死锁</a><br><a href="https://mp.weixin.qq.com/s/v1XgT2X4IuF3_WNqeUVhVA" target="_blank" rel="noopener">全网最细：17张图带你秒杀synchronized关键字</a></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><a href="https://mp.weixin.qq.com/s/hxTw3c-bnUIQuicUpmjibA" target="_blank" rel="noopener">如何画出优秀的软件架构图？</a><br><a href="https://mp.weixin.qq.com/s/NtIE0eznUAbXgKwZN83TvA" target="_blank" rel="noopener">手把手教你画架构图，看一次就会了！</a><br><a href="https://mp.weixin.qq.com/s/NtIE0eznUAbXgKwZN83TvA" target="_blank" rel="noopener">厉害了，淘宝千万并发，14 次架构演进…</a><br><a href="https://mp.weixin.qq.com/s/594UJgs4SKLqVXPCYmKTCQ" target="_blank" rel="noopener">今日头条技术架构分析</a><br><a href="https://mp.weixin.qq.com/s/lj7l687k50HE8vTfwZOT3w" target="_blank" rel="noopener">服务端如何防止订单重复支付！</a><br><a href="https://mp.weixin.qq.com/s/HnAfn3yM7uo5Vnego94AcA" target="_blank" rel="noopener">短信验证码的登录流程</a><br><a href="https://mp.weixin.qq.com/s/36z4UMVH_YUj7vIcA79jag" target="_blank" rel="noopener">手写一个迷你版的 Tomcat 猫</a><br><a href="https://mp.weixin.qq.com/s/93887BFjanrS6EB9fCRnFQ" target="_blank" rel="noopener">Tomcat 架构原理解析到架构设计借鉴</a><br><a href="https://mp.weixin.qq.com/s/YCElKLSQaM-UeB0drGiOYw" target="_blank" rel="noopener">如何保证缓存与数据库的双写一致性？</a><br><a href="https://mp.weixin.qq.com/s/-EErLaPPbO9gItIzefjTuw" target="_blank" rel="noopener">亿级流量高并发场景下，如何保证缓存与数据库的双写一致性？</a><br><a href="https://mp.weixin.qq.com/s/i5Zp6nd0beCOHPEZUpmMNg" target="_blank" rel="noopener">微信和淘宝扫码登录背后的实现原理</a></p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul>
<li><a href="http://c.biancheng.net/view/4497.html" target="_blank" rel="noopener">Spring体系</a></li>
<li><a href="https://thinkingcao.blog.csdn.net/category_9281035_4.html" target="_blank" rel="noopener">收费博客:SpringBoot2.x架构教程</a><br><a href="https://mp.weixin.qq.com/s/9DuadYAsY_xJwOZEPR9aLQ" target="_blank" rel="noopener">Java 反射：框架设计的灵魂</a></li>
</ul>
<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p><a href="https://mp.weixin.qq.com/s/n3SMe7co5S2cVlfefx1m4A" target="_blank" rel="noopener">Spring 常犯的十大错误，打死都不要犯！</a><br><a href="https://mp.weixin.qq.com/s/cKgoSqIk97M1M9Q-gBOLBw" target="_blank" rel="noopener">手写一个 web 服务器！</a><br><a href="https://mp.weixin.qq.com/s/jjJcPRDpkbQ8XDOWpE4Tvg" target="_blank" rel="noopener">Spring 的核心思想，总结得非常好！</a></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/gbNQHXENUV1_h5a9nvS1Hg" target="_blank" rel="noopener">面试官：给我说一下 Spring MVC 拦截器的原理？</a></li>
<li><a href="https://mp.weixin.qq.com/s/cSTX_BnpuPowHpEqpKh98w" target="_blank" rel="noopener">面试官：你分析过 Spring MVC 源码吗？不会就算了~</a><br><a href="https://mp.weixin.qq.com/s/Njc91B8EOGOMg_d0x0Ybsw" target="_blank" rel="noopener">浅谈 SpringMVC 执行过程</a><h4 id="AOP-IOC"><a href="#AOP-IOC" class="headerlink" title="AOP/IOC"></a>AOP/IOC</h4><a href="https://mp.weixin.qq.com/s/nVhBrBO4cWUYo25DrXYlgA" target="_blank" rel="noopener">徒手撸一个简单的 Spring IOC</a><br><a href="https://mp.weixin.qq.com/s/zQGnvBZcKPxxbkaGAfbyPw" target="_blank" rel="noopener">面试系列 - Spring和Spring IOC总结（一）</a><br><a href="https://mp.weixin.qq.com/s/XJiyLFXoBK3OyNvQmJwPPg" target="_blank" rel="noopener">听说 Spring AOP 有坑？那就来踩一踩</a><br><a href="https://mp.weixin.qq.com/s/mbZ9RJKpGqfDTAVU-p7kaQ" target="_blank" rel="noopener">Spring 如何实现 AOP，请不要再说 cglib 了！</a><br><a href="https://mp.weixin.qq.com/s/Sqf5TYwQ859byq9eu0znCA" target="_blank" rel="noopener">9,000+ 字，彻底征服 Spring AOP！</a></li>
</ul>
<h4 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h4><p><a href="https://mp.weixin.qq.com/s/B2qYiI51HSwvw7mA6FZ7rg" target="_blank" rel="noopener">一文搞定 Spring Bean 的创建全过程！</a><br><a href="https://mp.weixin.qq.com/s/eYqsvEvwBsnmgDlKVGLLLg" target="_blank" rel="noopener">Spring的Bean生命周期，11 张高清流程图及代码，深度解析</a><br><a href="https://mp.weixin.qq.com/s/yk0SmHljpmuVKSRKJVzf6w" target="_blank" rel="noopener">Spring 事务用法示例与实现原理</a><br><a href="https://www.jb51.net/article/125846.htm" target="_blank" rel="noopener">详解Spring 中如何控制2个bean中的初始化顺序</a><br><a href="https://www.cnblogs.com/moxiaotao/p/9353776.html" target="_blank" rel="noopener">web.xml中监听器如何顺序加载</a><br><a href="https://blog.csdn.net/neweastsun/article/details/78775371" target="_blank" rel="noopener">使用Spring @DependsOn控制bean加载顺序</a><br><a href="http://c.biancheng.net/view/4271.html" target="_blank" rel="noopener">Spring CGLlB动态代理（附带实例）</a><br><a href="https://www.pianshen.com/article/15631453341/" target="_blank" rel="noopener">springboot改变bean的加载顺序【提供两种有效的方法】</a><br><a href="https://blog.csdn.net/yu_kang/article/details/88530016" target="_blank" rel="noopener">CGLIB动态代理源码分析</a></p>
<h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><p><a href="https://mp.weixin.qq.com/s/W4mxZrztMk57j31C_tjaxA" target="_blank" rel="noopener">面试官问：知道DDoS攻击吗？大概讲讲它的原理</a><br><a href="https://mp.weixin.qq.com/s/bRo7ypLsuSI4_5ck1VSYaQ" target="_blank" rel="noopener">13 张图解 Java 中的内存模型，快上车！</a><br><a href="https://mp.weixin.qq.com/s/HavvuyCLi_QZy5V-jr_Syw" target="_blank" rel="noopener">Java内存模型与指令重排</a><br><a href="https://mp.weixin.qq.com/s/xfixkZRCuPKlcEwsAdlU6Q" target="_blank" rel="noopener">宝贝，来，讲讲 Spring 事务有哪些坑?</a><br><a href="https://mp.weixin.qq.com/s/fuqQTnCU80QsCnP_-g5dYQ" target="_blank" rel="noopener">面试官问：为什么 Java 线程没有Running状态？我懵了</a><br><a href="https://mp.weixin.qq.com/s/WWLtxxox5Oz2N6yykuC34w" target="_blank" rel="noopener">突然就懵了！面试官问我：线程池中多余的线程是如何回收的？</a><br><a href="https://mp.weixin.qq.com/s/JJ7lojbCGG0Da_QGAH1Cjg" target="_blank" rel="noopener">看完这篇还不懂高并发中的线程与线程池，你来打我（20张图深度剖析）)</a><br><a href="https://mp.weixin.qq.com/s/_iVBP84X1KRcUkumqyk38Q" target="_blank" rel="noopener">一款直击痛点的优秀 HTTP 框架，让我超高效率完成了和第三方接口的对接</a><br><a href="https://mp.weixin.qq.com/s/tN5xPnuZhKnL2j74fu2zfw" target="_blank" rel="noopener">恕我直言，HttpClient 你不一定会用</a><br><a href="https://mp.weixin.qq.com/s/aauYOG4zOh2xzUJjgAdC2g" target="_blank" rel="noopener">踩坑了，JDK8中HashMap依然会产生死循环问题！</a><br><a href="https://mp.weixin.qq.com/s/wjGbXhOGtG_kB8vZm-ZJkQ" target="_blank" rel="noopener">JAVA并发十二连招，你能接住吗？</a><br><a href="https://mp.weixin.qq.com/s/7lvU8gp1rE2Ijw9n9w2MJQ" target="_blank" rel="noopener">新一代垃圾回收器ZGC的探索与实践</a></p>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p><a href="https://mp.weixin.qq.com/s/yTy2GOOctMh6-MvrARmacw" target="_blank" rel="noopener">保姆级教程，手把手教你实现一个SpringBoot的starter</a><br><a href="https://mp.weixin.qq.com/s/i_83OM4cVlgysKIvlCBhhA" target="_blank" rel="noopener">“RPC 好，还是 RESTful 好？” 不要选错了！</a><br><a href="https://www.cnblogs.com/rickiyang/p/12153070.html" target="_blank" rel="noopener">微服务全流程分析</a><br><a href="https://mp.weixin.qq.com/s/2OgPEolWy2QePUudRsgJYA" target="_blank" rel="noopener">从 0 开始手写一个 RPC 框架，轻松搞定</a><br><a href="https://mp.weixin.qq.com/s/gbSW3X3J1trs-5pKSBk2YQ" target="_blank" rel="noopener">SpringBoot注解大全，收藏一波！！！</a><br><a href="https://mp.weixin.qq.com/s/XN49x4PUHz-1ZekrzE_POA" target="_blank" rel="noopener">Spring Validation最佳实践及实现原理</a><br><a href="https://mp.weixin.qq.com/s/tXm4GqUPyhkFHJeAMKmiqw" target="_blank" rel="noopener">SpringBoot 启动时让方法自动执行的几种实现方式</a><br><a href="https://mp.weixin.qq.com/s/375N5X89t6DasUflvvLOxQ" target="_blank" rel="noopener">五分钟说清楚 Spring Boot的自动配置原理~超级干的货！</a><br><a href="https://mp.weixin.qq.com/s/UcTyEwYmWPQfv-Qdpjn-kg" target="_blank" rel="noopener">Spring Boot 启动扩展点超详细总结，再也不怕面试官问了！</a><br><a href="https://mp.weixin.qq.com/s/Oitl9Hed10y_FCS2nbW6TA" target="_blank" rel="noopener">Spring Boot 异步请求和异步调用，一文搞定！</a><br><a href="https://mp.weixin.qq.com/s/9YDLIcF7J6pQ91o-lipL6w" target="_blank" rel="noopener">深入理解 SpringBoot 启动机制（starter 机制）</a><br><a href="https://mp.weixin.qq.com/s/44n9wqRnRP7ot85K3Taaeg" target="_blank" rel="noopener">Spring 自定义注解从入门到精通</a><br><a href="https://mp.weixin.qq.com/s/PTaKbJdTBVoJ3jHf2fdd-Q" target="_blank" rel="noopener">为什么阿里规定需要在事务注解 @Transactional 中指定 rollbackFor？</a><br><a href="https://mp.weixin.qq.com/s/044UVaCinUdGbof-SI-3XA" target="_blank" rel="noopener">TCP 协议面试灵魂10问，建议收藏~</a><br><a href="https://mp.weixin.qq.com/s/RIIICQczcrWUdqR1iV40vA" target="_blank" rel="noopener">Spring Boot 优雅停止服务的几种方法</a></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/PaBz1ggS7aPdvlzaOYc5_A" target="_blank" rel="noopener">springboot面试杀手锏-自动配置原理</a><br><a href="https://mp.weixin.qq.com/s/BAx6NnACNV68hBzekY2aCA" target="_blank" rel="noopener">Spring Boot 无侵入式 实现 API 接口统一 JSON 格式返回</a><br><a href="https://mp.weixin.qq.com/s/0jjB-ZC3p3cV3uIW0ymRBw" target="_blank" rel="noopener">Spring Boot 配置文件放在 jar 外部</a></li>
</ul>
<h4 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h4><p><a href="https://mp.weixin.qq.com/s/vfe51ZOW2h8HRXtfL6sEYQ" target="_blank" rel="noopener">Spring Boot 中 @EnableXXX 注解的驱动逻辑</a></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/_qkYwMEj0hMvAUBqD7pcDQ" target="_blank" rel="noopener">@Component，@Service 等注解是如何被解析的</a><br><a href="https://mp.weixin.qq.com/s/eRzW-yzu45bcKJKejCw8HQ" target="_blank" rel="noopener">SpringBoot @Value 读取配置，太强大了！</a><br><a href="https://www.cnblogs.com/wl20200316/p/12579982.html" target="_blank" rel="noopener">spring中@Configuration注解的作用</a><br><a href="https://mp.weixin.qq.com/s/6wAD7fN1hUjQR-0twvvaTw" target="_blank" rel="noopener">Spring Boot 最最最常用的注解梳理</a></li>
</ul>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/_uEYIJUnaj59g2xJRrbbrg" target="_blank" rel="noopener">徒手撸了一个RPC框架，理解更透彻了，代码已上传github，自取~</a><br><a href="https://mp.weixin.qq.com/s/4Vv3JinskK3nXS_wxpon4Q" target="_blank" rel="noopener">从零搭建 Spring Cloud 服务（超级详细）</a><br><a href="https://mp.weixin.qq.com/s/vbM3knP15LPrMD6eIOKm3A" target="_blank" rel="noopener">微服务架构最强讲解，那叫一个通俗易懂！</a><br><a href="https://mp.weixin.qq.com/s/dU8a_hjQ9QsEaHEugBBsvg" target="_blank" rel="noopener">这 12 张手绘图，让我彻底搞懂了微服务架构！</a><br><a href="https://mp.weixin.qq.com/s/UHUQwiqYqyNjlHjN2jbqAg" target="_blank" rel="noopener">19张图带你梳理SpringCloud体系中的重要技术点！</a><br><a href="https://mp.weixin.qq.com/s/NVKtxuud2ARFw5S89ty35w" target="_blank" rel="noopener">10分钟说透Saga分布式事务</a><br><a href="https://mp.weixin.qq.com/s/MTk6WF161Ob8sBdpnboFgg" target="_blank" rel="noopener">40张图看懂分布式追踪系统原理及实践</a><br><a href="https://mp.weixin.qq.com/s/T_XaGbDzKmwFSXSyeFo__g" target="_blank" rel="noopener">谈谈几个 Spring Cloud 常见面试题及答案</a><br><a href="https://mp.weixin.qq.com/s/3LK8vcvIdkBw7eXDBReygw" target="_blank" rel="noopener">分布式 Session 解决方案</a><br><a href="https://mp.weixin.qq.com/s/6YlBB7RRwftT3b4ypTuvoQ" target="_blank" rel="noopener">花一个周末，掌握 SpringCloud Ribbon 负载均衡原理</a><br><a href="https://mp.weixin.qq.com/s/JypXG4arZVRvgf6tzAl3nw" target="_blank" rel="noopener">芋道 Spring Cloud Alibaba 介绍</a><br><a href="https://www.cnblogs.com/rickiyang/category/1583046.html" target="_blank" rel="noopener">Spring Cloud 大全学习</a><br><a href="https://mp.weixin.qq.com/s/T_XaGbDzKmwFSXSyeFo__g" target="_blank" rel="noopener">谈谈几个 Spring Cloud 常见面试题及答案</a><br><a href="https://mp.weixin.qq.com/s/sV8ytiuYQq1HYUCSuogkow" target="_blank" rel="noopener">喜马拉雅自研 API 网关架构实践</a><br><a href="https://mp.weixin.qq.com/s/eOWCgNGHsRIJplVLK3MOMA" target="_blank" rel="noopener">RPC 实现以及相关学习</a><br><a href="https://mp.weixin.qq.com/s/wMTFQmQste0DwHR8FDgR1g" target="_blank" rel="noopener">【性能优化之道】每秒上万并发下的Spring Cloud参数优化实战</a><br><a href="https://mp.weixin.qq.com/s/krC3CWbmidxVtTnT3Kb9Jw" target="_blank" rel="noopener">我们公司使用了 6 年的分布式锁，很是牛逼啊！</a><br><a href="https://mp.weixin.qq.com/s/7QcqATv5neKmwrCvgTYVLg" target="_blank" rel="noopener">Java 分布式 RPC 框架性能大比拼，Dubbo 排第几？</a><br><a href="https://mp.weixin.qq.com/s/JPBavLP6ZPcfOktVM8RnsA" target="_blank" rel="noopener">微服务面试必问的Dubbo，这么详细还怕自己找不到工作？</a><br><a href="https://mp.weixin.qq.com/s/-avqw6F1MjWM0NirRdeeTQ" target="_blank" rel="noopener">史上最便捷搭建 Zookeeper 的方法！</a><br><a href="https://mp.weixin.qq.com/s/_gFtOqKbT7xQuoMB6m9apg" target="_blank" rel="noopener">ZooKeeper 不行了？居然被 Kafka 抛弃了！</a><br><a href="https://mp.weixin.qq.com/s/c9jipQbUhFbGbwFK3L-QSA" target="_blank" rel="noopener">6 种常见分布式唯一ID生成策略及它们的优缺点对比</a><br><a href="https://mp.weixin.qq.com/s/bqx_zc24DyoxupjnsiSsPw" target="_blank" rel="noopener">七种分布式事务的解决方案，一次讲给你听！</a></li>
</ul>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p><a href="https://mp.weixin.qq.com/s/E5DtyIkTVZ6rdNTexKoH5A" target="_blank" rel="noopener">一文带你 API 网关从入门到放弃</a><br><a href="https://mp.weixin.qq.com/s/V0RqE-yzoVFI2ij_bZXUIQ" target="_blank" rel="noopener">全网最详细的一篇 SpringCloud 总结</a><br><a href="https://mp.weixin.qq.com/s/FG4Vik6cHhIFatxkiL8sjQ" target="_blank" rel="noopener">关于Spring Cloud Zuul 那些“不能说的秘密”！</a><br><a href="https://mp.weixin.qq.com/s/Ai0nwDmDzv7qMkDE7HuLBg" target="_blank" rel="noopener">后端接口如何提高性能？从 MySQL、ES、HBASE 等技术一起探讨下！</a><br><a href="https://mp.weixin.qq.com/s/VvUHcFsiV0kqsSZQeVBjZg" target="_blank" rel="noopener">为什么微服务一定要有 API 网关？</a><br><a href="https://mp.weixin.qq.com/s/uE6kRWpY3s6fqPaCv_toPw" target="_blank" rel="noopener">阿里终面：如何设计一个高性能网关？</a></p>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p><a href="https://mp.weixin.qq.com/s/232V3xHuUZlkHt-nIFVKhg" target="_blank" rel="noopener">对于注册中心，ZooKeeper、Eureka 哪个更合适？</a><br><a href="https://mp.weixin.qq.com/s/jTvE_u3_YDuN4Vxs4C2AVA" target="_blank" rel="noopener">为啥这么多公司用 ZooKeeper？它到底解决了什么问题？</a><br><a href="https://mp.weixin.qq.com/s/VmbQNoG7WH--9_akn1DZXQ" target="_blank" rel="noopener">用大白话给你解释Zookeeper的选举机制</a><br>[推荐<a href="https://mp.weixin.qq.com/s/I7KJeudEk1KX2LORybnNzg" target="_blank" rel="noopener">史上最便捷搭建Zookeeper服务器的方法</a><br><a href="https://mp.weixin.qq.com/s/BAZiyIAnUOty2-BdV7GE7g" target="_blank" rel="noopener">面试官问：ZooKeeper是强一致的吗？怎么实现的？</a><br><a href="https://mp.weixin.qq.com/s/u-V_ymZoCUlmfzYYJdGsVg" target="_blank" rel="noopener">阿里巴巴为什么不用 ZooKeeper 做服务发现？</a><br><a href="https://mp.weixin.qq.com/s/g32pNdRyaG0fnwoByEAiXA" target="_blank" rel="noopener">双11狂欢的背后：微服务注册中心如何承载大型系统的千万级访问？？</a></p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="MySQL原理"><a href="#MySQL原理" class="headerlink" title="MySQL原理"></a>MySQL原理</h3><p><a href="https://www.cnblogs.com/rickiyang/p/13473854.html" target="_blank" rel="noopener">MYSQL 整体架构浅析</a><br><a href="https://mp.weixin.qq.com/s/lE7FRvjVYS21EEeavoH8Tg" target="_blank" rel="noopener">3天，把MySQL索引、事务、分库分表撸干净了！</a><br><a href="https://blog.csdn.net/qq_41999455/article/details/106161484" target="_blank" rel="noopener">MySQL事务实现原理之Redo Log</a><br><a href="https://www.cnblogs.com/rickiyang/p/13704868.html" target="_blank" rel="noopener">分布式事务</a><br><a href="https://mp.weixin.qq.com/s/eYpqXpxjO7-svdlpxC8JYQ" target="_blank" rel="noopener">MySQL 用得好好的，为什么要转 Elasticsearch?</a><br><a href="https://mp.weixin.qq.com/s/AbiYMbDUJsMWK-_g0mFNwg" target="_blank" rel="noopener">面试官：能说一说Mysql缓存池吗？</a><br><a href="https://mp.weixin.qq.com/s/JuHelQ1kXsXcQfJviPuwlA" target="_blank" rel="noopener">头条二面：你们公司怎么处理 MySQL 的 Binlog 日志？</a><br><a href="https://mp.weixin.qq.com/s/AgQeeqYdevlgy_bdbByAhg" target="_blank" rel="noopener">MySQL分页场景（limit,offset）为什么会慢？</a><br><a href="https://mp.weixin.qq.com/s/HH_8Go3hWTnHqdtXS0g92Q" target="_blank" rel="noopener">事务注解 @Transactional 失效的3种场景及解决办法</a><br><a href="https://mp.weixin.qq.com/s/PRkye2jozxn1bfojJ-IhMw" target="_blank" rel="noopener">Mybatis 框架下 SQL 注入攻击的 3 种方式，真是防不胜防！</a></p>
<h3 id="读写分离主从同步"><a href="#读写分离主从同步" class="headerlink" title="读写分离主从同步"></a>读写分离主从同步</h3><p><a href="https://mp.weixin.qq.com/s/0ORvPNFErpY3YBw_8PdysQ" target="_blank" rel="noopener">MySQL 与 Redis 缓存的同步方案</a><br><a href="https://mp.weixin.qq.com/s/C_6uAARwe8zG7pStEqxpfA" target="_blank" rel="noopener">面试官: 为什么在系统中不推荐双写?</a><br><a href="https://www.cnblogs.com/rickiyang/p/13856388.html" target="_blank" rel="noopener">MySQL 主从复制原理不再难</a><br><a href="https://mp.weixin.qq.com/s/rHp0-IjHmHTkNtmxhIupXg" target="_blank" rel="noopener">MySQL读写分离：如何解决写完读不到问题</a><br><a href="https://mp.weixin.qq.com/s/NwcX2Mamaoh7menT8L2j-A" target="_blank" rel="noopener">MySQL 的 Binlog 日志处理工具（Canal，Maxwell，Databus，DTS）对比</a></p>
<h3 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/79opEOVqODjOIIFnMBylog" target="_blank" rel="noopener">一文读懂分库分表的技术演进（最佳实践）</a><br><a href="https://mp.weixin.qq.com/s/RAS5Jv59DWGioV5zdZnamA" target="_blank" rel="noopener">MySQL 常用分库分表方案，都在这里了！</a><br><a href="https://mp.weixin.qq.com/s/56DQk-cHBYdrne5pwbU3hg" target="_blank" rel="noopener">MySQL 大表优化方案</a><br><a href="https://mp.weixin.qq.com/s/GbhOywDZl1SJtwmP3NDXzQ" target="_blank" rel="noopener">数据量大了一定要分表，分库分表 Sharding-JDBC 入门与项目实战</a><br><a href="https://mp.weixin.qq.com/s/LsiYnaKZTnyXIpM55iGVTg" target="_blank" rel="noopener">数据库常用架构方案</a><br><a href="https://mp.weixin.qq.com/s/dYUGA0wLfn-GbWrMKRKAAQ" target="_blank" rel="noopener">数据库链接池终于搞对了，这次直接从100ms优化到3ms！</a><br><a href="https://mp.weixin.qq.com/s/TnUIv69XShpQsHrsCpRz6g" target="_blank" rel="noopener">数据持久化框架为什么放弃 Hibernate、JPA、Mybatis，最终选择 JDBCTemplate！</a><br><a href="https://mp.weixin.qq.com/s/DKe2vPjO0B4YKGoX-Ixv7g" target="_blank" rel="noopener">老大又批评我不要为了“分库分表”而“分库分表”</a><br><a href="https://mp.weixin.qq.com/s/wpzfIxixiAmDXEYuxLoZGQ" target="_blank" rel="noopener">ShardingJdbc分库分表实战案例解析（下）</a><br><a href="https://mp.weixin.qq.com/s/oZEkECeBl1zw8eOApH1Vqg" target="_blank" rel="noopener">这四种情况下，才是考虑分库分表的时候！</a></li>
</ul>
<h3 id="数据源切换问题"><a href="#数据源切换问题" class="headerlink" title="数据源切换问题"></a>数据源切换问题</h3><p><a href="https://mp.weixin.qq.com/s/oYJxWb6LJd-Nf_Gj9Lx_dA" target="_blank" rel="noopener">Spring Boot + Mybatis 配合 AOP 和注解实现动态数据源切换配置</a></p>
<h3 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h3><p><a href="https://mp.weixin.qq.com/s/32psjtpLXFSaq6JsQEsL3w" target="_blank" rel="noopener">本以为用的 MyBatis 框架就万无一失了，没想到还是被黑客注入了，我真的无语了！</a><br><a href="https://blog.csdn.net/li_jian_hui_/article/details/105801454" target="_blank" rel="noopener">一分钟让你搞明白 left join、right join和join的区别</a><br><a href="https://mp.weixin.qq.com/s/yaJnDXbz4uqKlc1iK95gXQ" target="_blank" rel="noopener">一次非常有意思的 SQL 优化经历：从 30248.271s 到 0.001s</a><br><a href="https://mp.weixin.qq.com/s/tabXz_-vsoeVzqZz-gOVyA" target="_blank" rel="noopener">MySQL 唯一索引为什么会导致死锁？</a><br><a href="https://blog.csdn.net/asdfsadfasdfsa/article/details/83030011" target="_blank" rel="noopener">insert into … select 由于SELECT表引起的死锁情况分析</a><br><a href="https://mp.weixin.qq.com/s/7vtyhs0qf3rltiU9bEy5tw" target="_blank" rel="noopener">求求你别再用offset和limit分页了</a><br><a href="https://mp.weixin.qq.com/s/L6dLOLmEoYzmd34-Qpp4xA" target="_blank" rel="noopener">面试官：数据量很大，分页查询很慢，有什么优化方案？</a><br><a href="https://mp.weixin.qq.com/s/JtHf0AEr7BmapGFFd1tegQ" target="_blank" rel="noopener">10张图告诉你，MySQL 是如何查找数据的？</a><br><a href="https://mp.weixin.qq.com/s/Oc70q4hMp7JaN309SiF7BA" target="_blank" rel="noopener">一次 SQL 查询优化原理分析（900W+ 数据，从 17s 到 300ms）</a><br><a href="https://mp.weixin.qq.com/s/zQaOVYCNcZKUlZ2UILPb5g" target="_blank" rel="noopener">SQL 中的 in 与 not in、exists 与 not exists 的区别以及性能分析</a><br><a href="https://mp.weixin.qq.com/s/A_-n_05Q4HrF9mtekuTgvg" target="_blank" rel="noopener">索引失效的场景有哪些？索引何时会失效？</a><br><a href="https://mp.weixin.qq.com/s/14yjEL5LrHKbD-YrnHW7Mw" target="_blank" rel="noopener">一入职！就遇到上亿(MySQL)大表的优化。。。</a><br><a href="https://mp.weixin.qq.com/s/r45Zozse4whon4cp2OaFbQ" target="_blank" rel="noopener">为什么 MySQL 不推荐使用 join？</a><br><a href="https://mp.weixin.qq.com/s/Pm5Yf1y7xtd9iNiLXkrm0A" target="_blank" rel="noopener">干 MySQL 两千万数据的大表优化解决过程，三种厉害的解决方案</a><br><a href="https://mp.weixin.qq.com/s/CW4fW4DedbBcfhCXXUqzrQ" target="_blank" rel="noopener">MySQL 百万级数据量分页查询方法及其优化</a><br><a href="https://mp.weixin.qq.com/s/czrpzXigkoF0b9aZeAid4A" target="_blank" rel="noopener">MyBatis 动态 SQL（认真看看， 以后写 SQL 就爽多了）</a><br><a href="https://mp.weixin.qq.com/s/vOM62dVGAko71yx2SY48-w" target="_blank" rel="noopener">面试官：你知道select语句和update语句分别是怎么执行的吗？</a><br><a href="https://mp.weixin.qq.com/s/w1rMnAaY3PnIqSzgTH1kzQ" target="_blank" rel="noopener">CTO 说了，如果发现谁用 SELECT * 查询直接开除</a><br><a href="https://mp.weixin.qq.com/s/YGiTMS9wzQD74p11tpvsaQ" target="_blank" rel="noopener">SQL 语句中 left join 后用 on 还是 where，区别大了！</a><br><a href="https://mp.weixin.qq.com/s/YPsV9Qj0jJvsGJOo-pHLdw" target="_blank" rel="noopener">场景+案例分析，SQL优化这么做就对了！</a><br><a href="https://mp.weixin.qq.com/s/V8jnLPMVBvXmCgs3DPa6Eg" target="_blank" rel="noopener">15000 字的 SQL 语句大全</a><br><a href="https://mp.weixin.qq.com/s/4YxKK6JWUYutJ_VEQBq_eA" target="_blank" rel="noopener">52 条 SQL 语句性能优化策略，建议收藏！</a></p>
<h2 id="No-sql-非关系型"><a href="#No-sql-非关系型" class="headerlink" title="No sql(非关系型)"></a>No sql(非关系型)</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a href="https://mp.weixin.qq.com/s/ij67XYJgYK2kYrAlSDz3sw" target="_blank" rel="noopener">彻底理解 Redis 的持久化机制：RDB和AOF</a><br><a href="https://mp.weixin.qq.com/s/SO3S2UZaomYwVA43sYzJpw" target="_blank" rel="noopener">面试官：缓存一致性问题怎么解决</a><br><a href="https://mp.weixin.qq.com/s/c-gPA_UIAqAKkGDGaDqZBQ" target="_blank" rel="noopener">缓存届霸主，Redis 不得不说的秘密</a><br><a href="https://mp.weixin.qq.com/s/trXretFRbFdf5UKYqvGLrw" target="_blank" rel="noopener">瞬间几千次的重复提交，我用 Spring Boot + Redis 扛住了！</a><br><a href="https://mp.weixin.qq.com/s/Q2KyFZu1J9E1U-mfSUSx8g" target="_blank" rel="noopener">如何设计缓存系统：缓存穿透，缓存击穿，缓存雪崩解决方案分析</a><br><a href="https://mp.weixin.qq.com/s/e1NH3-CPUlFqkIbLwcoslA" target="_blank" rel="noopener">总结一波 Redis 面试题，收藏起来。</a><br><a href="https://mp.weixin.qq.com/s/msljR2ocm9xu1Lnh0OfMDg" target="_blank" rel="noopener">每次面试都要被问：为什么采用单线程的 Redis 也会如此之快？</a><br><a href="https://mp.weixin.qq.com/s/6II3GLBXauwg_anvLx8Y3w" target="_blank" rel="noopener">最强 Java Redis 客户端</a><br><a href="https://mp.weixin.qq.com/s/5ZomglVZQHzUxPYhuGvYkQ" target="_blank" rel="noopener">Redis 从入门到放弃</a><br><a href="https://mp.weixin.qq.com/s/l3sidMQ1VIY9Axzk_PogXw" target="_blank" rel="noopener">Redis 如何存储上亿级别的用户状态？</a><br><a href="https://mp.weixin.qq.com/s/eKqHJxqP7jsWbrPE0LwCKQ" target="_blank" rel="noopener">首长，Redis 性能优化十三条军规立好了，请过目~</a><br><a href="https://mp.weixin.qq.com/s/GWZsALj_HoN7G9AT6_epxQ" target="_blank" rel="noopener">推荐一款神仙颜值的 Redis 客户端工具</a><br><a href="https://mp.weixin.qq.com/s/5wAp844dUrV5djCcJzZipg" target="_blank" rel="noopener">Redis 由浅入深深深深深剖析</a><br><a href="https://mp.weixin.qq.com/s/y8opuVeQzhQ3Oh8ZcnKcCw" target="_blank" rel="noopener">Spring Boot 监听 Redis Key 失效事件实现定时任务</a><br><a href="https://mp.weixin.qq.com/s/NbX47nCOGIPQ0NnTuwX9cg" target="_blank" rel="noopener">Redis 分布式锁使用不当，酿成一个重大事故，超卖了 100 瓶飞天茅台！！！</a></p>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p><a href="https://mp.weixin.qq.com/s/7CdwkSOIMZNw0vnwtXgXIA" target="_blank" rel="noopener">恕我直言，牛逼哄哄的MongoDB你可能只会30%</a></p>
<h3 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h3><h2 id="线上优化与排查问题"><a href="#线上优化与排查问题" class="headerlink" title="线上优化与排查问题"></a>线上优化与排查问题</h2><p><a href="https://mp.weixin.qq.com/s/VRlxeclAbMdCkYJ_iJLCXg" target="_blank" rel="noopener">一次 Java 内存泄漏排查过程，学习学习</a><br><a href="https://mp.weixin.qq.com/s/MmEn18aunDASfCyOep25Qg" target="_blank" rel="noopener">线上服务 CPU 100%？一键定位 so easy！</a><br><a href="https://mp.weixin.qq.com/s/BN7kFFE0AWIec7j-yTGhZA" target="_blank" rel="noopener">推荐一款神器，助你秒级定位线上问题！</a><br><a href="https://mp.weixin.qq.com/s/mbiVH-GYjvouu-fPH4Vnog" target="_blank" rel="noopener">JVM GC 耗时频频升高，这次排查完想说：还有谁？</a><br><a href="https://mp.weixin.qq.com/s/3uaIsDWrMmK0zXX946mJBg" target="_blank" rel="noopener">一次简单的 JVM 调优，性能提升了15%</a><br><a href="https://mp.weixin.qq.com/s/4f7k-SC5bsQ3lhaRMWAJPw" target="_blank" rel="noopener">惊呆了，Spring Boot居然这么耗内存！</a><br><a href="https://mp.weixin.qq.com/s/xB5jXai6d-ggTu9U3Lyq1g" target="_blank" rel="noopener">JAVA 线上故障排查完整套路，从 CPU、磁盘、内存、网络、GC 一条龙！</a><br><a href="https://mp.weixin.qq.com/s/HGnylGNsmnc6FslDGrc2Mw" target="_blank" rel="noopener">一整套线上故障排查技巧，爱了！</a><br><a href="https://mp.weixin.qq.com/s/23feuvCFJHfs6x_aJ2c3dg" target="_blank" rel="noopener">记一次订单号重复的事故，快看看你的 uuid 在并发下还正确吗？</a></p>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p><a href="https://mp.weixin.qq.com/s/P0u-q-d_nrTQbgXm4o0y8g" target="_blank" rel="noopener">Http 持久连接与 HttpClient 连接池，有哪些不为人知的关系？</a><br><a href="https://mp.weixin.qq.com/s/b7ODGzAQdHY-JhBo8-V-vg" target="_blank" rel="noopener">最精美详尽的 HTTPS 原理图</a><br><a href="https://mp.weixin.qq.com/s/1Y4eEckZedjiH1cq0Z66XQ" target="_blank" rel="noopener">跨域问题</a><br><a href="https://blog.csdn.net/weixin_34237596/article/details/88685505" target="_blank" rel="noopener">前后端分离中的无痛刷新token机制</a><br><a href="https://mp.weixin.qq.com/s/uuSM0OERqeeADsodPlrLWA" target="_blank" rel="noopener">单点登录原理与简单实现</a><br><a href="https://mp.weixin.qq.com/s/i1CpctXmb2Nh2j9qBIYRdw" target="_blank" rel="noopener">Spring Boot 解决跨域问题的 3 种方案！</a><br><a href="https://www.cnblogs.com/zhuochong/p/10412755.html" target="_blank" rel="noopener">抓包工具Wireshark/Charles</a><br><a href="https://mp.weixin.qq.com/s/2V-DQoFWpA4N5mP4ZIOmYg" target="_blank" rel="noopener">Spring Boot + Vue 如此强大？竟然可以开发基于 C/S 架构的应用</a><br><a href="https://mp.weixin.qq.com/s/HzUwYQyvOJpIZue2OaBuzw" target="_blank" rel="noopener">基于 token 的多平台身份认证架构设计</a><br><a href="https://mp.weixin.qq.com/s/UVmVBGggsaiuFH-WEtSRkg" target="_blank" rel="noopener">JSON Web 令牌（JWT）是如何保护 API 的？？</a><br><a href="https://mp.weixin.qq.com/s/5dQKXOT9lTbDxNrQGNzW9A" target="_blank" rel="noopener">JWT、JWE、JWS 、JWK 到底是什么？该用 JWT 还是 JWS？</a><br><a href="https://mp.weixin.qq.com/s/zwm_OcoyIlaIVEcYvg-VDg" target="_blank" rel="noopener">为什么要放弃 JSP ？</a><br><a href="https://mp.weixin.qq.com/s/zAyYIs5d3f4p0-jsU6QmVQ" target="_blank" rel="noopener">还分不清 Cookie、Session、Token、JWT？</a><br><a href="https://mp.weixin.qq.com/s/vrnUdffl95Gv0pLRcvrjlA" target="_blank" rel="noopener">SpringSecurity + JWT，从入门到精通！</a><br><a href="https://mp.weixin.qq.com/s/BqwHFbyb-ShlYelUw2x6sA" target="_blank" rel="noopener">从前端到后端，Web 安全不仅仅是安全团队的事</a><br><a href="https://mp.weixin.qq.com/s/XZMXhh72m2i-HwtngIbJKQ" target="_blank" rel="noopener">在用安全框架前，我想先让你手撸一个登陆认证</a><br><a href="https://blog.csdn.net/majiabao123/article/details/4152448" target="_blank" rel="noopener">细说HTML元素的ID和Name属性的区别</a><br><a href="https://mp.weixin.qq.com/s/6d_16hfd5Fz8pZvdpO3BEw" target="_blank" rel="noopener">单点登录系统原理与实现，图文并茂，附源码</a><br><a href="https://mp.weixin.qq.com/s/MXIlI_MzLJ4raIzExpEziA" target="_blank" rel="noopener">在 SpringBoot 项目中，Spring Security 和 Shiro 该如何选择？</a><br><a href="https://mp.weixin.qq.com/s/XYSQ_VuH8cY-PQCSDG1dnQ" target="_blank" rel="noopener">面试官：你连 HTTPS 原理没搞懂，还给我讲“中间人攻击”？</a></p>
<h2 id="工作查询"><a href="#工作查询" class="headerlink" title="工作查询"></a>工作查询</h2><p><a href="https://mp.weixin.qq.com/s/Y5GPjsezLNWzvz7Ke1x4Ew" target="_blank" rel="noopener">Java8日期处理，工作必用！</a><br><a href="https://mp.weixin.qq.com/s/aroL0LoxZfP8EPOuyoSKUw" target="_blank" rel="noopener">搞懂高可用：异地多活，看这篇文章就够了！</a><br><a href="https://mp.weixin.qq.com/s/QGI5iEg991pB83zWGX_iLA" target="_blank" rel="noopener">PowerDesigner 逆向工程，太实用了！</a><br><a href="https://www.processon.com/diagraming/6065a7387d9c0829db67ba74" target="_blank" rel="noopener">Process交互图</a><br><a href="https://blog.csdn.net/wuxing26jiayou/article/details/79730987" target="_blank" rel="noopener">TCP粘包问题分析和解决（全）</a><br><a href="https://mp.weixin.qq.com/s/4PHTxsyiQzrYclDZlz4X1Q" target="_blank" rel="noopener">IDEA中一个被低估的功能，一键把项目代码绘制成UML类图</a></p>
<h2 id="实用"><a href="#实用" class="headerlink" title="实用"></a>实用</h2><p><a href="https://mp.weixin.qq.com/s/Mw0xo-V9tDvDhATsb13cKQ" target="_blank" rel="noopener">改良的中国投资时钟：周期轮动和大类资产表现</a><br><a href="https://mp.weixin.qq.com/s/mqm2rmVq81pNm7PgQyGhnw" target="_blank" rel="noopener">技术转项目管理常掉的3个大坑，我们找到了填坑的方法！</a><br><a href="https://mp.weixin.qq.com/s/tgGNbiHKcBfmyiKyV3Aj7g" target="_blank" rel="noopener">技术人员想成功转型为项目经理，这两点很关键</a><br><a href="https://www.cnblogs.com/brady-wang/p/8416116.html" target="_blank" rel="noopener">博客打赏</a><br><a href="https://www.cnblogs.com/rickiyang/" target="_blank" rel="noopener">别人博客</a><br><a href="https://www.zhihu.com/people/xue-chuan-da-chong" target="_blank" rel="noopener">别人博客</a><br><a href="https://mp.weixin.qq.com/s/0cL4bfrcr0sAyPn0_q38-A" target="_blank" rel="noopener">从一个工程师到管理员的经验分享</a><br><a href="https://mp.weixin.qq.com/s/fTXavDfs9RNBpqKmKauz2A" target="_blank" rel="noopener">牛市来了？上班盯盘太累？这五个开源项目了解下！</a><br><a href="https://mp.weixin.qq.com/s/V6JDNE8Ds0G6XJDz9GESlQ" target="_blank" rel="noopener">【短视频】Python金融实战者风采展示（吕伽颀）</a><br><a href="https://mp.weixin.qq.com/s/iEmWhyEKVH7oDCzRe_HTiw" target="_blank" rel="noopener">开发经理是否应该写代码？</a><br><a href="https://blog.csdn.net/fuyipingwml1976124/article/details/107031838" target="_blank" rel="noopener">一分钟读懂优秀PM与普通PM的区别</a><br><a href="https://mp.weixin.qq.com/s/wijA1FNK9mqvtQ6W_PO7_w" target="_blank" rel="noopener">Nacos 2.0 正式发布，性能大幅提升 10 倍！</a><br><a href="https://mp.weixin.qq.com/s/-yvx8dklsplCZzBFCK7QDg" target="_blank" rel="noopener">如何使用 Arthas 定位 Spring Boot 接口超时</a></p>
<h2 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h2><p><a href="https://blog.csdn.net/c_kite/article/details/86493178" target="_blank" rel="noopener">Service Worker概念和应用介绍</a><br><a href="https://blog.csdn.net/c_kite/article/details/78389218" target="_blank" rel="noopener">react+webpack+es6详细配置教程</a></p>
<h2 id="数据库生产表dataGrip"><a href="#数据库生产表dataGrip" class="headerlink" title="数据库生产表dataGrip"></a>数据库生产表dataGrip</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/UPh0--gqPLQsYJAmARjbyQ" target="_blank" rel="noopener">数据库界的 Swagger，一键自动生成 Java 实体类和数据库文档！不讲武德！</a></li>
</ul>
]]></content>
      <categories>
        <category>(分类)</category>
      </categories>
      <tags>
        <tag>(分类)</tag>
      </tags>
  </entry>
  <entry>
    <title>BitMap算法详解</title>
    <url>/2020/09/12/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84-BitMap/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://blog.csdn.net/weixin_40539125/article/details/90084416" target="_blank" rel="noopener">海量数据处理算法—BitMap（Bitmap Sort）</a><br><a href="https://www.cnblogs.com/dongxi/archive/2012/11/07/2758045.html" target="_blank" rel="noopener">Bitmap算法解析</a><br><a href="https://blog.csdn.net/u010246947/article/details/77452091" target="_blank" rel="noopener">bitmap用途</a><br><a href="https://www.jianshu.com/p/0db33fade32c" target="_blank" rel="noopener">海量数据下 BitMap 理解及应用场景</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>BitMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法-最短路径问题</title>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84-Dijkstra(%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95)/</url>
    <content><![CDATA[<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题:"></a>解决的问题:</h2><p><a href="https://mp.weixin.qq.com/s/v07D1jsVtcztzUb4P8Xd4w" target="_blank" rel="noopener">最短路径问题——迪杰斯特拉算法(Dijkstra)</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dijkstra算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA算法详解</title>
    <url>/2020/09/12/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84-RSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://blog.csdn.net/shenggaofei/article/details/52333687" target="_blank" rel="noopener">最全加密算法之对称加密和非对称加密</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>堆-二叉树</title>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p><a href="https://mp.weixin.qq.com/s/4_5t-2qn11qC-qh328v3NA" target="_blank" rel="noopener">重温《数据结构与算法》之堆与堆排序</a></p>
<h2 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h2><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>算法结构体系图</title>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="Single-Sign-On"><a href="#Single-Sign-On" class="headerlink" title="Single Sign On"></a>Single Sign On</h2><p><a href="https://mp.weixin.qq.com/s/sgrHmuQlQlxIh-0Ska_yIA" target="_blank" rel="noopener">算法结构体系图</a></p>
<p><img src="/img/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB%E5%9B%BE.png" alt="算法结构体系图" title="算法结构体系图"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>path</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合算法详解</title>
    <url>/2020/09/12/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://www.cnblogs.com/zzlback/p/10947064.html" target="_blank" rel="noopener">java实现排列组合(通俗易懂)</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2020/09/12/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://jingyan.baidu.com/article/c85b7a64352a0f403aac954e.html" target="_blank" rel="noopener">算法复杂度解析</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与回溯</title>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84-%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://mp.weixin.qq.com/s/Q6UFD72smBbwl765w2kHgA" target="_blank" rel="noopener">如何解决八皇后问题</a></p>
<p><a href="https://blog.csdn.net/houxuehan/article/details/50209553" target="_blank" rel="noopener">数独算法</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>递归与回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrum与看板对比</title>
    <url>/2021/03/13/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-Srcum%E4%B8%8E%E7%9C%8B%E6%9D%BF%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="Scrum简述"><a href="#Scrum简述" class="headerlink" title="Scrum简述"></a>Scrum简述</h2><ol>
<li>把组织拆分成小规模的、跨功能的自组织团队。</li>
<li>把工作拆分成一系列小而具体的交付物。按优先级排序，估算每项任务的相对 工作量。</li>
<li>把时间拆分成固定大小的短迭代（通常为1-4 周），在每个迭代结束时对基本可 以交付的代码进行演示。</li>
<li>在每个迭代结束后跟客户一起检查发布目标，并据此优化发布计划，更新任务优先级。<br>总结：我们不是靠一个庞大的团队，花大量时间造出庞然大物；而是用小团队在短时间内做出小块的东西来，在有规律的集成中组装出全貌。</li>
</ol>
<h2 id="看板简述"><a href="#看板简述" class="headerlink" title="看板简述"></a>看板简述</h2><p>将流程可视化</p>
<ul>
<li>把工作拆分成小块，一张卡片写一件任务，再把卡片放到墙上。 </li>
<li>每一列都起一个名字，显示每件任务在流程中处于什么位置。</li>
<li>限制 WIP（在制品，work in progress）──明确限制流程中每个状态上最多同 时进行的任务数。</li>
<li>度量生产周期（完成一件任务的平均时间，又称循环周期），不断总结对流程进行调优，尽可能缩短生产周期，并使其可预测。</li>
</ul>
<h2 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h2><p>Scrum 和看板都是过程工具，它们讲的是做哪些事情能够在一定程度上帮助你提高工作效率。<br>工具=用于完成任务或达成目的的任何东西                                                                                          过程=工作方式</p>
<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><ul>
<li><p>scrum: 角色：Scrum 规定了三种角色：产品负责人（描绘产品远景，定义优先级）、团队（实现 产品）、Scrum Master（消除障碍，带领过程运作）。</p>
</li>
<li><p>看板:看板没规定任何角色。</p>
</li>
<li><p>scrum: 定固定时长的迭代：固定时长的迭代是 Scrum 的基础，Scrum 的迭代就是一段长度固定的单声部旋律，混合了三种活动：计划、过程 改进、（理想中的）发布。</p>
</li>
<li><p>看板:看板没有规定固定时长的迭代。</p>
</li>
<li><p>scrum: 限制 WIP：Scrum的WIP按单位时间限制。</p>
</li>
<li><p>看板:看板的WIP 按流程状态限制。</p>
</li>
<li><p>scrum: Scrum 的平均响应时间等于sprint 长度的一半。</p>
</li>
<li><p>看板:响应时间：看板的原则是“一件出去，一件进来”（由 WIP 驱动），所以看板团队的响应时间（多 久才能响应优先级的变化）就等于他们要花多长时间才能把手头的事情做完。</p>
</li>
<li><p>scrum: 板子是否重置：Scrum 板在迭代之间重置。在Sprint 的不同时期，Scrum 板通常有不同的样子。Sprint 结束以后，板子就会进行清理──所有卡片全部去掉。等到新的 Sprint 开始， Sprint 计划会议结束以后，就有了新的 Scrum 板。</p>
</li>
<li><p>看板:看板图的样子几乎是一成不变的──你不需要把板子清理干净，重新开始。</p>
</li>
<li><p>scrum: 是否要求跨功能团队：一个 Scrum 团队只有一块 Scrum 板。Scrum 团队是跨功能的，要完成迭代全部任务 所需的技能，这个团队要全都具备。</p>
</li>
<li><p>看板:看板不强制要求跨功能团队，看板图也不是独归某个团队所有。看板图对应的是流 程，不必非得是一个团队。</p>
</li>
<li><p>scrum: 任务是否要在某个时间内做完：Scrum 团队只会承诺他们认为能在一个迭代里面做完（基于他们对“完成”的定义） 的任务。如果任务太大了，一个 Sprint 放不下，团队跟产品负责人就会寻找方法拆分，直到能放下为止。</p>
</li>
<li><p>看板:看板团队努力缩短生产周期，保持顺畅流动，而这些因素会间接推动团队把任务拆 分成相对较小的片段。但是看板对任务规模没有明文规定一定要在某个时间内做完。</p>
</li>
<li><p>scrum:是否规定估算和生产率：在Scrum 里面，团队要对每个承诺的任务估算其相对大小（=工作量），到迭代结束 的时候，把每个任务的大小相加，就得到了生产率。生产率是度量团队能力──我们 每个Sprint 能交付多少东西──的指标。</p>
</li>
<li><p>看板:看板没有规定估算这回事。</p>
</li>
</ul>
<h3 id="共同"><a href="#共同" class="headerlink" title="共同"></a>共同</h3><p>二者都是经验主义的：Scrum 和看板都是经验主义的产物，你用的时候需要先进行试验，然后根据自己的环境作调整。实际上，你必须得先试验。Scrum 和看板都没给出一切问题的答案，它们只是给了一些基本约束，以此驱动过程改进。</p>
<p>都是既精益又敏捷。都是拉动式计划。都限制了WIP。都以透明的方式驱动过程改进。都关注于尽早交付、频繁交付可发布的软件。 根基都是自组织型团队。 都需要把工作拆分。发布计划都是根据经验数据（生产率/生产周期）不断优化的。<br><img src="/scrum/009.png" alt="009.png" title="009"><br><img src="/scrum/010.png" alt="010.png" title="010"></p>
]]></content>
      <categories>
        <category>Project Management</category>
      </categories>
      <tags>
        <tag>Scrum</tag>
        <tag>敏捷</tag>
      </tags>
  </entry>
  <entry>
    <title>ACP敏捷知识</title>
    <url>/2021/01/05/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-ACP%E6%95%8F%E6%8D%B7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="敏捷是什么？"><a href="#敏捷是什么？" class="headerlink" title="敏捷是什么？"></a>敏捷是什么？</h2><p>“敏捷”是一种问题解决方式，<font color="red">为了应对高度不确定项目变化速度快,复杂性和风险也高.为了在短时间内探讨可行性,根据评估和反馈快速调整。同时是在问题本身或问题解决能力不能确定的情况下取得尽可能好的结果的问题解决方式;因此敏捷是根据应对不确定性出现时,寻找近优解或更优解。</font></p>
<p>ACP 的学习包含了波浪式规划、迭代递增式交付、对变化做出快速而灵活的反应 在团队、干系人和客户之间进行开放式交流，敏捷遵循极限编程、Scrum、精益、看板、测试驱动开发、功能驱动开发等原则，快速解决项目中出现的问题，并进行对客户的不断交付。整个模型核心为客户快速提供有价值的可交付成果</p>
<h3 id="主要解决6大模块的问题。内容总结如下："><a href="#主要解决6大模块的问题。内容总结如下：" class="headerlink" title="主要解决6大模块的问题。内容总结如下："></a>主要解决6大模块的问题。内容总结如下：</h3><pre><code>1.如何交付与客户需求一致的产品?
2.如何管理干系人的参与和期望?
3.如何在敏捷管理过程中提升团队的绩效?
4.如何让计划更好的适应变化?
5.如何及时发现问题并有效解决?
6.如何持续改进—产品、过程、人</code></pre><h3 id="面临问题"><a href="#面临问题" class="headerlink" title="面临问题"></a>面临问题</h3><pre><code>1.估算不准确,导致延期风险：加班/或者部分交付/延期交付：提前识别逾期
2.识别有用需求,排期合理，
3.拆分工作包</code></pre><h3 id="每日站立会："><a href="#每日站立会：" class="headerlink" title="每日站立会："></a>每日站立会：</h3><h2 id="敏捷的核心规则"><a href="#敏捷的核心规则" class="headerlink" title="敏捷的核心规则"></a>敏捷的核心规则</h2><h3 id="敏捷4大宣言"><a href="#敏捷4大宣言" class="headerlink" title="敏捷4大宣言"></a>敏捷4大宣言</h3><p><img src="/acp/%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80.png" alt="敏捷宣言" title="敏捷宣言"></p>
<h3 id="12大原则"><a href="#12大原则" class="headerlink" title="12大原则"></a>12大原则</h3><p><img src="/acp/12%E5%A4%A7%E5%8E%9F%E5%88%99.png" alt="12大原则" title="12大原则"></p>
<h3 id="敏捷思维模式"><a href="#敏捷思维模式" class="headerlink" title="敏捷思维模式"></a>敏捷思维模式</h3><p><img src="/acp/%E6%95%8F%E6%8D%B7%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F.png" alt="敏捷思维模式" title="敏捷思维模式"></p>
<h3 id="精益与敏捷关系"><a href="#精益与敏捷关系" class="headerlink" title="精益与敏捷关系"></a>精益与敏捷关系</h3><p><img src="/acp/%E7%B2%BE%E7%9B%8A%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%85%B3%E7%B3%BB.png" alt="精益与敏捷关系" title="精益与敏捷关系"><br>项目团队有时候会发现将各种方法结合起来使用更加有用,只要对组织或团队有效的方法,无论来源如何,都应该采纳.</p>
<h3 id="不确定性-风险和生命周期选择"><a href="#不确定性-风险和生命周期选择" class="headerlink" title="不确定性,风险和生命周期选择"></a>不确定性,风险和生命周期选择</h3><p><img src="/acp/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%92%8C%E9%A3%8E%E9%99%A9%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%80%89%E6%8B%A9.png" alt="不确定性和风险和生命周期选择" title="不确定性和风险和生命周期选择"></p>
<p>不确定性包括:<br>    1. 适用性和需求(正在构建的产品是否正确?)<br>    2. 技术可行性和性能(产品是否可以采用这种方法构建?)<br>    3. 过程和人员(这是否为团队工作的一种有效方式)</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>四种类型生命周期形态<br><img src="/acp/%E5%91%A8%E6%9C%9F%E7%89%B9%E5%BE%81.png" alt="周期特征" title="周期特征"></li>
</ul>
<h3 id="预测型"><a href="#预测型" class="headerlink" title="预测型"></a>预测型</h3><p><img src="/acp/%E9%A2%84%E6%B5%8B%E5%9E%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="预测型生命周期" title="预测型生命周期"><br>预测型生命周期预计会从高确定性的明确的需求,稳定的团队和低风险中获益。<br>团队需要详细计划,了解要交付什么以及怎么样交付.如果过程变更收到控制,那项目就容易成功.预测型项目根据部门划分的，有效的，顺序的工作,并且不能在项目前结束商业价值,如果遇到变更或需求分歧,或技术解决方案变得不在简单明了,预测型项目就产生意想不到的成本。</p>
<h3 id="迭代型"><a href="#迭代型" class="headerlink" title="迭代型"></a>迭代型</h3><p><img src="/acp/%E8%BF%AD%E4%BB%A3%E8%A1%8C%E5%91%A8%E6%9C%9F.png" alt="迭代行周期" title="迭代行周期"><br>当项目复杂性高,变更频繁或当项目范围受到相关方对所需最终产品的不同观点的支配时，采用迭代型生命周期有优势。迭代型生命周期可能需要更长时间,因为他是为学习而优化,而不是交付速度而优化.</p>
<p>场景1:</p>
<ul>
<li>您是否并不确定新的商业服务在实践中怎么样发挥作用?用评估标准来创建一个概念验证,以此探讨期望结果,如果您怀疑需求将根据客户反馈发生更变,请使用迭代方法。</li>
</ul>
<p>场景2：</p>
<ul>
<li>您是否曾经参与过这样的项目,在项目过程中,需求视乎每天都在变化,您认为,“我们在交付企业批准的原型就会了解需求”。如果情况如此，那么敏捷方法将有助于这个项目。原型法鼓励反馈，并有助于更好理解可纳入每个交付成果的需求。</li>
</ul>
<h3 id="增量型"><a href="#增量型" class="headerlink" title="增量型"></a>增量型</h3><p><img src="/acp/%E5%A2%9E%E9%87%8F%E5%9E%8B.png" alt="增量型" title="增量型"><br>为了快速交付,许多项目无法等待所有事情全部完成,这种情况下,客户愿意接受整个解决方案的一部分.这种少量交付成果的频繁交付成为增量型生命周期。</p>
<ul>
<li>生命周期不一样</li>
<li>通过不断交付的反馈，团队可以有效管理项目偏差.与客户在项目中结束时获得价值相比,确保客户能尽早获得价值,其变更和差异程度的重要型变得不那么重要。</li>
<li>由于完整性和交付是主观的,团队可能需要获得关于原型的反馈,然后可能选择将最小可行性产品交付客户。客户反馈会帮助团队了解他们需要为随后交付最终功能提供什么。</li>
<li>采用增量方法的一个例子:为客户提供一个单一功能或是交付一项完成的工作。如商品房未完成之前先提交样本房。</li>
</ul>
<h3 id="敏捷型"><a href="#敏捷型" class="headerlink" title="敏捷型"></a>敏捷型</h3><p><img src="/acp/%E6%95%8F%E6%8D%B7%E5%9E%8B.png" alt="敏捷型" title="敏捷型"><br>在敏捷环境中,团队预料需求会发生更变.迭代和增量方法能够提供反馈,以便改善项目下一部分的计划.不过在项目敏捷中,增量交付会发现隐藏或误解的需求。图中事先了交付两种可能的方法,这样便于项目与客户需求保持一致,并根据需求调整。</p>
<ul>
<li><p>迭代敏捷:团队以迭代(相等持续的时间盒)形式交付完整的功能。团队集中于最重要功能,作为一个团队合作完成其工作.然后,团队再集中于下一项最重要的功能,并合作完成其工作.团队可决定一次进行若干功能的开发工作,但是团队不会同时完成所有迭代工作(团队不会在完全分析等工作后再解决所有需求)</p>
</li>
<li><p>流程基础上的敏捷方法:团队将根据自身能力,从代办事项列表中提取若干功能开始工作,而不是安装基于迭代的进度计划开始工作.团队定义任务板各列工作流,并管理各列的进行中的工作.完成不同工能所花费的时间可能有所不同。团队让进行中的工作规模尽量小,以便尽早发现问题,并在需要更变时减少返工.<font color="red">无需利用迭代定义计划和审核点,而由团队和业务相关方决定规划,产品评审与回顾的最适当的进度计划</font></p>
</li>
<li><p>敏捷生命周期是符合《敏捷宣言》原则的周期,特别是,客户满意度将随着有价值产品的早期交付和持续交付不断提升.功能性的，提供价值的增量可交付成果,是衡量进展的主要尺度。为了更适应更频繁的变更,和更频繁的交付项目价值,敏捷生命周期结合迭代和增量的方法</p>
</li>
</ul>
<h3 id="迭代与增量应用特点"><a href="#迭代与增量应用特点" class="headerlink" title="迭代与增量应用特点"></a>迭代与增量应用特点</h3><pre><code>1.非常短的反馈循环
2.频繁调整过程
3.重新进行优先级排序
4.定期更新计划
5.频繁交付
6.需要研究与开发
7.变更速度极快
8.具有不明确或未知的需求,不确定性或风险
9.最终目标难以描述:通过构建小增量,然后对其进行评估测试,团队可以在短时间内以低成本探索不确定性,降低风险,最大程度的实现商业价值的交付.</code></pre><h3 id="混合型"><a href="#混合型" class="headerlink" title="混合型"></a>混合型</h3><p><img src="/acp/%E6%B7%B7%E5%90%88%E5%9E%8B.png" alt="混合型" title="混合型"><br>对于整个项目,没有必要使用单一的方法.为了达到特定的目标,经常要结合不同的生命周期要素.预测,迭代,增量和敏捷方法的组合就是混合方法.</p>
<ul>
<li><p>案例有:<br>　　１.医药公司上市前需要审批,每一次审批都是修正,但是一旦审批通过就可以批量生产,因此整个生命周期嵌套了不一样类型生命周期<br>  2.需要从预期型过度到敏捷:添加站立会,回顾,采取短迭代….</p>
</li>
<li><p>预测为主,敏捷为辅<br><img src="/acp/%E9%A2%84%E6%B5%8B%E4%B8%BA%E4%B8%BB.png" alt="预测为主" title="预测为主"><br>以敏捷处理项目中具有不确定性,复杂性或者范围存在蔓延机会项目的一部分.其余都是预测<br>如承包商可能计划首先在地面上进行小规模安装实验,已确定最佳安装方法,并在有足够时间解决问题时尽早发现问题,随后通过试验和调整,增量地改进</p>
</li>
<li><p>敏捷为主,预测为辅<br><img src="/acp/%E6%95%8F%E6%8D%B7%E4%B8%BA%E4%B8%BB.png" alt="敏捷为主" title="敏捷为主"><br>当某个特定要素不可协商,或者使用敏捷方法不可执行时,可能会使用这种方法.<br>如集成不同外部供应商开发外部组件,这些组件不能或不会以协作或增量方式合作。组件交付之后,需要单独集成</p>
</li>
</ul>
<h2 id="影响裁剪项目的因素"><a href="#影响裁剪项目的因素" class="headerlink" title="影响裁剪项目的因素"></a>影响裁剪项目的因素</h2><p><img src="/acp/%E8%A3%81%E5%89%AA%E5%9B%A0%E7%B4%A0.png" alt="裁剪因素" title="裁剪因素"></p>
<h2 id="创建敏捷环境"><a href="#创建敏捷环境" class="headerlink" title="创建敏捷环境"></a>创建敏捷环境</h2><h3 id="敏捷环境需要思考的问题"><a href="#敏捷环境需要思考的问题" class="headerlink" title="敏捷环境需要思考的问题"></a>敏捷环境需要思考的问题</h3><ol>
<li>项目团队如何以敏捷方式行动？</li>
<li>为了下一个周期受益,团队需要快速交付那些成果并获得早期反馈？</li>
<li>团队如何以一种透明的方式行动？</li>
<li>为了专注高优先级的项目，可以避免那些工作？</li>
<li>仆人式领导对团队达成目标有何益处？</li>
</ol>
<h3 id="仆人式领导"><a href="#仆人式领导" class="headerlink" title="仆人式领导"></a>仆人式领导</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义:仆人式领导是通过对团队服务来领导团队的实践,它注重理解和关注团队成员的需要和发展,旨在使团队尽可能达到最高绩效。<br>作用:促进团队发现和定义敏捷,以身作则实践并传播敏捷<br>仆人式领导按照以下顺序从事项目工作:</p>
<ol>
<li>目的:与团队一起定义“为什么”或目的,以便他们能够围绕项目目标进行合作互动。参与决策同时也是让他们达成共识，让整个团队在项目层面而不是在人员层面优化</li>
<li>人员:目标确立后，鼓励团队创造一个人人都能成长的环境.要求每个团队成员在项目工作中做出贡献</li>
<li>过程:不能计划遵循”完美”的敏捷过程,而是关注通过敏捷带来的结果。要以结果为导向来敏捷，不能以敏捷导向结果。如果跨智能团队能够常常交付完成的价值并反思产品和过程，团队就是敏捷的。团队将其过程称作什么不重要。</li>
</ol>
<h4 id="仆人式领导特征"><a href="#仆人式领导特征" class="headerlink" title="仆人式领导特征"></a>仆人式领导特征</h4><ol>
<li>提升自我意识</li>
<li>倾听</li>
<li>为团队服务</li>
<li>帮助他人成长</li>
<li>引导与控制</li>
<li>促进安全,尊重与信任;</li>
<li>促进他人精力与才智提升</li>
</ol>
<h4 id="仆人式职责"><a href="#仆人式职责" class="headerlink" title="仆人式职责"></a>仆人式职责</h4><p>仆人式领导通过管理关系,在团队内和组织中建立沟通与协作。这些关系可以帮助领导在组织中得心应手地为团队提供支持。这种支持有助于消除障碍,促进团队理顺过程。由于仆人式领导了解敏捷，在应用具体方法时践行敏捷，因此他们能够帮助满足团队需要</p>
<h4 id="仆人式领导促进地作用"><a href="#仆人式领导促进地作用" class="headerlink" title="仆人式领导促进地作用"></a>仆人式领导促进地作用</h4><p>仆人式领导工作重点就是从”管理协调”转向”促进合作”。促进帮助每个人各尽所能地思考与工作，促进鼓励团队参与，理解，并对团队输出共同承担责任。促进帮助团队创建可以接受地解决方案</p>
<p>仆人式领导促进团队内部和团队之间的合作与对话。例如，仆人式领导在团队内部和团队之间帮助发现瓶颈问题，并进行相应沟通。然后团队将解决这些瓶颈问题。此外鼓励大家通过交互式会议，非正式对话和知识共享展开工作协作.仆人式领导要通过成为公正的搭桥者和教练来做到这一点，而不是代替其他责任人作出决策。</p>
<h4 id="仆人式领导消除组织障碍"><a href="#仆人式领导消除组织障碍" class="headerlink" title="仆人式领导消除组织障碍"></a>仆人式领导消除组织障碍</h4><p>仆人式领导职责是认真审视那些阻碍团队敏捷或组织敏捷的过程,并努力使其合理化.<br>如一个部门需要大量文档,仆人式领导的角色就能发挥作用,他们可以与部门合作审查所需要文档,就敏捷交付如何满足这些需求达成共识提供协助,并对所需的文档数量进行评估,从而使团队能够将时间更多地提供有价值地产品,而不是创建详尽地文档.<br>仆人式领导还应该关注其他冗长地过程,这些过程往往造成瓶颈问题,阻碍团队或组织地敏捷性.可能需要处理地过程或部门地例子包括,财务部门,变更控制委员会或审计部门。仆人式领导可以与他人携手合作,共同质疑和审核他们地过程,为敏捷团队和领导提供支持.如对团队而言,每2周交付一个工作产品仅仅是为了让产品进入队列或过程,而冗长地分布过程可能需要6周或更长时间,这样做有什么好处?太多组织都有这些瓶颈过程,正是他们阻碍了团队快速交付有价值地产品或服务。仆人式领导有能力改变或消除障碍,为交付团队提供支持。</p>
<h4 id="仆人式领导为他人贡献铺路"><a href="#仆人式领导为他人贡献铺路" class="headerlink" title="仆人式领导为他人贡献铺路"></a>仆人式领导为他人贡献铺路</h4><p>在敏捷中,团队管理其工作过程及其工作产品.自我管理和自我组织适用于所有为组织和项目提供支持地人.仆人式领导为满足团队,项目和组织地需求而工作。仆人式领导可以在团队工作场所与团队一起工作,与管理层一起工作。使团队能够一次专注于一个项目,或者与产品负责人合作,与团队共同开发故事.有些仆人式领导与审计人员合作,改善监管环境中所需地过程,有些仆人式领导与财务部合作,帮助组织向增量预算过度。仆人式领导注重为团队铺路,让团队尽其所能.仆人式领导影响项目,鼓励组织以不同方式思考</p>
<ul>
<li>人际关系技能与专业技能<br>除仆人式领导外,团队成员还有重视自身地人际关系技能和清商技能,不仅仅是专业技能.团队中每个人都要努力展示更多主动性,正直,清商,诚实,合作态度,谦逊和以往不同方式沟通地愿意,才能促进整个团队携手共进.团队需要上述技能，才能对项目方向地变化和技术产品地变更做出积极应对.只有每个人都能适应工作彼此适应,整个团队才更有可能迈向成功</li>
</ul>
<h4 id="考虑仆人式领导职责"><a href="#考虑仆人式领导职责" class="headerlink" title="考虑仆人式领导职责"></a>考虑仆人式领导职责</h4><p>仆人式领导可能有很多头衔,但是最重要地还是他们所做地工作，以下仆人式领导地职责示例<br>1.教育培训相关方,使其了解为什么要敏捷以及如何敏捷.根据优先级说明商业价值地好处,对被赋权团队加强问责,提高工作效率,并通过更频繁评审改进质量<br>2.通过指导,鼓励和帮助为团队提供支持。提倡团队成员培训和职业发展。通过支持,鼓励和专业发展,团队成员将获得信心,承担更多责任,并在组织中做出更大贡献.仆人式领导的一个关键作用是,培养和发展团队成员,帮助他们超越自身当前的角色,既使团队将失去他们也在所不惜<br>3.通过技术项目管理活动,如量化风险分析帮助团队.有时团队成员可能并不具备在某些角色或功能方面知识或经验,对相关技能有更多接触或接受过相关培训的仆人式领导可以通过提高培训或开展这些活动来为团队提供支持<br>4.庆祝团队的成功,为团队与外部团队合作提供支持,并起到桥梁作用,创造相互欣赏的积极范围,建立加强合作的良好意愿.</p>
<h4 id="项目经理与仆人式领导"><a href="#项目经理与仆人式领导" class="headerlink" title="项目经理与仆人式领导"></a>项目经理与仆人式领导</h4><p>项目经理已经习惯于项目的协调中心,负责跟踪团队的状态,并向组织中其他成员反映.当项目被分解为孤立功能时,这种方法没有问题；但是对于高不确定性项目,项目的复杂性是一个人无法管理的.而跨职能团队既能协调自身工作，还能与业务代表(产品负责人)开展合作，这时候项目经理就从团队中心转为团队和管理人员提供服务。在敏捷环境中，项目经理充当仆人式领导,其工作重点转变为引导需要帮助的人.促进团队的合作,项目经理要鼓励将责任分配给团队成员,分配给那些掌握完成任务所需要知识的人</p>
<h3 id="团队的构成"><a href="#团队的构成" class="headerlink" title="团队的构成"></a>团队的构成</h3><p>《敏捷宣言》的价值观和原则的一个核心宗旨是强调个人和交互的重要性.敏捷优化了价值流,强调了客户快速交付功能,而不是怎么样用人.要善于激励项目人员,为他们提供所需要的环境和支持,信任他们能够完成工作.</p>
<ul>
<li>敏捷优化了价值流好处<br>1.人员更有可能合作<br>2.团队更快地完成价值地工作<br>3.由于不从事多余任务，没必要重新建立环境,团队减少了时间浪费<br><img src="/acp/%E6%95%8F%E6%8D%B7%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C.png" alt="敏捷团队合作" title="敏捷团队合作"></li>
</ul>
<h4 id="敏捷团队角色"><a href="#敏捷团队角色" class="headerlink" title="敏捷团队角色"></a>敏捷团队角色</h4><p><img src="/acp/%E6%95%8F%E6%8D%B7%E5%9B%A2%E9%98%9F%E8%A7%92%E8%89%B2.png" alt="敏捷团队角色" title="敏捷团队角色"></p>
<h4 id="识别团队人才"><a href="#识别团队人才" class="headerlink" title="识别团队人才"></a>识别团队人才</h4><p>敏捷团队是跨职能的,往往由T型人才(横向)和I型人才(纵向)组成;由于团队密切合作和自我组织,敏捷团队才能够迅速完成工作,这就是需要相互帮助成为常态.敏捷团队成员都要致力于培养这样的特质。一个人的能力大小无关紧要。如果给其他团队其他成员来的瓶颈问题,集中于某一个人能力甚至是有害的.团队的目的是优化已经完成工作,并且获得反馈</p>
<h4 id="尽力使得小组成员形成专职"><a href="#尽力使得小组成员形成专职" class="headerlink" title="尽力使得小组成员形成专职"></a>尽力使得小组成员形成专职</h4><p>　　　经常会出现团队成员不是100%为团队专职工作,这样情况经常无法避免.多任务处理缓解了整个团队的进展,因为团队要浪费时间切换环境或者相互等待其他工作完成.当人员100%为团队专职工作时,团队最有可能最快产出.如果让一个团队非100%投入,这样带来的问题是，处理多任务但是会降低团队的产出,并影响团队从燃尽图预测交付能力一致性。而且随着任务增加,效率损失呈指数增加。关键人们减少投入精力,在一心多用同时更加容易犯错误.任务频繁切换会消耗工作记忆,多任务处理不太可能记住对于的工作背景和其中技术，也不利团队成员沉淀与发展。<br>　　　追逐太阳的开发过程是一种每天结束工作时将工作移交到下一个工作状态,并不要是要求团队中拥有自身需要的全部角色。例如DBA，如果有外部团队成员来支援,则需要确定这名成员能否100%专职？分配支援时间多久？对团队每个人设定期望</p>
<h4 id="团队工作场所"><a href="#团队工作场所" class="headerlink" title="团队工作场所"></a>团队工作场所</h4><p>分散式管理团队沟通技术包括鱼缸窗口和远程结对</p>
<ul>
<li>鱼缸窗口：通过视频会议链接不同地点团队,创建鱼缸窗口.开始工作时，打开链接,工作结束时,关闭链接。以此来互动，减少不同工作地方所有滞后问题</li>
<li>使用虚拟工具来共享屏幕:包括语音和视频链接,建立远程结对,这样类似面对面结对一样有效</li>
</ul>
<h4 id="克服组织存在得孤岛"><a href="#克服组织存在得孤岛" class="headerlink" title="克服组织存在得孤岛"></a>克服组织存在得孤岛</h4><p><font color ="blue">作为敏捷的领导,首先重点放在如何组建跨职能团队,让所有团队成员100%投入团队工作.即使这只是意味关键团队成员(如开发和测试人员)每天一起工作交流，也是迈向敏捷方向一步.拥有不同技能的人共同组成团队,培养管理者和领导的敏捷思维模式,在敏捷开发早期就让他们参与其中.为了克服组织孤岛问题,就要与团队成员不同管理者合作，让他们为夸职能团队安排必要专职人员.这样不仅建立团队协同,而且能让组织看到怎么样用人才能优化进行中的项目和产品</front></p>
<h2 id="实施敏捷"><a href="#实施敏捷" class="headerlink" title="实施敏捷"></a>实施敏捷</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="项目章程"><a href="#项目章程" class="headerlink" title="项目章程"></a>项目章程</h4><p>每个项目都需要一个项目章程,这样项目团队就能了解项目之所以重要的原因,团队的前进方向以及项目的目标.</p>
<h4 id="团队章程"><a href="#团队章程" class="headerlink" title="团队章程"></a>团队章程</h4><p>对团队而言,还需要团队规范以及对一起工作方式的理解.这样就需要一个团队章程，制定章程的过程能帮助团队学习如何一起工作,怎样围绕项目协作。对于敏捷而言,团队至少还需要项目愿景或目标,以及一组清晰的工作协议.</p>
<p>项目需要回答一下问题</p>
<ol>
<li>我们为什么做这个项目?项目愿景</li>
<li>谁会从中受益?如何受益?这是可能项目愿景和/或项目目标的一部分</li>
<li>对此项目而言,达到那些条件才意味着项目完成?这些是项目的发布标准</li>
<li>我们怎么样合作?这就说明预期的工作流,仆人式领导可以促进章程的制定过程.团队可以通过一起工作实现协作,而制定项目章程是一种很好的开始工作的方式.此外,团队成员可能希望通过协作了解他们将如何一起工作。只要团队知道如何一起工作,制定章程就不需要一个正式的过程.有些团队可以从团队制定章程的过程中受益。下面是对团队成员制定章程的一些建议,可以将其作为制定团队社会契约的基础<ol>
<li>团队价值观:如何可持续的开发速度和核心工作时间</li>
<li>工作协议: 例如”就绪”如何定义,这是团队可以接受工作的前提;”完成”如何定义,这样团队才能一致的判断完整性;考虑时间盒;使用工作过程限制;</li>
<li>团队规范,例如团队如何对待会议时间.仆人式领导可以与团队一起决定处理其他行为.</li>
</ol>
</li>
</ol>
<p><font color ="blue">请记住,团队的社会契约,即团队章程,将规定团队成员之间彼此互动方式。团队章程的目标是创建一个敏捷的环境,在这个环境中,团队成员可以发挥他们作为团队的最大能力</font></p>
<h3 id="Retro-Meeting-回顾"><a href="#Retro-Meeting-回顾" class="headerlink" title="Retro Meeting(回顾)"></a>Retro Meeting(回顾)</h3><p>Retro 是一个最重要的实践,原因是它能让团队学习,改进和调整其过程。回顾可以帮助团队从之前的产品开发工作及其过程中学习.在敏捷宣言里背后的原则之一:”团队要定期反省如何能够做到更加有效,并相应地调整团队的行为”</p>
<h4 id="回顾的关键时刻"><a href="#回顾的关键时刻" class="headerlink" title="回顾的关键时刻"></a>回顾的关键时刻</h4><ol>
<li>当团队完成一个发布或者加入一些功能时.这不一定是一个巨大的增量,它可以是任何发布,无论它有多小</li>
<li>当团队出现问题时,以及团队协作完成工作不顺畅时</li>
<li>当团队达到任何其他里程碑时,团队可以通过分配足够时间学习受益,无论时在项目中间回顾,还是在项目结束时回顾.团队需要了解他们的工作产品和工作过程。例如，有些团队在完成工作时遇到困难,团队可以计划用充足的时间组织回顾,以此收集数据,处理数据,再决定之后要尝试的实验做法.<ol>
<li>首要的是,回顾并不是责备;回顾是让团队以从前的工作中学习并做出小的改进</li>
<li>回顾针对定性的(人的感觉)和定量的(权衡指标)数据,然后利用这些数据找到根源,设计对策,并制定行动计划.项目团队可以采取许多行事项来消除障碍</li>
<li>考虑限制行动事项的数量,使团队在进行的迭代或工作期限间有能力改进.尝试依次改进太多的事情却没有完成其中任何一件,比计划完成较少的事情并成功全部完成要糟糕得多.然后在时间允许得情况下,团队可以进行列表中得下一个改进。团队选择改进时,要决定如何衡量结果。然后，下一段时间内要权衡结果.以验证每个改进成功与否。团队引导者通过一个活动对所有改进事项得重要性进行排序.完成对改进事项得排序后,团队为下一次迭代选择合适得数量(或者在流程基础上增加工作)</li>
</ol>
</li>
</ol>
<h4 id="待表事项列表"><a href="#待表事项列表" class="headerlink" title="待表事项列表"></a>待表事项列表</h4><p>工作开始之时,只需要了解第一个发布主要内容正确即可,不需要为项目创建所有故事。考虑使用影响地图查看产品如何组合在一起.产品负责人可能会制作一个产品路线图,以显示预期得可交付成果序列，这样产品负责人根据团队得实际成果重新规划路线图。</p>
<h4 id="待办列表细化"><a href="#待办列表细化" class="headerlink" title="待办列表细化"></a>待办列表细化</h4><p>在执行敏捷过程中,产品责任人在多次得会议里,目的细化足够得故事，让团队充分了解故事内容,以及故事之间得相互关系.</p>
<ul>
<li>许多基于迭代敏捷团队在两周得迭代中用了1小时的时间盒讨论(团队选择一个迭代持续时间,为他们提供足够频繁反馈)</li>
<li>基于迭代的敏捷团队的多次细化讨论,团队可以在陌生的产品,产品领域或问题领域使用这一技巧；同时在细化过程，产品负责可以让团队了解故事中潜在的挑战或问题.如果产品负责人不确定依赖关系,还可以请求团队对相应功能进行刺探,以便了解风险。</li>
</ul>
<p>产品负责细化代表事项列表</p>
<ul>
<li>鼓励团队在开发人员,测试人员,业务分析人和产品负责人三方合作开展讨论和撰写故事</li>
<li>把这个故事的概念呈现给团队,团队进行讨论,并根据需要将其细化为许多故事</li>
<li>产品负责人需要与团队一起寻找各种方法探索和撰写故事,确保所有的故事足够小,以便团队能源源不断地交付完成地工作.考虑每天至少完成一个故事，团队通常有个目标，就是每周用不超过1小时地时间来为下一批工作细化故事。团队希望把时间尽可能花在工作上,而不是计划上.如果团队每周花1小时以上来细化故事,那么产品负责人可能会过度准备或者团队可能缺乏评估和细化工作地一些关键技能</li>
</ul>
<h3 id="每日站立会"><a href="#每日站立会" class="headerlink" title="每日站立会"></a>每日站立会</h3><p>站立会存在目的:1.为了发现存在问题。2.知道团队/队员进度状态,给予及时帮助.3.不在会上解决问题</p>
<h4 id="关注每个人进度"><a href="#关注每个人进度" class="headerlink" title="关注每个人进度"></a>关注每个人进度</h4><p>规定每日站立会地时间盒子:一般不超出15分钟<br>每个人轮流回答以下问题</p>
<ol>
<li>昨天来我都完成了什么？</li>
<li>接下来今天我打算完成什么？</li>
<li>我遇到地障碍/风险/问题是什么？<br>这样地问题得出的答案能够让团队自我组织,并让团队成员完成之前承若地工作承担地责任.<h4 id="关注团队产出"><a href="#关注团队产出" class="headerlink" title="关注团队产出"></a>关注团队产出</h4>可以从看板中从右到左进行评估</li>
<li>我们还需要做些什么来推进这一工作？</li>
<li>作为一个团队,我们需要完成什么?</li>
<li>工作流程是否存在瓶颈或阻碍？</li>
</ol>
<h4 id="反模式1"><a href="#反模式1" class="headerlink" title="反模式1"></a>反模式1</h4><p>站立会成为状态报告会议,传统上在预测环境中工作地团队可能倾向于采用这样反模式,因为他们习惯报告状态。鼓励任何团队成员主持会议而不是由项目经理或者领导主持,确保它不会变成状态报告会议,而是作为团队进行自我组织相互承诺地会议。</p>
<h4 id="反模式2"><a href="#反模式2" class="headerlink" title="反模式2"></a>反模式2</h4><p>当问题变得明显时,团队才开始解决问题.站立是为了发现问题而不是解决他们.发现地问题可以记录在停车场,然后创建会议，并解决问题。将团队地注意力吸引到反模式,并帮助团队发现如何改进战会.团队可以举办自己的战会,只要体现团队工作需要密切合作，进行顺利,战会就非常有用.</p>
<h4 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h4><p>要针对团队何时需要站会，站会是否有效等问题有意识地做出决定</p>
<h4 id="Retro-Meeting-展示-评审"><a href="#Retro-Meeting-展示-评审" class="headerlink" title="Retro Meeting(展示/评审)"></a>Retro Meeting(展示/评审)</h4><p>当团队完成用户故事的形式完成特定功能时,团队会定期展示工作产品.看过展示后,产品负责人接受或拒绝故事。在基于迭代敏捷中,团队在迭代结束时展示所有已完成工作项,基于敏捷流程的敏捷中,团队在需要时完成展示工作,通常是当完成的功能积累到足以构成一个连贯组合时,团队包括产品负责人都需要反馈来决定合适需要产品反馈。</p>
<p>一般做法是:没两周至少展示一次团队工作产品,这样频率对于大多数团队来说是足够的,这样,团队成员就可以得到反馈,防止他们朝着错误方向前进。这样的频率也可以让团队保持产品开发足够清晰,按照自己希望或需要的频率构建一个完整产品.如果没有展示/回顾/评审的团队,其学习书读不会快,也可能没采用敏捷技术</p>
<h4 id="规划故事注意"><a href="#规划故事注意" class="headerlink" title="规划故事注意"></a>规划故事注意</h4><ol>
<li>充分了解:提前一个sprint,关注下一个sprint是否有节假日,以及人员是否存在请假.最好做表格统计<br>团队不能100%确定自己能够交付什么,因为他们无法知道意外情况。当产品负责人拆分故事使其变为小的时候,团队看到的是产品的完成进度,团队就知道他们将来能够作什么。</li>
</ol>
<h4 id="注重交付产品价值-质量"><a href="#注重交付产品价值-质量" class="headerlink" title="注重交付产品价值(质量)"></a>注重交付产品价值(质量)</h4><p>如果团队不重视质量,那就无法快速发布任何东西,需要返工导致不断延期</p>
<ol>
<li>持续集成.无论产品如何都要频繁将工作集成到整体中,然后再进行重新测试,以确定整个产品然按照预期工作</li>
<li>在不同层面测试.对端到端信息使用系统及测试,对构建使用单元测试.两者之间,了解是否需要进行集成测试,以及在何处进行测试。团队发现冒烟测试有助于测试工作产品是否良好.以便决定何时以及对那些产品进行回归测试,可以帮助他们在维护产品质量的同时,良好构建性能。自动化测试可以让团队构建保持交付的产品能力提高</li>
<li>验收测试驱动开发(ATDD).在ATDD中，整个团队聚集一堂讨论工作产品的验收标准.然后团队创建测试,让这个团队能够编写足够的代码进行自动化测试,满足标准要求。</li>
<li>测试驱动开发(TDD)和行为驱动开发(BDD).在创建或编写产品之前些自动化测试,实际可以帮助人员设计产品，防止产品无耻</li>
<li>刺探(实际盒研究或实验)刺探对学习何有用,可以在诸如评估,验收标准定义以及通过产品了解用户行为的流程中使用</li>
</ol>
<h3 id="敏捷痛点及解决方法"><a href="#敏捷痛点及解决方法" class="headerlink" title="敏捷痛点及解决方法"></a>敏捷痛点及解决方法</h3><p><img src="/acp/%E6%95%8F%E6%8D%B7%E7%97%9B%E7%82%B9%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png" alt="敏捷痛点及解决方法" title="敏捷痛点及解决方法"><br><img src="/acp/%E6%95%8F%E6%8D%B7%E7%97%9B%E7%82%B9%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952.png" alt="敏捷痛点及解决方法2" title="敏捷痛点及解决方法2"></p>
<h3 id="衡量敏捷团队的衡量结果"><a href="#衡量敏捷团队的衡量结果" class="headerlink" title="衡量敏捷团队的衡量结果"></a>衡量敏捷团队的衡量结果</h3><p>预测型衡量指标问题再于,他们往往并不反映真实情况。有时候会到项目上线前才暴露问题,这项目也是西瓜项目(外面绿里面红)。而敏捷项目衡量指标含有意义的信息,这些信息提供了历史记录,项目团队可以利用这些数据改进和决策。<br>团队可以根据自己的情况收集定性衡量指标.这些指标侧重于团队选择的实践,评估团队使用这些实践情况，例如对交付功能的业务满意度,团队的士气;团队希望跟踪的任何东西都是定性衡量指标</p>
<p>敏捷倾向于使用基于经验和价值的衡量指标,而不是预测型衡量指标。敏捷团队的能力(故事点数)达到平衡,就能根据这些数量很来衡量预估后续项目时长。或者当团队成员开发故事点数趋于平稳,也可以预估个人开发能力;同时实时监控团队还有多少工作,以及团队是否能够按时完成工作</p>
<h4 id="故事的点数评估要素"><a href="#故事的点数评估要素" class="headerlink" title="故事的点数评估要素:"></a>故事的点数评估要素:</h4><ol>
<li>任务本身的难易程度</li>
<li>繁琐度/复杂度</li>
<li>风险<br>误区:有些团队根据已完成的任务评估未完成的故事点,这是错误的,故事点衡量的是能力,而不是以及完成的工作。这违背了”可用的软件是衡量进度的主要指标”,当然这样的相对估算缺点是:无法比较各个团队或者团队之间的增加速度。<h4 id="敏捷流程衡量指标"><a href="#敏捷流程衡量指标" class="headerlink" title="敏捷流程衡量指标"></a>敏捷流程衡量指标</h4></li>
</ol>
<ul>
<li>交付周期: 交付一个工作项目总花费实际,从项目添加到看板到项目完成</li>
<li>周期时间: 处理一个工作项目所需的时间</li>
<li>响应时间:一个工作项目等待工作开始的时间<br><img src="/acp/%E6%95%8F%E6%8D%B7%E7%9C%8B%E6%9D%BF.png" alt="敏捷看板" title="敏捷看板"><br>当团队依赖外部团队时,衡量周期时间可了解团队完成工作所需要的时间。团队完成工作之后,衡量交付周期可了解外部依赖关系。还可以测量反应时间,从准备就绪到第一列时间,了解平均需要多长时间才能对新需求响应</li>
</ul>
<h4 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h4><p>团队会发现一般要4-8次迭代才能达到稳定速度,团队需要从每个迭代中获得反馈,了解他们工作情况以及如何改进。<br>作用:团队能查看他们的已完成工作,也能显示迭代过程范围的变化，这将有利对项目进一步安排。迭代结束时,他们可能根据自己在这个迭代中完成工作的能力(多少故事或故事点)来建立他们下一个迭代的能力衡量指标,这样就能让产品负责人与团队一起重新规划,团队就更有可能在下一次迭代中成功交付,同时实际完成的点数也代表速度,可以通过观察历史数据来估算团队的能力，以便规划下一阶段项目工作;</p>
<ul>
<li><p>功能图(燃尽图/燃起图)<br>功能图可以显示项目期间需求的发展情况.功能完成线显示团队以正常速度完成功能.<br>总功能线显示了项目的总功能随时间的变化.剩余的燃尽线显示功能完成速度的变化.每次在项目中添加功能时,燃尽线都会有改变。</p>
</li>
<li><p>产品代办列表燃起图<br><img src="/acp/%E4%BA%A7%E5%93%81%E4%BB%A3%E5%8A%9E%E5%88%97%E8%A1%A8%E7%87%83%E8%B5%B7%E5%9B%BE.png" alt="产品代办列表燃起图" title="产品代办列表燃起图"><br>产品代办事项列表燃气图显示已经完成的工作与区间里程碑或迭代中的预期工作总量的比较</p>
</li>
<li><p>敏捷体系挣值<br>一个团队一次只能完成一个故事,为了完成一个包含多个故事的打功能.团队会有待完成剩余故事,并且除非拥有更多时间，否则可能无法完成整个功能.团队可以用一个产品代表事项列表燃起图来显示已经完成的价值。如果一个团队需要衡量挣值,可以考虑起用燃起图:如SPI=实际完成故事点/计划故事点，CPI= 完成的价值成本 /实际使用成本</p>
</li>
<li><p>累积流图<br>累积流图显示了看板上进行的工作。如果一个团队有许多等待测试的故事,项目测试团队将会扩大。积累工作一目了然,团队处理积累工作方面有困难,团队进行中的工作,而不是已经完成的工作,如果团队有大量进行的工作,就会延迟整体功能交付.团队交付越长,相同时间内有更多功能,团队压力越大;可以将累积流图调整到项目任务搬<br><img src="/acp/%E7%B4%AF%E7%A7%AF%E6%B5%81%E5%9B%BE.png" alt="累积流图" title="累积流图"></p>
</li>
</ul>
<h2 id="关于敏捷性考虑要素"><a href="#关于敏捷性考虑要素" class="headerlink" title="关于敏捷性考虑要素"></a>关于敏捷性考虑要素</h2><p>这里探讨组织及(某些情况下)项目环境影响项目的方式,领导可以通过探讨变革方案来提高项目成功率。如果组织能够做出相应调整,则可以提高项目敏捷性的效率和适用性</p>
<h3 id="传统变革到敏捷因素"><a href="#传统变革到敏捷因素" class="headerlink" title="传统变革到敏捷因素"></a>传统变革到敏捷因素</h3><h4 id="与加速交付管理的变革"><a href="#与加速交付管理的变革" class="headerlink" title="与加速交付管理的变革"></a>与加速交付管理的变革</h4><p>敏捷方法强调频繁并尽快交付项目的输出.但是接受组织可能尚未做好加速纳入这些输出的充分准备.加速交付将会考虑组织适应该交付能力.成功发现和交付项目功能是不够的.如果组织抗拒项目输出,则会延迟项目的投资回报,客户接受并支持项目输出在敏捷环境中日益盛行</p>
<h4 id="与敏捷方法相关的变革"><a href="#与敏捷方法相关的变革" class="headerlink" title="与敏捷方法相关的变革"></a>与敏捷方法相关的变革</h4><p>组织在刚开始采用敏捷方法时也会经历更高程度的变革.高级别协作可能需要团队,部门或供应商之间频繁的交流.将工作分解到迭代原型时会涉及到不利的返工.领导应该考虑利用变革管理技术来解决过度到敏捷方法时所遇到的阻碍。</p>
<h4 id="变革考虑组织文化"><a href="#变革考虑组织文化" class="headerlink" title="变革考虑组织文化"></a>变革考虑组织文化</h4><p>组织在开始采用敏捷方法时应该了解这些方法与当前方法之间的相对兼容性.某些组织特征可能跟容易支持跨部门协作,持续学习和内部过程演变等敏捷原则<br>正面变革友好型特征包括:</p>
<ol>
<li>管理层的变革意愿</li>
<li>组织在员工认知,审核和评估方式上做出改变的意愿</li>
<li>集中或分散项目,项目集和项目组合管理职能</li>
<li>专注于短期预算和指标而不是长期目标</li>
<li>人才管理成熟度和能力</li>
</ol>
<p>反面变革特征:</p>
<ol>
<li>工作被分解为部门孤岛,从而创造出阻碍加速交付的依赖关系,而不是构建在能力中心指导下的跨职能团队</li>
<li>采购策略基于短期定价策略,而不是长期能力</li>
<li>奖励领导的一句是本地效率而不是端到端项目交付流或整体优化情况(就组织而言)</li>
<li>员工属于特定领域人才,实现技能多元化的工具或激励有限,不重视培养T型人才</li>
<li>分散化项目组合使员工同时分配到过多的项目,而无法专注于单个项目.组织审查和修改这些实践的意愿程度将决定采用敏捷方法的速度和效率。但是,为了解决这些敏捷组织障碍,项目领导可以尝试多种方法来加速文化兼容:<ol>
<li>积极明确管理层支持</li>
<li>变革管理实践，包括沟通和引导</li>
<li>逐个项目应用敏捷实践</li>
<li>向团队增量引入敏捷实践</li>
<li>通过采取适用的敏捷技术和实践示范引导</li>
</ol>
</li>
</ol>
<h3 id="组织文化"><a href="#组织文化" class="headerlink" title="组织文化"></a>组织文化</h3><p>组织文化就是组织的DNA-组织的核心标识.文化始终影响敏捷方法使用.组织文化一直在连续运转.从高预测计划到一切皆为实验的精益创业阶段皆有体现.尽管敏捷方法与精益创业文化相当吻合,高预测型组织可以鼓励实证的衡量指标,小型实验和不断学习一边向敏捷方向转变。<br><font color="red">敏捷强调人的承诺和热情对于一份事业的重要性，无论您在团队中实施何种策略计划,其成功与否将会受到实施该计划得人员的控制.如果推动策略的人员对变革没有热情，甚至漠视其工作和组织,则您可能没有机会实施变革</font>组织文化难以改变，但是组织中最重要的文化规范一愿意尝试任何新方法或技术只有在安全,诚实和透明的环境中,团队和领导才可以真正反思其成功,确保项目持续进步,或者应用从失败项目中所吸取教训,不在重蹈覆辙。</p>
<h4 id="评估文化"><a href="#评估文化" class="headerlink" title="评估文化"></a>评估文化</h4><p>每个项目都会遇到相关方意愿相左的棘手情况.</p>
<ol>
<li>团队如何在不影响质量的情况下取得快速进展?</li>
<li>团队如何在保留灵活性的同时确保时效性?</li>
<li>更重要的是,团队如何满足客户要求</li>
</ol>
<p>项目领导可能感觉其职责就是满足各个相关方的期望;但是在面对选择时,通常需要根据组织业务环境的文化和要求来确定优先级；如电信项目偏重于速度，而政府项目可能偏重于大宗化和稳定性。要引导这些动态变化, 项目领导应该花费时间去评估组织通常所关注的重点。下面是项目领导发起与相关方,团队成员和高层管理者对话以讨论组织优先级,这些优先级根据滑动尺标在这两个极端之间的位置来进行记录,然后再利用该结果去找最合适这些优先级的敏捷技术，有些模型可以用于评估这些变动，<font color ="red">选哪个评估并不重要,重要的是了解某组织需要满足的组织与行业需求后才能选择合适对话,权衡尤其是技术。</font><br><img src="/acp/%E4%BC%98%E5%85%88%E7%BA%A7%E8%AF%84%E4%BC%B0%E8%A1%A8.png" alt="优先级评估表" title="优先级评估表.png"><br>有些人坚持在开始各种文化转型前构建新的组织结构.还有些人持相反意见,认为新型组织结构只是表面的调整,只有集体文化朝着有意义的方向转变才是根本.实际上,任何一方都是孤掌难鸣,如果要实现敏捷,项目领导应同时考虑其组织这两方面的当前和未来状态.</p>
<h3 id="采购合同"><a href="#采购合同" class="headerlink" title="采购合同"></a>采购合同</h3><p>协作方法提倡共担项目风险和共享项目奖励的关系,实现所有方共赢。设计这样动态特性合同签署技术包括</p>
<ol>
<li>多层结构.除了在单个文档中正式说明整个合同关系, 项目方可以通过不同文档中说明不同方面来提高灵活性.通常固定项目(担保/仲裁)可以锁定在主协议中.同时所有方将可能会更变的其他项目(服务价格/产品说明)列服务明细表中.合同主要服务协议中注明这些服务参考.最后范围进度计划和预算等更多动态变化项目可以列在轻量级工作说明书中。多动态变化项目可以列在轻量级工作说明书中。通过将合同中更多变化因素隔离到单独的文档中，将会简化修改工作并提高灵活性。</li>
<li>强调价值交付.许多供应商关系是专注于中间人因素的固定里程碑或阶段关口控制,而不是由增量业务价值完全可交付成果控制。通常,这些控制会限制利用反馈来改进产品。与之相反的是,里程碑和支付项目可以根据价值驱动可交付成果来构建，以增强项目敏捷性</li>
<li>总价增量。可以将范围化解为总价微型可交付成功(用户故事),对于供应商而言,这可以限制对单个功能或可交付成果的过多承诺所带来的财务风险</li>
<li>固定时间和材料。客户在采用传统的时间和材料方法时会产生不必要的风险。一种替代方法是将整体预算限制为固定数量。这就允许客户在最初未计划的项目中纳入新的观点和创新。如果客户需要纳入新的观点,则必须管理给定能力,用新的工作来替代原有工作。应密切监控工作防止所分配的时间超过限制。此外,在认为有用的情况下,还可以在最大预算中规划额外应急<br>时间。</li>
<li>累进的时间和材料。一种替代方法是共担财务风险法在捷法中,质量标准是已完成工作的一部分如果在合同期限之前交付,则可对供应商的高率进行奖励。相反,如果供应商延迟交付,则扣除一定费用。提前取消方案。如果敏捷供应商在仅完成一半范围时便可交付足够的价值,且客户不再需要另外一半范围,则不必支付这部分费用。但合同中可以规定客户应为项目剩余部分支付一定的取消费用。因为不再需要这些服务,客户可以限制预算敞口,而供应商也获得可观的收入</li>
<li>动态范围方案。对于具有固定预算的合同，供应商可为客户提供在项目特定点改变项目范围的方案。客户可调整功能以适应该能力。这样客户便可利用创新机会，同时限制供应商的过度承诺风险。</li>
<li>团队扩充。大多数协作合同方法是将供应商服务直接嵌入客户组织中。通过资助团队而不是特定范围，可以保留客户自行确定需要完成工作这方面策略的权力。</li>
<li>支持全方位供应商。为了分化风险，客户可能需要采取多供应商策略。但是，这样签署合同的结果是，每家供应商只能负责一项工作，这就会产生许多依赖关系，阻碍可行服务或产品的交付。相反，要强调提供全面价值的合约（这与已完成独立功能集中的观点相符）。</li>
<li>可以创建敏捷合同。敏捷是在协作和信任的共同基础上建立的。如果供应商能够尽早频繁交付价值，则有助于实现这一点。如果客户能够提供及时反馈，则有助于实现这一点。</li>
</ol>
<h3 id="商业实践"><a href="#商业实践" class="headerlink" title="商业实践"></a>商业实践</h3><p>在需求产生时,组织创建新能力的意和能力即是组织敏捷性的标志。对于关注敏捷及其所提供结果的组织而言,这些不必是颜覆性的变革,破坏性较小。适明和开放协作至关重要。在跨职能团队交付价值时,团队和个人可能会遇到组织多种支持职能方面的可题。如果团队定期交付价值,财务部]可能有机会以不同的方式获得产品收益。如果团队与其他组织签署了合同,采购部门可能需要变更这些合同以帮助其他组织频交付价值并与团队保持同团队开始以团结协作的方式展开工作后,将会对内部管理策略提出挑战。人力资源可能注意到个人激励不足,而经理可能会在自组织员工的绩效评估方面绞尽脑汁。在各种情况下都有机会评审现有实践对敏捷工作方式的支持程度。当组织发展到更高敏捷性时,其他业务部门将有必要更改其交互方式并履行自己的职责。现在应拥护对组织其他领域有益的变更,以此来提高整个组织的效率</p>
<h4 id="多团队协作和依关系-扩展"><a href="#多团队协作和依关系-扩展" class="headerlink" title="多团队协作和依关系(扩展)"></a>多团队协作和依关系(扩展)</h4><p>多个项目之间会产生依赖关系,即使不是在给定项目集中进行管理。因此有必要了解敏捷工作在现有项目集和项目组合管理环境下的工作方式</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>大多数流行敏捷方法(如 Scrum和极限编程)的指导专注于单个小型目通常是集中办公的跨职能团队活动。这对于需要单个团队的工作非常有用,但对于需要在一个项目集或项目组合中进行多个敏捷团队协作的举措却显得捉襟见肘。目前已出现许多框架(如大规模捷框架、大规模捷开发和规范敏捷)和方法(例如 ScrumofScrums)来应对这种情况。有关这些框架和方法的更多详细信息</p>
<h4 id="考虑事项"><a href="#考虑事项" class="headerlink" title="考虑事项"></a>考虑事项</h4><p>有多种扩展工作的方式。团队可能需要将多个敏捷项目工作扩展到单个敏捷项目集中。或者,组织可以设计出支持整个项目组合中不同敏捷方法的结构。例如,可以从小项目着手,然后尽快了解组织环境中比较适合的方式。即使一切还未完全转换到敏捷方法,团队仍可获得成功无论采用哪种方法,关键成功因素是健康的敏捷团队。如果单个团队采取敏捷方法无法获得成功,则勿尝试将其扩展到更大范围;而是要先行解决阻止团队敏捷工作的组织障碍。大规模敏捷项目的目标是协调不同团队的工作以便为客户提供价值。这有多种实现方式。团队可以采用正式的框架或应用敏捷思维调整现有项目集管理实践</p>
<h4 id="敏捷和项目管理办公室-PMo"><a href="#敏捷和项目管理办公室-PMo" class="headerlink" title="敏捷和项目管理办公室(PMo)"></a>敏捷和项目管理办公室(PMo)</h4><p>设立PMO的目的是引导组织实现商业价值。可以通过帮助实现项目目标来做到这一点。PMO有时还会提供团队教育(或安排培训)和项目支持。PMO还会针对给定项目或项目集提供相关商业价值方面的管理建议由于敏捷会带来文化变更,随看时间的推移,组织可能也需要变更,包括PMO。例如,经理会决定资助的项目及其时间,团队会决定培训或建议需求。</p>
<h4 id="敏捷PMo为价值驱动型"><a href="#敏捷PMo为价值驱动型" class="headerlink" title="敏捷PMo为价值驱动型"></a>敏捷PMo为价值驱动型</h4><p>所有项目都应在合适的时间为合适的受众提供合适的价值。PMO的目标是帮助促进这个目标的实现。基于敏捷的PMO方法以客户协作思维为基础,并存在于所有PMO项目集中。在许多情况下,这意味看PMO的运营方式类似于咨询企业,需要根据给定项的特定需求来定制其工作。有些项目可能需要工具和模板,还有些项目可能会从管理层引导获益。PMO应努力按需交付并紧跟客户需求确保了解并适应他们的需求。这种內部创业方法专注于能为所支持的项目提供最大价值的PMO活动。</p>
<h4 id="敏捷PMo为面向创新型"><a href="#敏捷PMo为面向创新型" class="headerlink" title="敏捷PMo为面向创新型"></a>敏捷PMo为面向创新型</h4><p>为了在基于价值的章程下加速发展,PMO可能需要强制执行某些解决方案或方法,例如,保持所有人行动的一致性以快速获得成功。但需要确保员工的参与意愿才能提高效率。只邀请感兴趣的人员参与PMO服务即可实现这一点。PMO实践的参与度越高,便更容易提高这些实践的“粘合力”。如果PMO为其客户提供了价值,则客户很可能会要求这种服务并采用其实践。</p>
<h4 id="敏捷PMo为多学科型"><a href="#敏捷PMo为多学科型" class="headerlink" title="敏捷PMo为多学科型"></a>敏捷PMo为多学科型</h4><p>为了支持特定项目需求,PMO还需要熟悉项E管理本身以外的其他一些能力,因为不同的项要求不同的能力。例如,一个项目可能需要组织设计来解决人员配备挑战,而另一个项目可能需要组织变革管理技术来确保相关方参与或获得独特的业务模型以支持客户目标某些组织已将其PMO转换为卓越敏捷中心以提供以下服务制定和实施标准。提供用户故事、测试案例、累积流图等模板,提供敏捷工具并培训支持小组了解迭代开发概念□通过培训和指导发展人才。协调敏捷培训课程、教练和导师以帮助员工过渡到敏捷思维模式并升级其技能。鼓励和支持员工参与本地敏捷活多项目管理。通过不同项目交流协调敏捷团考虑分享进度、问题、回顾性发现和改进实验等内容。借助适当的框架,帮助管理项目层的主要客户发布和项目组合层的投资主题促进组织学习。收集项目进度信息并获取、存储和记录回顾性发现成果管理相关方。提供产品负责人培训,指导验收测试以及评估方法,并提供系统反馈。宣扬主题专家(SME对项目的重要性招聘、筛选和评估项目领导。制定敏捷实践者访谈指南。执行专业化项目任务。培训和提供回顾促进者,与敏捷项目问题解决者订立协议,并提供导师和教练。</p>
<h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>组织结构会严重影响其转向新信息或转变市场需求的能力。下面列出了主要特征地理。地理分散的项目组织可能会在各种项发现阻碍工作进展的一些挑战。项目领导和区域经理可能持有不同或相反的目标。此外,文化差异、语言障碍和低可视化可能会降低工作效率。幸运得是,采用敏捷方法可以鼓励更好的协作并提高信心。在这些环境下,项目领导应鼓励团队和管理层对话,定制该环境所需的技术并管理对工作需求的期望职能结构。有些组织按照高度项目型、矩阵型或高度职能型的方式构建。具有髙度职能结构的项目可能会在组织内部协作方面遇到很大阻项目可交付成果的大小。缩小项目可交付成果将会激励部门之间更频繁的交流,由此带来更频繁的交互以及组织内部更快速的价值流动。项目人员分配。另一种方法是在各个部抽出一个人,将其临时完全分配到最高优先级项重釆购型组织。有些组织选择主要通过供应商实施项目。尽管项目目标可能非常明确,供应商也有责任监管自己的财务状况。但是,供应商完成其义务并退出合约后,相关项目知识也将随之带走。这就会限制持续灵活性和速度所需的内部能力。如果在供应商还参与时采用敏捷技术(例如回顾和跟踪可能改进的领域),则可帮助缓解产品知识缺失情况。</p>
<h4 id="组织演变"><a href="#组织演变" class="headerlink" title="组织演变"></a>组织演变</h4><p>应对单个挑战领域或实施新的混合或敏捷方法时,建议以累积方式承接工作。常用实践是将变更过程视为一个敏捷项目,团队可以根据自己的价值观或其他考虑事项引入自己的变更待办事项列表并确定其优先级。每个变更可以被视为一个实验,将进行短时间测试以确定每个变更的适应性以及进一步细化/考虑需求。使用看板面板跟踪进度,显示已作为“已完成”使用的新方法、被视为“进行中”的方法以及仍在等待被引入“待办事项”的方法。请参见图6-3以了解具有待办事项列表排序的初始面板。图6-4显示了面板工作进度的示例</p>
<p>通过使用这些工具来组织和管理变更实施,将可提供进度的可视化并对正在实施的方法进行建模。以透明和吸引人的方式部署变更,将可以提高成功可能性。</p>
]]></content>
      <categories>
        <category>Project Management</category>
      </categories>
      <tags>
        <tag>敏捷</tag>
        <tag>ACP</tag>
      </tags>
  </entry>
  <entry>
    <title>PMP知识储备</title>
    <url>/2020/12/06/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-PMP%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>200道题,4个小时,10分钟要10道题速度答题,以10分钟为周期调整速度</p>
<p>1.理解问题关键词</p>
<ul>
<li>(特别是2选1)理解题目中提干意思是注重处理问题的过程还是注重处理问题结果</li>
<li>注意题目限定词</li>
</ul>
<p>2.答案要扣题: 对照题意：</p>
<ul>
<li>(特别是2选1)定义类问题：选了答案要连着校验或从词汇中解析对比已选答案</li>
</ul>
<p>3.问题解决流程</p>
<ul>
<li>发现问题</li>
<li>分析问题</li>
<li>解决问题</li>
</ul>
<p>甘特图:进度图<br>德尔菲技术:匿名反馈<br>亲和图:分组<br>帕累托图:主次图<br>蒙特卡洛技术:统计模拟方法</p>
<h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><h3 id="项目组织结构"><a href="#项目组织结构" class="headerlink" title="项目组织结构"></a>项目组织结构</h3><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt="项目组织结构" title="项目组织结构"></p>
<h3 id="项目一般周期-时间维度"><a href="#项目一般周期-时间维度" class="headerlink" title="项目一般周期(时间维度)"></a>项目一般周期(时间维度)</h3><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="项目生命周期" title="项目生命周期"></p>
<h3 id="项目投入曲线"><a href="#项目投入曲线" class="headerlink" title="项目投入曲线"></a>项目投入曲线</h3><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E6%8A%95%E5%85%A5%E6%9B%B2%E7%BA%BF.png" alt="项目投入曲线" title="项目投入曲线"></p>
<h2 id="五大过程组-项目管理维度-与十大知识领域-知识领域维度"><a href="#五大过程组-项目管理维度-与十大知识领域-知识领域维度" class="headerlink" title="五大过程组(项目管理维度)与十大知识领域(知识领域维度)"></a>五大过程组(项目管理维度)与十大知识领域(知识领域维度)</h2><p><img src="/pmp/%E5%8D%81%E4%BA%94%E8%87%B3%E5%B0%8A.png" alt="十五至尊" title="十五至尊"></p>
<h2 id="十五至尊图-1351"><a href="#十五至尊图-1351" class="headerlink" title="十五至尊图(1351)"></a>十五至尊图(1351)</h2><p><img src="/pmp/PMP%E5%8D%81%E4%BA%94%E8%87%B3%E5%B0%8A%E7%9F%A5%E8%AF%86.png" alt="PMP十五至尊知识" title="PMP十五至尊知识"></p>
<h3 id="47个过程组学习方法"><a href="#47个过程组学习方法" class="headerlink" title="47个过程组学习方法"></a>47个过程组学习方法</h3><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.png" alt="项目管理过程学习方法" title="项目管理过程学习方法"></p>
<h3 id="记忆逻辑图"><a href="#记忆逻辑图" class="headerlink" title="记忆逻辑图"></a>记忆逻辑图</h3><p><img src="/pmp/%E5%88%86%E8%A7%A31.png" alt="分解1" title="分解1"></p>
<p><img src="/pmp/%E5%88%86%E8%A7%A32.png" alt="分解2" title="分解2"></p>
<p><img src="/pmp/%E5%88%86%E8%A7%A33.png" alt="分解3" title="分解3"></p>
<p><img src="/pmp/%E5%88%86%E8%A7%A34.png" alt="分解4" title="分解4"></p>
<h2 id="项目整合管理"><a href="#项目整合管理" class="headerlink" title="项目整合管理"></a>项目整合管理</h2><p>1.知识点</p>
<ul>
<li>事业环境因素:是宏观的（如外部的法律、法规、国家政策与市场环境；内部的企业管理制度，文化等）</li>
<li>组织过程资产:是具体的（如流程与程序、模板、档案、经验教训、知识库等）</li>
<li>开工会议:在规划阶段结束之前召开</li>
</ul>
<p>2.变更请求</p>
<ul>
<li>更新(会改变项目管理计划或基准):对正式受控的项目文件或计划等进行的变更，以反映修改或增加的意见或内容</li>
<li>缺陷补救(维护基准)为了修正不一致的产品而进行的有目的活动</li>
<li>纠正措施(维护基准):为了使项目工作绩重新与项目管理计划一致而进行有目的活动</li>
<li>预防措施(维护基准:为了确保项目工作的未来业绩符合项目管理计划而进行有目的的活动</li>
</ul>
<p>3.项目收尾顺序:移交成果,更新资产</p>
<h3 id="4-1制定章程-启动"><a href="#4-1制定章程-启动" class="headerlink" title="4.1制定章程(启动)"></a>4.1制定章程(启动)</h3><p><img src="/pmp/4.1%E5%88%B6%E5%AE%9A%E7%AB%A0%E7%A8%8B.png" alt="制定章程" title="制定章程"></p>
<table>
<thead>
<tr>
<th>商业论证模型</th>
<th>数学模型</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/pmp/%E5%95%86%E4%B8%9A%E8%AE%BA%E8%AF%81%E6%A8%A1%E5%9E%8B.png" alt="商业论证模型" title="商业论证模型"></td>
<td><img src="/pmp/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B.png" alt="数学模型" title="数学模型"></td>
</tr>
</tbody></table>
<h3 id="4-2制定项目管理计划-规划"><a href="#4-2制定项目管理计划-规划" class="headerlink" title="4.2制定项目管理计划(规划)"></a>4.2制定项目管理计划(规划)</h3><p><img src="/pmp/4.2%E5%88%B6%E5%AE%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92.png" alt="制定项目管理计划" title="制定项目管理计划"></p>
<h3 id="4-3指导与项目管理工作-执行"><a href="#4-3指导与项目管理工作-执行" class="headerlink" title="4.3指导与项目管理工作(执行)"></a>4.3指导与项目管理工作(执行)</h3><p><img src="/pmp/4.3%E6%8C%87%E5%AF%BC%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C.png" alt="指导与项目管理工作" title="指导与项目管理工作"></p>
<h3 id="4-4监控项目工作-监控"><a href="#4-4监控项目工作-监控" class="headerlink" title="4.4监控项目工作(监控)"></a>4.4监控项目工作(监控)</h3><p><img src="/pmp/4.5%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C.png" alt="监控项目工作" title="监控项目工作"></p>
<h3 id="4-5变更控制-监控"><a href="#4-5变更控制-监控" class="headerlink" title="4.5变更控制(监控)"></a>4.5变更控制(监控)</h3><p><img src="/pmp/4.6%E5%8F%98%E6%9B%B4%E6%8E%A7%E5%88%B6.png" alt="变更控制" title="变更控制"></p>
<h4 id="变更控制流程"><a href="#变更控制流程" class="headerlink" title="变更控制流程"></a>变更控制流程</h4><ul>
<li>变更请求–&gt;[记录–&gt;分析—&gt;评估]–&gt;审批–&gt;更新–&gt;记录<br><img src="/pmp/%E5%8F%98%E6%9B%B4%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="变更控制流程" title="变更控制流程"></li>
</ul>
<h3 id="4-5项目结束或阶段-收尾"><a href="#4-5项目结束或阶段-收尾" class="headerlink" title="4.5项目结束或阶段(收尾)"></a>4.5项目结束或阶段(收尾)</h3><p><img src="/pmp/4.7%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9D%9F%E6%88%96%E9%98%B6%E6%AE%B5.png" alt="项目结束或阶段" title="项目结束或阶段"></p>
<h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><p>1.收集需求工具</p>
<ul>
<li>引导:</li>
<li>观察/交流:不愿意说</li>
<li>头脑风暴:聚集多人会议，敞开讨论</li>
<li>访谈:一对一访问交流</li>
<li>焦点小组:将问题缩小以主题形式讨论</li>
<li>问卷调查:收集分布比较广泛</li>
<li>标杆对照:有参照物对比</li>
<li>德尔菲技术：多伦匿名反馈收集,可以消除主观</li>
<li>原型图:支持渐渐明晰的理念，从创建模型，用户体验，反馈收集到原型修改的反复循环过程</li>
<li>名义小组：投票,排序</li>
</ul>
<p>2.数据表现</p>
<ul>
<li>亲合图:分类归集图</li>
<li>思维导图:</li>
</ul>
<p>3.知识点理解</p>
<ul>
<li>项目范围与产品范围:产品范围决定项目范围、项目范围服务于产品范围</li>
<li>范围蔓延:未经控制的产品或项目范围扩大</li>
<li>项目范围完成情况是根据项目管理计划来衡量，产品范围完成情况根据产品需求来衡量</li>
<li>工作绩效数据：原始观察结果和测量值</li>
<li>工作绩效信息:从各控制过程收集，并结合相关背景和跨领域关系进行整合分析而得到的绩效数据<ul>
<li>(十个知识点都有)监控过程:确认范围/控制范围，控制进度，控制成本，控制质量，控制资源，监督沟通，监督风险，控制采购和监督相关方</li>
</ul>
</li>
<li>工作绩效报告：对工作绩效信息进一步加工，整理，汇编而得到的，关于项目绩效的专题和综合报告<ul>
<li>不存在的知识领域有:范围管理,质量管理，采购管理，相关方管理</li>
</ul>
</li>
<li>WBS:全部工作范围层级分解,没有验收标准信息</li>
<li>WBS词典:针对每一个WBS每个组件，详细描述可交付成果以及验收标准</li>
</ul>
<h3 id="5-1规划范围管理-规划"><a href="#5-1规划范围管理-规划" class="headerlink" title="5.1规划范围管理(规划)"></a>5.1规划范围管理(规划)</h3><p><img src="/pmp/5.1%E8%A7%84%E5%88%92%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86.png" alt="规划范围管理" title="规划范围管理"></p>
<h3 id="5-2收集需求-规划"><a href="#5-2收集需求-规划" class="headerlink" title="5.2收集需求(规划)"></a>5.2收集需求(规划)</h3><table>
<thead>
<tr>
<th>收集需求</th>
<th>需求更新矩阵</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/pmp/5.2%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.png" alt="收集需求" title="收集需求"></td>
<td><img src="/pmp/5.2.1%E9%9C%80%E6%B1%82%E6%9B%B4%E9%87%8D%E7%9F%A9%E9%98%B5.png" alt="需求更重矩阵" title="需求更重矩阵"></td>
</tr>
</tbody></table>
<h3 id="5-3定义范围-规划"><a href="#5-3定义范围-规划" class="headerlink" title="5.3定义范围(规划)"></a>5.3定义范围(规划)</h3><table>
<thead>
<tr>
<th>定义范围</th>
<th>项目章程与项目范围内容区别</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/pmp/5.3%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4.png" alt="定义范围" title="定义范围"></td>
<td><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AB%A0%E7%A8%8B%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E5%86%85%E5%AE%B9%E5%8C%BA%E5%88%AB.png" alt="项目章程与项目范围内容区别" title="项目章程与项目范围内容区别"></td>
</tr>
</tbody></table>
<h3 id="5-4创建WBS-规划"><a href="#5-4创建WBS-规划" class="headerlink" title="5.4创建WBS(规划)"></a>5.4创建WBS(规划)</h3><p><img src="/pmp/5.4%E5%88%9B%E5%BB%BAWBS.png" alt="创建WBS" title="创建WBS"></p>
<h3 id="5-5确认范围-监控"><a href="#5-5确认范围-监控" class="headerlink" title="5.5确认范围(监控)"></a>5.5确认范围(监控)</h3><p><img src="/pmp/5.5%E7%A1%AE%E8%AE%A4%E8%8C%83%E5%9B%B4.png" alt="确认范围" title="确认范围"></p>
<h3 id="5-6控制范围-监控"><a href="#5-6控制范围-监控" class="headerlink" title="5.6控制范围(监控)"></a>5.6控制范围(监控)</h3><p><img src="/pmp/5.6%E6%8E%A7%E5%88%B6%E8%8C%83%E5%9B%B4.png" alt="控制范围" title="控制范围"></p>
<h2 id="项目进度管理"><a href="#项目进度管理" class="headerlink" title="项目进度管理"></a>项目进度管理</h2><p>1.专业词汇与技术</p>
<ul>
<li>里程碑：是项目重要时点或事件,是强制或可选,持续时间为0，即是一个事件点</li>
<li>收益递减法则：增加一个用于确定单位产出需投入的因素(资源)会最终达到一个临界点</li>
<li>帕金森定律:只要还有时间,工作就会不断扩展,直到用完所有的时间。也就是工作会不断扩展,直到用完所有时间,以至于造成最终延期</li>
<li>进度压缩技术2种<ul>
<li>赶工:投入成本换取进度</li>
<li>快速跟进:将正常情况下顺序进行活动改为并行活动</li>
</ul>
</li>
<li>资源优化技术2种<ul>
<li>资源平衡:过度分配,解决关键路径上的资源不足,将非关键路径上的资源借调到关键路径上,保证关键路径上的时间进度,但是可能因为借调太多导致导致关键路径发生改变。</li>
<li>资源平滑:在不影响关键路径的情况下使用自由浮动时间和总浮动时间</li>
</ul>
</li>
<li>活动之间的依赖关系有4种<ul>
<li>外部依赖关系:是项目活动与非项目活动之间的依赖关系</li>
<li>内部依赖关系:是项目活动之间的紧前关系，通常在项目团队的控制之中</li>
<li>强制性依赖关系:是法律或合同要求的或工作的内在性质决定的依赖关系</li>
<li>选择性依赖关系:是基于具体应用领域的最佳实践或者基于项目的某种特殊性质而设定，即便还有其他顺序可以选用，但项目团队仍缺省按照此种特殊的顺序安排活动</li>
</ul>
</li>
</ul>
<p>2.进度工具</p>
<ul>
<li>关键路径法分析:决定项目最早完成时间的活动(能完成项目最短工期),是项目网络图中最长的路径，并且有最少的浮动时间或时差</li>
<li>进度网络分析:前关系图、提前量、滞后量、强制内部、强制外部、选择外部</li>
</ul>
<p>3.项目浮动的3种时间</p>
<ul>
<li>1.自由浮动时间:不影响后续工作最早可以开始时间的前提下，这项工作可以拖延的时间叫做自由浮动时间<br>  自由活动时间=紧后活动的最早开始时间-紧前活动的最早结束时间</li>
<li>2.总浮动时间/总时差:不影响项目总工期的情况下活动可以拖延的总时间,为正差值<br>  总浮动时间=LS-ES 或 LF-EF LS:最晚开始，ES：最早开始<br>  总时差=同一个活动的最晚开始-最早开始 或者 最晚结束-最早结束 </li>
<li>3.项目浮动时间:在已经排好的总工期的基础上，领导或者甲方又主动让出时间称为项目总浮动时间。例如：4月28日系统上线，但是4月29日至5月1日属于放假期间，系统上线没用，并且会出现报错没人解决问题，风险太大等问题，甲方则会要求节后再上线</li>
</ul>
<p>4.成本估算</p>
<ul>
<li>三点分布:(最乐观+4*最可能+最悲观)/6</li>
<li>三角分布:(最乐观+最可能+最悲观)/3</li>
<li>类比估算(情况不明)：也是专家判断一种,通常成本低，耗时少，准确性也低，项目信息不足或者项目启动早期时使用</li>
<li>参数估算：需要有数据</li>
<li>自下而上：需要明确需求</li>
</ul>
<p>5.前导图法在的4种类型的依赖关系</p>
<ul>
<li>结束——开始的关系(f-s型)</li>
<li>结束一结束的关系(f-f型)</li>
<li>开始-开始的关系(s-s型)</li>
<li>开始一结束的关系(s-f型)</li>
</ul>
<h3 id="6-1规划进度管理"><a href="#6-1规划进度管理" class="headerlink" title="6.1规划进度管理"></a>6.1规划进度管理</h3><p><img src="/pmp/6.1%E8%A7%84%E5%88%92%E7%9B%91%E7%9D%A3%E7%AE%A1%E7%90%86.png" alt="规划监督管理" title="规划监督管理"></p>
<h3 id="6-2定义活动"><a href="#6-2定义活动" class="headerlink" title="6.2定义活动"></a>6.2定义活动</h3><p><img src="/pmp/6.2%E5%AE%9A%E4%B9%89%E6%B4%BB%E5%8A%A8.png" alt="定义活动" title="定义活动"></p>
<h3 id="6-3排列活动顺序"><a href="#6-3排列活动顺序" class="headerlink" title="6.3排列活动顺序"></a>6.3排列活动顺序</h3><p><img src="/pmp/6.3%E6%8E%92%E5%88%97%E6%B4%BB%E5%8A%A8%E9%A1%BA%E5%BA%8F.png" alt="排列活动顺序" title="排列活动顺序"></p>
<h3 id="6-4估算活动持续时间"><a href="#6-4估算活动持续时间" class="headerlink" title="6.4估算活动持续时间"></a>6.4估算活动持续时间</h3><p><img src="/pmp/6.4%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4.png" alt="估算活动持续时间" title="估算活动持续时间"></p>
<h3 id="6-5制定进度计划"><a href="#6-5制定进度计划" class="headerlink" title="6.5制定进度计划"></a>6.5制定进度计划</h3><p><img src="/pmp/6.5%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.png" alt="制定进度计划" title="制定进度计划"></p>
<h3 id="6-6控制进度"><a href="#6-6控制进度" class="headerlink" title="6.6控制进度"></a>6.6控制进度</h3><p><img src="/pmp/6.6%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6.png" alt="控制进度" title="控制进度"></p>
<h2 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h2><h3 id="7-1规划成本管理"><a href="#7-1规划成本管理" class="headerlink" title="7.1规划成本管理"></a>7.1规划成本管理</h3><p><img src="/pmp/7.1%E8%A7%84%E5%88%92%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86.png" alt="规划成本管理" title="规划成本管理"></p>
<h3 id="7-2估算成本"><a href="#7-2估算成本" class="headerlink" title="7.2估算成本"></a>7.2估算成本</h3><p>1.术语：</p>
<ul>
<li>直接成本:直接归属于项目的成本</li>
<li>固定成本：不会随着产品数量增加</li>
<li>可变成本：随产量或工作量而变</li>
<li>可控成本：项目经理可以直接控制成本</li>
<li>不可控成本：项目经理不能直接控制</li>
<li>机会成本：获取一个机会会失去另外一个机会成本</li>
<li>沉没成本：已经花掉费用，如果继续做项目就不考虑该成本</li>
</ul>
<p>储备分析：应急储备(已知不确定风险)和管理储备(未知不确定风险)<br><img src="/pmp/7.2%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.png" alt="估算成本" title="估算成本"><br><img src="/pmp/7.2.1%E6%88%90%E6%9C%AC%E4%BC%B0%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="成本估算" title="成本估算"></p>
<ul>
<li><p>典型偏差。认为项目日后要完成的工作和以前的工作效率相同,未完成的工作的实际成本和未来完成工作预算的比例与已完成工作的实际成本和预算的比率是相同的。在考试中,常出现“仍按”、“指数器”这样的关键词。公式如：  EAC=AC+【(BAC-EV)/CPI】=BAC/CPI；其中BAC为完成工作预算,即整个项目的预算总和。  </p>
</li>
<li><p>非典型偏差。假定未完成工作的效率和已完成工作的效率没有什么关系,对未完成的工作依然使用原来的预算值,这时,对于最终估算成本就是已完成工作的实际成本与未完成工作的预算成本之和。在考试中,常出现“已解决了之前的问题”、“只是偶然现象”这样的关键词。公式：  EAC=AC+BAC-EV。 </p>
</li>
<li><p>EAC:完工总费用预算</p>
</li>
</ul>
<p>1.使用CPI计算 EAC = AC+(BAC-EV)/CPI = BAC/CPI(PMP认证最常用)<br>2.使用SPI&lt;1计算   EAC = BAC/(CPI*SPI)<br>3.使用新估算费用来计算EAC = AC+ETC<br>4.使用剩余预算费用计算EAC = AC+(BAC-EV)</p>
<p>VAC: 完工总费用偏差VAC = BAC-EAC<br>EDAC:估计完工工期    EDAC = BDAC/SPI</p>
<ul>
<li>ETC:完工尚需费用预算<br>基于非典型的偏差计算(以后不会再发生类似偏差时): ETC = BAC-EV<br>基于典型的偏差计算(当头偏差可代表未来的趋势时):ETC = (BAC-EV)/CPI</li>
</ul>
<h3 id="7-3制定预算"><a href="#7-3制定预算" class="headerlink" title="7.3制定预算"></a>7.3制定预算</h3><p><img src="/pmp/7.3%E5%88%B6%E5%AE%9A%E9%A2%84%E7%AE%97.png" alt="制定预算" title="制定预算"></p>
<p>项目资金需求=成本基准+管理储备(管理层控制)<br>成本基准=控制账户=工作包成本估算+应急储备(项目经理控制)<br>工作包成本估算=活动成本估算+活动应急储备(估算时控制)<br><img src="/pmp/%E6%88%90%E6%9C%AC%E9%A2%84%E7%AE%97.png" alt="成本预算" title="成本预算"></p>
<h3 id="7-4控制成本"><a href="#7-4控制成本" class="headerlink" title="7.4控制成本"></a>7.4控制成本</h3><p><img src="/pmp/7.4%E6%8E%A7%E5%88%B6%E6%88%90%E6%9C%AC.png" alt="控制成本" title="控制成本"></p>
<h2 id="项目质量管理"><a href="#项目质量管理" class="headerlink" title="项目质量管理"></a>项目质量管理</h2><p>1.控制质量的方法</p>
<ul>
<li>控制图:用3倍西格玛*均值(误差)设置上限跟下限，还有上下控制界限。连续7个点在均值外或直接某点在界限外就代表失控</li>
<li>帕累托图/主次图，是一种简单的图表工具，用于统计和显示一定时间内各种类型缺陷或问题的数目</li>
<li>鱼骨图/因果图/石川图：分析因果关系</li>
<li>趋势图:显示一定时间间隔(例如一天、一周或一个月)内所得到的测量结果</li>
<li>直方图:</li>
<li>散点图:表示一个变量与另一个变量如何相互关联的的标准方法</li>
<li>流程图:输入-输出图。该图直观地描述一个工作过程的具体步骤</li>
</ul>
<p>2.统计抽样:</p>
<ul>
<li>属性抽样:每个样本的结果都是非此即彼(比如，要么是检测合格，要么是不合格)：检测结果值能用离散值表达</li>
<li>变量抽样:实际检测结果在某个连续刻度上所处位置，而不是产品合格或不合格:检测结果值能用函数(线性)表达</li>
</ul>
<p>3.质量成本=一致性成本+非一致性成本</p>
<ul>
<li>一致性成本=预防成本(生产过程预防产生成本)+评估成本(评估质量产生成本)</li>
<li>非一致性成本=内部失败成本(项目发现失败成本)+外部失败成本(客户发现失败成本)</li>
</ul>
<p>4.质量控制水平有效性排列顺序</p>
<ul>
<li>(最优解)5.在组织内创建关注并致力于实现过程和产品质量文化</li>
<li>4.将质量融入规划和设计中</li>
<li>3.同归质量保证检查并纠正过程本身</li>
<li>2.通过质量控制先检测和纠正</li>
<li>(最次解)1.让客户发现缺陷</li>
</ul>
<p>5.结构化的解决问题流程:</p>
<ul>
<li>定义问题；</li>
<li>识别根本原因；</li>
<li>生成可能的解决方案；</li>
<li>选择最佳解决方案；</li>
<li>执行解决方案；</li>
<li>验证解决方案的有效性</li>
</ul>
<h3 id="8-1规划质量管理"><a href="#8-1规划质量管理" class="headerlink" title="8.1规划质量管理"></a>8.1规划质量管理</h3><p><img src="/pmp/8.1%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.png" alt="规划质量管理" title="规划质量管理"><br><img src="/pmp/8.1.1%E8%B4%A8%E9%87%8F%E6%88%90%E6%9C%AC.png" alt="质量成本" title="质量成本"></p>
<h3 id="8-2管理质量"><a href="#8-2管理质量" class="headerlink" title="8.2管理质量"></a>8.2管理质量</h3><p><img src="/pmp/8.2%E7%AE%A1%E7%90%86%E8%B4%A8%E9%87%8F.png" alt="管理质量" title="管理质量"></p>
<h3 id="8-3控制质量"><a href="#8-3控制质量" class="headerlink" title="8.3控制质量"></a>8.3控制质量</h3><p><img src="/pmp/8.3%E6%8E%A7%E5%88%B6%E8%B4%A8%E9%87%8F.png" alt="控制质量" title="控制质量"></p>
<h2 id="项目资源管理"><a href="#项目资源管理" class="headerlink" title="项目资源管理"></a>项目资源管理</h2><p>1.虚拟团队要加强沟通规划<br>2.资源管理模型:</p>
<ul>
<li>Y理论:积极</li>
<li>X理论:懒惰</li>
</ul>
<p>3.权力五种类型:</p>
<ul>
<li>强制权力:强迫他们做不愿意的事，非常无奈</li>
<li>合法/法定/正式权力:职权的权力，一般无奈</li>
<li>专家权力：次之</li>
<li>奖励权力：最好</li>
<li>潜示权力：狐假虎威，很无奈<br>4.预分派人员：A.投标制定人员 B.特定技能人员 C.项目章程制定人员<br>5.责任分配矩阵:人与活动的关系<br>6.团队资源管理:<br>形成:开始加入团队<br>震荡:冲突<br>规范:有规范团队<br>成熟:<br>解散:<br>7.冲突解决方法:<br>撤退/回避:不解决冲突<br>缓解/包容:各让一步，冲突没解决<br>妥协/调解:相互迁就<br>强迫/命令:牺牲一方，成就一方，解决冲突<br>合作/解决问题:双方达成协议，解决冲突<br>8.马斯洛需求层次:生理需求,生存需求，社交需求，自我实现<br>9.领导方式：指挥，教练，支持，授权<h3 id="9-1规划资源管理"><a href="#9-1规划资源管理" class="headerlink" title="9.1规划资源管理"></a>9.1规划资源管理</h3><img src="/pmp/9.1%E8%A7%84%E5%88%92%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.png" alt="规划资源管理" title="规划资源管理"><h3 id="9-2估算活动资源"><a href="#9-2估算活动资源" class="headerlink" title="9.2估算活动资源"></a>9.2估算活动资源</h3><img src="/pmp/9.2%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E8%B5%84%E6%BA%90.png" alt="估算活动资源" title="估算活动资源"><h3 id="9-3获取资源"><a href="#9-3获取资源" class="headerlink" title="9.3获取资源"></a>9.3获取资源</h3><img src="/pmp/9.3%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90.png" alt="获取资源" title="获取资源"><h3 id="9-4建设团队"><a href="#9-4建设团队" class="headerlink" title="9.4建设团队"></a>9.4建设团队</h3>促进提高团队能力<br><img src="/pmp/9.4%E5%BB%BA%E8%AE%BE%E5%9B%A2%E9%98%9F.png" alt="建设团队" title="建设团队"><h3 id="9-5管理团队"><a href="#9-5管理团队" class="headerlink" title="9.5管理团队"></a>9.5管理团队</h3>解决团队问题:冲突矛盾<br><img src="/pmp/9.5%E7%AE%A1%E7%90%86%E5%9B%A2%E9%98%9F.png" alt="管理团队" title="管理团队"><h3 id="9-6控制资源"><a href="#9-6控制资源" class="headerlink" title="9.6控制资源"></a>9.6控制资源</h3><img src="/pmp/9.6%E6%8E%A7%E5%88%B6%E8%B5%84%E6%BA%90.png" alt="控制资源" title="控制资源"><br><img src="/pmp/%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB%E6%8A%80%E8%83%BD.png" alt="人际关系技能" title="人际关系技能"></li>
</ul>
<h2 id="项目沟通管理"><a href="#项目沟通管理" class="headerlink" title="项目沟通管理"></a>项目沟通管理</h2><p>考点:<br>1.沟通渠道计算:N*(N-1)/2,N为成员数<br>2.沟通模型:</p>
<p>3.沟通技术:正式书面沟通,正是口头沟通,非正式书面沟通,非正是口头沟通<br>4.沟通方法:</p>
<ul>
<li>A.交互式沟通:会议</li>
<li>B.推式沟通方式: email</li>
<li>C.拉式沟通方式:公告</li>
</ul>
<p>5.沟通管理通常可分成五个层面：<br>第一个层面是自我沟通；主要是人的内在行为，如观察、倾听、阅读等；<br>第二个层面是人际沟通；在这个层面，两个或两个以上的人交换想法，他们可能为了分享信息、提供反馈，或者是为了为维持一定的社会关系；<br>第三个层面是小组沟通或团队沟通；<br>第四个层面是组织沟通；<br>第五个层面是跨文化沟通。</p>
<h3 id="10-1规划沟通管理"><a href="#10-1规划沟通管理" class="headerlink" title="10.1规划沟通管理"></a>10.1规划沟通管理</h3><p><img src="/pmp/10.1%E8%A7%84%E5%88%92%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86.png" alt="规划沟通管理" title="规划沟通管理"></p>
<h3 id="10-2管理沟通"><a href="#10-2管理沟通" class="headerlink" title="10.2管理沟通"></a>10.2管理沟通</h3><p><img src="/pmp/10.2%E7%AE%A1%E7%90%86%E6%B2%9F%E9%80%9A.png" alt="管理沟通" title="管理沟通"></p>
<h3 id="10-3监督沟通"><a href="#10-3监督沟通" class="headerlink" title="10.3监督沟通"></a>10.3监督沟通</h3><p><img src="/pmp/10.3%E7%9B%91%E7%9D%A3%E6%B2%9F%E9%80%9A.png" alt="监督沟通" title="监督沟通"></p>
<h2 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h2><p>考点:<br>1.识别风险分析工具(4种)</p>
<ul>
<li>根本原因分析</li>
<li>假设条件和制约因素分析</li>
<li>SWOT分析</li>
<li>文件分析</li>
</ul>
<p>2.定量风险分析工具(4种):</p>
<ul>
<li>龙卷风图(敏感性分析)</li>
<li>决策树分析(预期货币价值分析,利用概率计算成本)</li>
<li>蒙特卡洛(模拟):统计模拟方法</li>
<li>影响图</li>
</ul>
<p>3.定性分析风险概率矩阵:</p>
<p>4.规划风险威胁策略:</p>
<ul>
<li>上报,规避(提前预防),减轻(减低风险发生概率)–&gt;减轻后注意评估残余风险,转移(付出代价完全转移给第三方),接受</li>
</ul>
<p>5.机会风险策略:</p>
<ul>
<li>上报,开拓(采取措施保证机会出现),分享(与其他方共同促进,共享机会发生利益),提高(采取措施提高机会出现可能性),接受</li>
</ul>
<p>6.风险登记手册记录</p>
<ul>
<li>弹回计划:应急计划得配套计划,在应急计划不生效就弹回</li>
<li>次生风险:一个风险带来另外风险</li>
<li>残余风险:遗留下来得风险</li>
</ul>
<p><img src="/pmp/11.%E9%A3%8E%E9%99%A9%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="风险整体流程图" title="风险整体流程图"><br><img src="/pmp/11.0%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D.png" alt="风险管理介绍" title="风险管理介绍"></p>
<h3 id="11-1规划风险管理"><a href="#11-1规划风险管理" class="headerlink" title="11.1规划风险管理"></a>11.1规划风险管理</h3><p><img src="/pmp/11.1%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86.png" alt="规划风险管理" title="规划风险管理"></p>
<h3 id="11-2识别风险-识别已知风险"><a href="#11-2识别风险-识别已知风险" class="headerlink" title="11.2识别风险(识别已知风险)"></a>11.2识别风险(识别已知风险)</h3><p><img src="/pmp/11.2%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9.png" alt="识别风险" title="识别风险"></p>
<h3 id="11-3实施定性风险分析-对已知风险评估"><a href="#11-3实施定性风险分析-对已知风险评估" class="headerlink" title="11.3实施定性风险分析(对已知风险评估)"></a>11.3实施定性风险分析(对已知风险评估)</h3><p><img src="/pmp/11.3%E5%AE%9E%E6%96%BD%E5%AE%9A%E6%80%A7%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.png" alt="实施定性风险分析" title="实施定性风险分析"></p>
<h3 id="11-4实施定量风险分析-针对已知最大分析进一步分析"><a href="#11-4实施定量风险分析-针对已知最大分析进一步分析" class="headerlink" title="11.4实施定量风险分析(针对已知最大分析进一步分析)"></a>11.4实施定量风险分析(针对已知最大分析进一步分析)</h3><p><img src="/pmp/11.4%E5%AE%9E%E6%96%BD%E5%AE%9A%E9%87%8F%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.png" alt="实施定量风险分析" title="实施定量风险分析"></p>
<h3 id="11-5规划风险应对"><a href="#11-5规划风险应对" class="headerlink" title="11.5规划风险应对"></a>11.5规划风险应对</h3><p><img src="/pmp/11.5%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E5%BA%94%E5%AF%B9.png" alt="规划风险应对" title="规划风险应对"></p>
<h3 id="11-6实施风险应对"><a href="#11-6实施风险应对" class="headerlink" title="11.6实施风险应对"></a>11.6实施风险应对</h3><p><img src="/pmp/11.6%E5%AE%9E%E6%96%BD%E9%A3%8E%E9%99%A9%E5%BA%94%E5%AF%B9.png" alt="实施风险应对" title="实施风险应对"></p>
<h3 id="11-7监督风险"><a href="#11-7监督风险" class="headerlink" title="11.7监督风险"></a>11.7监督风险</h3><p><img src="/pmp/11.7%E7%9B%91%E7%9D%A3%E9%A3%8E%E9%99%A9.png" alt="监督风险" title="监督风险"></p>
<h2 id="项目采购管理"><a href="#项目采购管理" class="headerlink" title="项目采购管理"></a>项目采购管理</h2><p>考点1：合同类型(2种)<br>A.总价类合同</p>
<ul>
<li>固定总价类合同(FFP)：货物的采购价格在一开始就已确定工作范围,并且范围不变合同价格不允许改变(除非工作范围发生变更)</li>
<li>总价加激励费合同(FPIF)：同会设置价格上限,高于此价格的上限的全部成本由卖方承担</li>
<li>总价加经济价格调整(FP-EPA)：卖方履约期限跨越几年时间,或将以不同货币支付价款。它是总价合同的一种类型,但合同中包含了特殊条款,允许根据条件变化,如通货膨胀、某些特殊商品的成本增加(或降低),以事先确定的方式对合同价格进行最终调整。</li>
</ul>
<p>B.成本类合同</p>
<ul>
<li>成本加固定费用(CPFF)为卖方报销履行合同工作所发生的一切可列支成本,并向卖方支付一笔以合同成本固定比例费用。</li>
<li>成本加激励费用(CPIF)：为卖方报销履行合同工作所发生的一切可列支成本,并在卖方达到合同规定的绩效目标时,向卖方支付预先确定的激励费用</li>
<li>成本加奖励费用(CPFA)：为卖方报销一切合法成本。当只有在卖方满足合同规定的,某些笼统主观的绩效标准的情况下,才向卖方支付大部分费用。奖励费用完全由买方根据自己对卖方绩效的主观判断来决定,并且通常不允许申诉。<br>C.工料合同(T&amp;M):<br>  在无法快速编制出准确的工作说明书的情况下扩充人员、聘用专家或寻求外部支持。</li>
</ul>
<p>考点2：索赔和争议三步骤:</p>
<ul>
<li>1.谈判</li>
<li>2.ADR(用替代争议解决方法)</li>
<li>3.起诉:根据合同起诉</li>
</ul>
<p>考点3：计算合同价格公式:费用是利润,限价是总价<br>1.总价加激励费用FPIF合同 估算的合同总价<br>    估算的合同总价PTA(Point of Total Assumption)也称为总体假设点,是指买方支付最高限价时,卖方花费的成本：<br>    合同总价(PTA) = 目标成本 + (最高限价 – 目标价格)/ 买方分担比例<br>    目标价格 = 目标成本 + 目标利润</p>
<p>2.总价加激励费用FPIF合同<br>    合同价格 = 实际成本 + 实际利润<br>    实际利润 = 目标利润 + (目标成本 – 实际成本)* 卖方分担比例<br>    注意最高价上限 , 利润看(最高限价 – 实际成本)上限</p>
<p>3.成本加固定费用合同CPPC<br>    合同规定了估计成本,并同意以目标成本的10%作为利润<br>    总价 = 实际成本 + 目标成本*以成本的利润百分比</p>
<p>4.成本加激励费用CPIF合同<br>    合同价格 = 实际成本 + 实际利润<br>    实际利润 = 目标利润 + (目标成本 – 实际成本)*卖方分担比例<br>    然后注意下 费用上限,下限基本无忧</p>
<h3 id="12-1规划采购管理"><a href="#12-1规划采购管理" class="headerlink" title="12.1规划采购管理"></a>12.1规划采购管理</h3><p><img src="/pmp/12.1%E8%A7%84%E5%88%92%E9%87%87%E8%B4%AD%E7%AE%A1%E7%90%86.png" alt="规划采购管理" title="规划采购管理"></p>
<h3 id="12-2实施采购"><a href="#12-2实施采购" class="headerlink" title="12.2实施采购"></a>12.2实施采购</h3><p><img src="/pmp/12.2%E5%AE%9E%E6%96%BD%E9%87%87%E8%B4%AD.png" alt="实施采购" title="实施采购"></p>
<h3 id="12-3控制采购"><a href="#12-3控制采购" class="headerlink" title="12.3控制采购"></a>12.3控制采购</h3><p><img src="/pmp/12.3%E6%8E%A7%E5%88%B6%E9%87%87%E8%B4%AD.png" alt="控制采购" title="控制采购"></p>
<h2 id="项目相关方管理"><a href="#项目相关方管理" class="headerlink" title="项目相关方管理"></a>项目相关方管理</h2><p>1.识别相关方数据表现：</p>
<ul>
<li>权力利益方格:权高力高重管理,权低利低仅监督,权高利低满足他,权低利高常告知</li>
</ul>
<p>2.规划相关方数据表现</p>
<ul>
<li>思维导图:彰显相互关系</li>
<li>相关方参与度评估矩阵：不知道,抵制,中立,支持型,领导(有参与行为)<br>  支持型:了解项目及其潜在影响,并且会支持项目工作及其成果。(此类相关方知道化工厂项目有什么影响,但是同意建化工厂项目)<br>  领导型:了解项目及其潜在影响,而且积极参与以确保项目取得成功。(此类相关方知道化工厂项目有什么影响,但是为了项目成功,提供资源、钱等支持)<br>  (了解项目及潜在影响,积极参与以确保项目取得成功,比支持型更积极促进项目成功)</li>
</ul>
<h3 id="13-1识别相关方"><a href="#13-1识别相关方" class="headerlink" title="13.1识别相关方"></a>13.1识别相关方</h3><p><img src="/pmp/13.1%E8%AF%86%E5%88%AB%E7%9B%B8%E5%85%B3%E6%96%B9.png" alt="识别相关方" title="识别相关方"></p>
<h3 id="13-2规划相关方参与"><a href="#13-2规划相关方参与" class="headerlink" title="13.2规划相关方参与"></a>13.2规划相关方参与</h3><p><img src="/pmp/13.2%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E6%96%B9%E5%8F%82%E4%B8%8E.png" alt="规划相关方参与" title="规划相关方参与"></p>
<h3 id="13-3管理相关方参与"><a href="#13-3管理相关方参与" class="headerlink" title="13.3管理相关方参与"></a>13.3管理相关方参与</h3><p><img src="/pmp/13.3%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E6%96%B9%E5%8F%82%E4%B8%8E.png" alt="管理相关方参与" title="管理相关方参与"></p>
<h3 id="13-4监督相关方参与"><a href="#13-4监督相关方参与" class="headerlink" title="13.4监督相关方参与"></a>13.4监督相关方参与</h3><p><img src="/pmp/13.4%E7%9B%91%E7%9D%A3%E7%9B%B8%E5%85%B3%E6%96%B9%E5%8F%82%E4%B8%8E.png" alt="监督相关方参与" title="监督相关方参与"></p>
]]></content>
      <categories>
        <category>Project Management</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷Scrum框架总结</title>
    <url>/2021/03/13/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%95%8F%E6%8D%B7Scrum%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="构建Scrum团队"><a href="#构建Scrum团队" class="headerlink" title="构建Scrum团队"></a><a href="https://www.cnblogs.com/juking/p/5472654.html" target="_blank" rel="noopener">构建Scrum团队</a></h2><p> • Scrum 团队最佳人数控制在“7～9”人。<br> • 全职能性团队：开发组(后台开发,前端开发、测试人员——5-8人)、Scrum Master(项目经理)、产品负责人<br> • 兼职团队成员：美工、DBA、运维</p>
<h2 id="Scrum中的角色"><a href="#Scrum中的角色" class="headerlink" title="Scrum中的角色"></a>Scrum中的角色</h2><h3 id="Scrum-Master——项目负责人、项目经理"><a href="#Scrum-Master——项目负责人、项目经理" class="headerlink" title="Scrum Master——项目负责人、项目经理"></a>Scrum Master——项目负责人、项目经理</h3><p>保护团队不受外界干扰，是团队的领导和推进者，负责提升 Scrum 团队的工作效率，控制 Scrum 中的“检视和适应”周期过程。与 Product Owner 一起将投资产出最大化，他确保所有的利益相关者都可以理解敏捷和尊重敏捷的理念</p>
<h3 id="Team——开发人员、测试人员、美工设计、DBA等全职能性团队"><a href="#Team——开发人员、测试人员、美工设计、DBA等全职能性团队" class="headerlink" title="Team——开发人员、测试人员、美工设计、DBA等全职能性团队"></a>Team——开发人员、测试人员、美工设计、DBA等全职能性团队</h3><p>团队负责交付产品并对其质量负责，团队与所有提出产品需求的人一起工作，包括客户和最终用户，并共同创建 Product Backlog 。团队按照大家的共识来创建功能设计、测试 Backlog 条目交付产品</p>
<h3 id="Product-Owner——产品负责人、产品经理、运营人员"><a href="#Product-Owner——产品负责人、产品经理、运营人员" class="headerlink" title="Product Owner——产品负责人、产品经理、运营人员"></a>Product Owner——产品负责人、产品经理、运营人员</h3><p>从业务角度驱动项目，传播产品的明确愿景，并定义其主要特性。Product Owner 的主要职责是确保团队只开发对于组织最重要的 Backlog 条目，在 Sprint 中帮助团队完成自己的工作，不干扰团队成员，并迅速提供团队需要的所有信息。</p>
<h3 id="User——最终用户、运营人员、系统使用人员"><a href="#User——最终用户、运营人员、系统使用人员" class="headerlink" title="User——最终用户、运营人员、系统使用人员"></a>User——最终用户、运营人员、系统使用人员</h3><p>很多人都可能成为最终用户，比如市场部人员、真正的最终用户、最好的领域专家，也可能是因其专业知识而被雇佣的资讯顾问。最终用户会根据自己的业务知识定义产品，并告知团队自己的期望，提出请求。</p>
<h3 id="Manager——管理层、投资人"><a href="#Manager——管理层、投资人" class="headerlink" title="Manager——管理层、投资人"></a>Manager——管理层、投资人</h3><p>管理层要为 Scrum 团队搭建良好的环境，以确保团队能够出色工作，必要的时候，他们也会与 Scrum Master 一起重新组织结构和指导原则。</p>
<h3 id="Customer——客户、系统使用人员、运营人员"><a href="#Customer——客户、系统使用人员、运营人员" class="headerlink" title="Customer——客户、系统使用人员、运营人员"></a>Customer——客户、系统使用人员、运营人员</h3><p>客户是为 Scrum 团队提出产品需求的人，她会与组织签订合同，以开发产品。一般来说，这些人是组织中的高级管理人员，负责从外部软件开发公司购买软件开发能力。在为内部产品的公司中，负责批准项目预算的人就是客户</p>
<h2 id="Scrum中的产出物"><a href="#Scrum中的产出物" class="headerlink" title="Scrum中的产出物"></a>Scrum中的产出物</h2><h3 id="Product-Backlog——Backlog-待开发项，积压的任务。"><a href="#Product-Backlog——Backlog-待开发项，积压的任务。" class="headerlink" title="Product Backlog——Backlog 待开发项，积压的任务。"></a>Product Backlog——Backlog 待开发项，积压的任务。</h3><p>产品 Backlog 包括了所有需要交付的内容，其内容根据业务需求的价值顺序排列，每个 Backlog 的优先级是可以调整的，需求是可以增减的，因此产品 Backlog 将根据不断增长来持续驱动维护。</p>
<h3 id="Sprint-Backlog——Sprint-本意为“冲刺”，指迭代周期，长度通常是一至六周"><a href="#Sprint-Backlog——Sprint-本意为“冲刺”，指迭代周期，长度通常是一至六周" class="headerlink" title="Sprint Backlog——Sprint 本意为“冲刺”，指迭代周期，长度通常是一至六周"></a>Sprint Backlog——Sprint 本意为“冲刺”，指迭代周期，长度通常是一至六周</h3><p>在 Sprint 开始前，定义本次 Sprint 要讨论的“Sprint Backlog”，从中产生本次 Sprint 要完成的 “已定 Product Backlog”</p>
<h3 id="已定-Product-Backlog"><a href="#已定-Product-Backlog" class="headerlink" title="已定 Product Backlog"></a>已定 Product Backlog</h3><p>Sprint 计划会议的产物，它定义了团队所接受的工作量，在整个 Sprint 过程中它将保持不变</p>
<h3 id="User-Story、Task——用户故事、任务"><a href="#User-Story、Task——用户故事、任务" class="headerlink" title="User Story、Task——用户故事、任务"></a>User Story、Task——用户故事、任务</h3><p>用 User Story 来描述 Sprint Backlog 里的项目，User Story 是从用户的角度对系统的某个功能模块所作的简短描述。一个 User Story 描述了项目中的一个小功能，以及这个功能完成之后将会产生什么效果，或者说能为客户创造什么价值。一个 User Story 的大小和复杂度应该以能在一个 Sprint 中完成为宜。如果 User Story 太大，可能会导致对它的开发横跨几个 Sprint，此时就应该将这个 User Story 分解。</p>
<p>为了能够及时，高效地完成每个 Story，Scrum 团队会把每个 Story 分解成若干个 Task。每个Task 的时间最好不要超过8小时，保证在1个工作日内完成，如果 Task 的时间超过了8个小时，就说明Task的划分有问题，需要特别注意。</p>
<h3 id="障碍-Backlog——问题列表，积压的待处理事务。"><a href="#障碍-Backlog——问题列表，积压的待处理事务。" class="headerlink" title="障碍 Backlog——问题列表，积压的待处理事务。"></a>障碍 Backlog——问题列表，积压的待处理事务。</h3><p>列举了所有团队内部和团队相关的和阻碍项目的进度的问题，Scrum Master 需要确保所有的障碍 Backlog 中的问题都已分配并可以得到解决</p>
<h2 id="会议规则"><a href="#会议规则" class="headerlink" title="会议规则"></a>会议规则</h2><h3 id="会议作用"><a href="#会议作用" class="headerlink" title="会议作用"></a>会议作用</h3><p> • 让团队坐在一起,一起讨论或解决问题,彼此意识到团队作用！<br> • 大家都懒的动，尽量让“产品负责人”和“全功能团队”都坐在一起！<br> • 互相听到：所有人都可以彼此交谈，不必大声喊，不必离开座位。<br> • 互相看到：所有人都可以看到彼此，都能看到任务板——不用非得近到可以看清楚内容，但至少可以看到个大概。<br> • 隔离：如果你们整个团队突然站起来，自发形成一个激烈的设计讨论，团队外的任何人都不会被打扰到，反之亦然。</p>
<h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p> • 每次会议都要准时开始、准时结束。<br> • 每次会议都采取开放形式，所有人都可以参加<br> • 根据需要控制会议时长</p>
<h3 id="会前准备"><a href="#会前准备" class="headerlink" title="会前准备"></a>会前准备</h3><p> • <font color="red">提前邀请所有必须参会的人，让他们有时间准备。</font><br> • <font color="red">发送带有会议目标和意图的会议纲要。</font><br> • <font color="red">预订会议所需的全部资源：房间、投影仪、挂图、主持设备，以及此会议需要的其他东西。</font><br> • <font color="red">会前24小时发送提醒。</font></p>
<h3 id="会议推进"><a href="#会议推进" class="headerlink" title="会议推进"></a>会议推进</h3><p> • 展开讨论时，会议的推进人必须在场。他不能参与到具体讨论中，但是他需要注意讨论进程，如果讨论参与者失去重点，他还要将讨论带回正规。<br> • 推进人展示会议的目标和意图。<br> • 有必要时，推进人可以商定由某个撰写会议记录。<br> • 推进人可以记录团队的意见，或是教授团队如何自己记录文档；而且推进人可能会在挂图上进行记录，将对话可视化。<br> • 推进人会对会议进行收尾，并进行非常简短的回顾</p>
<h3 id="会议输出"><a href="#会议输出" class="headerlink" title="会议输出"></a>会议输出</h3><p> • 使用手写或挂图说明来记录文档，给白板和挂图上的内容拍照。<br> • 必须传达会议记录和大家对会议结果的明确共同认知。</p>
<h3 id="我们为什么要开会"><a href="#我们为什么要开会" class="headerlink" title="我们为什么要开会"></a>我们为什么要开会</h3><h4 id="会议价值"><a href="#会议价值" class="headerlink" title="会议价值"></a>会议价值</h4><p>会议本身是一个讨论和决策的过程，其本身并不产生实际的价值。而真正产生价值的事情有2个，一个是「有形」的，一个是「无形」的。</p>
<ul>
<li>有形价值：会议产生的决议或行动项被落实，对产品或业务产生了价值；</li>
<li>无形价值：让团队有条理、高效地开会，节省宝贵时间；<br>会议的目的是为了产生价值，价值是公司存在的意义。</li>
</ul>
<h3 id="如何高效开会"><a href="#如何高效开会" class="headerlink" title="如何高效开会"></a>如何高效开会</h3><h4 id="会前"><a href="#会前" class="headerlink" title="会前"></a>会前</h4><p>会议有几个要素，「主题」「时间」「地点」「参与者」「资料」。<br>我们应该提前通知与会人上面的这些要素，会前资料非常重要，它是「高效」会议的重点，大家提前阅读资料。在开会时，都已经知晓了会议内容，和要讨论的事情。<br>在会议开始前，主持人应该提前达到现场准备好会议环境，准好投影等设备，并提前告知与会者会议马上开始。</p>
<h4 id="会中"><a href="#会中" class="headerlink" title="会中"></a>会中</h4><p>会议开始：首先应该阐明，会议的目的，也就是为什么开，需要达成什么共识或者行动项。<br>会议持续时间：个人认为应该控制好节奏，人的注意力是有限的，会议的讨论周期不应该特别长，如果需要很长，应该合理安排中间休息</p>
<h4 id="会后"><a href="#会后" class="headerlink" title="会后"></a>会后</h4><p>这个阶段是会议价值的体现特别重要的一步。会议形成的决议，争议项，应该记录好，维护到企业的TODO LIST里面去，形成任务，并且主持人或相关OWNER，应该跟踪任务的进展。如果存在争议项，需要确认争议项在什么条件下，双方在进行讨论解决</p>
<h2 id="估算会议——根据项目情况合并到Sprint第二部分会议"><a href="#估算会议——根据项目情况合并到Sprint第二部分会议" class="headerlink" title="估算会议——根据项目情况合并到Sprint第二部分会议"></a><font color="red">估算会议——根据项目情况合并到Sprint第二部分会议</font></h2><h3 id="会议目的"><a href="#会议目的" class="headerlink" title="会议目的"></a>会议目的</h3><p> • 要做好战略规划，你需要知道 Backlog 中各项的大小，这是版本规划的必要输入；如果想知道团队在一个 Sprint 中能够完成多少工作，这个数据也是必须的。<br> • 团队成员可以从会议中知道项目接下来的阶段会发生哪些事情。</p>
<h3 id="基本要求-1"><a href="#基本要求-1" class="headerlink" title="基本要求"></a>基本要求</h3><p> • 只有团队才能作估算，Product Owner(产品负责人)需要在场，以帮助判定某些用户故事能否拆分为更小的故事。</p>
<h3 id="构成部分："><a href="#构成部分：" class="headerlink" title="构成部分："></a>构成部分：</h3><p> • Product Owner 根据业务价值排定 Product Backlog 各项顺序。<br> • 需要参加的人员：Team、Product Owner、User、Scrum Master</p>
<p>注意事项：<br> • 不要估算工作量大小——只有团队能这么做。<br> • Product Owner 不参与估算。</p>
<h3 id="会议过程"><a href="#会议过程" class="headerlink" title="会议过程"></a>会议过程</h3><p> • Prodcut Owner 展示她希望得到估算的 Product Backlog 条目。<br> • 团队使用规划扑克来估算 Backlog 条目。<br> • 如果某个 Backlog 条目过大，需要放到下一个或是后续的 Sprint 中，团队就会将该大 Backlog 条目划分为较小的几个 Backlog 条目，并对新的 Backlog 条目使用规划扑克进行估算。<br> • 重新估算 Backlog 中当前没有完成、但是可能会在接下来三个 Sprint 中要完成的条目。</p>
<p>持续时间：该会议时间限制为不超过90分钟。如果 Sprint 持续时间长于一周，那么每个 Sprint 举行两次估算会议比较合适。</p>
<h3 id="会议输出-1"><a href="#会议输出-1" class="headerlink" title="会议输出"></a>会议输出</h3><p> • 经过估算的 Product Backlog。<br> • 更小的 Backlog 条目。</p>
<h2 id="每日立会-Daily-Standup-Meeting"><a href="#每日立会-Daily-Standup-Meeting" class="headerlink" title="每日立会(Daily Standup Meeting)"></a>每日立会(Daily Standup Meeting)</h2><p>建议上班后开始 或 下班前开始,控制在15分钟内</p>
<h3 id="会议目的-1"><a href="#会议目的-1" class="headerlink" title="会议目的"></a>会议目的</h3><p> • 团队在会议中作计划，协调其每日活动，还可以报告和讨论遇到的障碍。<br> • 任务板能够帮助团队聚焦于每日活动之上，要在这个时候更新任务板和燃尽图</p>
<h3 id="基本要求-2"><a href="#基本要求-2" class="headerlink" title="基本要求"></a>基本要求</h3><p> • 成员：团队、Scrum Master<br> • 无法出席的团队成员要由同伴代表。<br> • 持续时间/举办地点：每天15分钟，同样时间，同样地点。<br>提示：团队成员在聆听他人发言时，都应该想这个问题：“我该怎么帮他做得更快？”</p>
<h3 id="会议输出-2"><a href="#会议输出-2" class="headerlink" title="会议输出"></a>会议输出</h3><p> • 团队彼此明确知道各自的工作，最新的工作进度图。<br> • 得到最新的“障碍 Backlog”<br> • 得到最新的“Sprint Backlog”</p>
<h3 id="会议过程-1"><a href="#会议过程-1" class="headerlink" title="会议过程"></a>会议过程</h3><p> • 团队聚在故事板旁边，可以围成环形。<br> • 从左边第一个开始，向团队伙伴说明他到现在完成的工作。<br> • 然后该成员将任务板上的任务放到正确的列中。<br> • 如果可以的话，该成员可以选取新的任务，交将其放入“进行中工作”列。<br> • 如果该成员遇到问题或障碍，就要将其报告给 Scrum Master。<br> • 每个团队成员重复步骤2到步骤5。</p>
<h3 id="每个人回答三个问题"><a href="#每个人回答三个问题" class="headerlink" title="每个人回答三个问题"></a>每个人回答三个问题</h3><p> • 上次会议时的任务哪些已经完成？<br> 把任务从“正在处理”状态转为“已完成”状态。——今天完成了什么？<br> • 下次会议之前，你计划完成什么任务？<br> 如果任务状态为“待处理”，转为“正在处理”状态。如果任务不在 Sprint Backlog 上，则添加这个任务。如果任务不能在一天成，把这任务细分成多个任务。如果任务可以在一天内完成，把任务状态设为“正在处理”。如果任务状态已经是“正在 处理”，询问是否存在阻碍任务完成得问题。——明天做什么？<br> • 有什么问题阻碍了你的开发？<br> 如果有阻碍你的开发进度的问题，把该障碍加入到障碍 Backlog中。——今天遇到了什么问题？</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><font color="red">注意事项</font></h3><p> • <font color="red">不要迟到</font><br> • <font color="red">不要超出限制时间</font><br> • <font color="red">不要讨论技术问题</font><br> • <font color="red">不要转变会议话题</font><br> • <font color="red">不要在没有准备的情况下参加</font><br> • <font color="red">Scrum Master 不要替团队成员移动任务卡片，不要替团队更新燃尽图。</font><br> • <font color="red">Scrum Master 不要提出问题，团队成员不要向 Scrum Master 或管理层人员报告。</font><br> • <font color="red">如果不能出席会议，需要通知团队，并找一名代表参加。</font></p>
<h2 id="任务板块"><a href="#任务板块" class="headerlink" title="任务板块"></a>任务板块</h2><p> • 任务板集合了选择好的 Product Backlog 和 Sprint Backlog，并以可视化方式展示。<br> • 任务板只能由团队维护，使用不同颜色的“即时贴”来区分开发人员，或者在“即时贴”写上接受任务的姓名。<br> • 尽量使用大白板，也可以使用软件</p>
<h3 id="任务板块有4列"><a href="#任务板块有4列" class="headerlink" title="任务板块有4列"></a>任务板块有4列</h3><p> • 选择好的 Product Backlog：按照优先级，将团队在当前 Sprint 中要着手的 Product Backlog 条目或是故事放在该列中。<br> • 待完成的任务：要完成一个故事，你得完成一些任务。在 Sprint 规划会议中，或是在进行当前 Sprint 中，收集所有特定 Backlog 条目需要完成的新任务，并将它们放入该列。<br> • 进行中的工作：当团队成员开始某个任务后，他会将该任务对应的卡片放到“进行中的工作”列中。从上个每日 Scrum 例会开始，没有完成的任务都会放在该列中，并在上面做标记(通常是个红点)。如果某个任务在“待完成任务”列中所处时间超过一天，就尽量将该任务分为更小 的部分，然后把新任务放到那一列，移除其所属大任务卡片。如果一个新任务因为某个障碍无法完成，就会得到一个红点标记，Scrum Master 就会记下一个障碍。<br> • 完成：当一个任务卡完成后，完成此任务的成员将其放入“完成”列，并开始选取下一张任务卡。</p>
<h2 id="燃尽图"><a href="#燃尽图" class="headerlink" title="燃尽图"></a>燃尽图</h2><p> • 跟踪进度要由团队来完成，燃尽图的横轴表示整个Sprint 的总时间，纵轴表示 Sprint 中所有的任务，其单位可以是小时，人天等。一般来说，燃尽图有”Sprint燃尽图”和”Release燃尽图”之分。<br> • 团队每天更新燃尽图。<br> • 如果燃尽图一直是上升状态，或当 Sprint 进行一段时间之后，Sprint 燃尽图上的Y值仍然与 Sprint 刚开始时相差无几，就说明这个 Sprint 中的 Story 过多，要拿掉一些 Story 以保证这个 Sprint 能顺利完成。 如果Sprint 燃尽图下降得很快，例如 Sprint 刚过半时Y值已经接近0了，则说明这个 Sprint 分配的任务太少，还要多加一些任务进来。在 Sprint 计划会议上，如果团队对即将要做的任务理解和认识不充分，就很可能导致这两种情况的出现。(锻炼团队人员的自我估算时间)<br> • 燃尽图要便于团队更新，没必要让它看起来很炫，也不要过于复杂，难以维护。<br> • Release 燃尽图：记录整个Scurm项目的进度，它的横轴表示这个项目的所有Sprint， 纵轴表示各个Sprint开始前，尚未完成的工作，它的单位可以是个(Story 的数量)，人天等。</p>
<h2 id="Sprint规划会议-Planning-Meeting-——第一部分-上午"><a href="#Sprint规划会议-Planning-Meeting-——第一部分-上午" class="headerlink" title="Sprint规划会议(Planning Meeting)——第一部分(上午)"></a>Sprint规划会议(Planning Meeting)——第一部分(上午)</h2><h3 id="会议目的-2"><a href="#会议目的-2" class="headerlink" title="会议目的"></a>会议目的</h3><p> • <font color="red">该会议的工作以分析为主，目的是要详细理解最终用户到底要什么，产品开发团队可以从该会议中详细了解最终用户的真实需要。在会议的结束，团队将会决定他们能够交付哪些东西。</font><br> • <font color="red">产品负责人在会前准备：条目化的需求(用户故事)，优先级排序，最近1~2个迭代最希望看到的功能。会前准备至关重要，可帮助产品负责人理清头绪，不至于在迭代期内频繁提出变更、增加或删除故事。</font></p>
<h3 id="基本要求-3"><a href="#基本要求-3" class="headerlink" title="基本要求"></a>基本要求</h3><p> • <font color="red">迭代计划会在每个迭代第一天召开，目的是选择和估算本次迭代的工作项。</font><br> • <font color="red">只有团队成员才能决定团队在当前 Sprint 中能够领取多少个 Backlog 条目的工作。</font></p>
<h3 id="构成部分：-1"><a href="#构成部分：-1" class="headerlink" title="构成部分："></a>构成部分：</h3><p> • 经过估算和排序的 Product Backlog。<br> • 挂图、马克笔、剪刀、胶水、即时贴、白板、铅笔和蜡笔。<br> • <font color="red">假期计划表、重要人员的详细联系信息。</font><br> • 参会成员：团队成员、Scrum Master、产品负责人</p>
<h3 id="持续时间"><a href="#持续时间" class="headerlink" title="持续时间"></a>持续时间</h3><p>在 Sprint 中，每周该会议占用时间为 60 分钟，在早上召开该会议，这样还有可能在同一天召开 Sprint 规划会议的第二部分。</p>
<h3 id="会议过程-2"><a href="#会议过程-2" class="headerlink" title="会议过程"></a>会议过程</h3><p> • 从第一个 Product Backlog 条目(故事)开始。<br> • 讨论该 Product Backlog 条目，以深入理解。<br> • 分析、明确用户验收测试。<br> • 找到非功能性需求(性能、稳定性…)<br> • 找到验收条件。<br> • 弄清楚需要“完成”到何种水平。<br> • 获得 Backlog 条目各个方面的清晰了解。<br> • 绘制出所需交付物的相关图表，包括流程图、UML图、手绘草图、屏幕 UI 设计等。<br> • 回到步骤1，选取下一个 Backlog 条目。</p>
<h3 id="流程检查"><a href="#流程检查" class="headerlink" title="流程检查"></a>流程检查</h3><p>询问团队能否快速回答下列问题，只需要简要回答即可：<br>“我们能在这个 Sprint 中完成第一个 Backlog 条目吗？”如果能得到肯定的回答，那么继续询问下一个 Backlog 条目，一直到已经分析完的最后一个 Backlog 条目。——接下来，休息一下。在休息后，对下一个 Backlog 条目展开上述流程。</p>
<h3 id="结束流程："><a href="#结束流程：" class="headerlink" title="结束流程："></a>结束流程：</h3><p> • 在 Sprint 规划会议第一部分结束前留出 20 分钟。<br> • 再次提问——这次要更加严肃、正式：“你们能否完成第一个 Backlog 条目，…第二个，…？”<br> • 如果团队认为他们不能再接受更多的 Backlog 条目，那就停下来。<br> • 现在是非常重要的一步：送走 Product Owner，除了团队和 Scrum Master 之外的所有人，都得离开。<br> • 当其他人都离开后，再询问团队：“说真的——你们相信自己可以完成这个列表？”<br> • 希望团队现在能短暂讨论一下，看看他们到底认为自己能完成多少工作。<br> • 将结果与 Product Owner 和最终用户沟通。</p>
<p> <font color="red">注意事项：不要改变 Backlog 条目大小，不要估算任务。</font></p>
<h3 id="会议输出-3"><a href="#会议输出-3" class="headerlink" title="会议输出"></a>会议输出</h3><p>明确需求:做什么,怎么做,测试范围<br> • 选择好的 Product Backlog 条目。<br> • 各个 Backlog 条目的需求。<br> • 各个定义Backlog 条目的用户验收测试。</p>
<h2 id="Sprint规划会议-Planning-Meeting-——第二部分-下午"><a href="#Sprint规划会议-Planning-Meeting-——第二部分-下午" class="headerlink" title="Sprint规划会议(Planning Meeting)——第二部分(下午)"></a>Sprint规划会议(Planning Meeting)——第二部分(下午)</h2><h3 id="会议目的-3"><a href="#会议目的-3" class="headerlink" title="会议目的"></a>会议目的</h3><p> •  <font color="red">该会议的工作以设计为主，产品开发团队可以为他们要实现的解决方案完成设计工作，在会议结束后，团队知道如何构建他们在当前 Sprint 中要开发的功能。</font></p>
<h3 id="基本要求-4"><a href="#基本要求-4" class="headerlink" title="基本要求"></a>基本要求</h3><p> • 只有产品开发团队才能制定解决方案，架构师或其他团队之外的人只是受邀帮助团队。</p>
<h3 id="构成部分：-2"><a href="#构成部分：-2" class="headerlink" title="构成部分："></a>构成部分：</h3><p> • 能够帮助团队在该 Sprint 中构建解决方案的人，比如厂商或是来自其他团队的人员。<br> • 选择好的 Product Backlog 条目。<br> • 挂图……<br> <font color="red">注意事项：不要估算任务，不要分配任务。</font></p>
<h3 id="会议输出-4"><a href="#会议输出-4" class="headerlink" title="会议输出"></a>会议输出</h3><p> • 应用设计、架构设计图、相关图表<br> • 确保团队知道应该如何完成任务！</p>
<h3 id="会议过程-3"><a href="#会议过程-3" class="headerlink" title="会议过程"></a>会议过程</h3><p> • 从第一个 Backlog 条目开始。<br> • 查看挂图，确定对于客户的需求理解正确。<br> • 围绕该 Backlog 条目进行设计，并基于下列类似问题： • 我们需要编写什么样的接口？<br> • 我们需要创建什么样的架构？<br> • 我们需要更新哪些表？<br> • 我们需要更新或是编写哪些组件？</p>
<p>当团队明确知道自己应该如何开发该功能后，就可以转向下一个 Backlog 条目了。在会议的最后 10 分钟，团队成员使用即时贴写出初步的任务。这能帮助团队成员知道接下来的工作从哪里开展，将这些任务放在任务板上。</p>
<h3 id="持续时间："><a href="#持续时间：" class="headerlink" title="持续时间："></a>持续时间：</h3><p>在 Sprint 规划会议第一部分完成后，召开该会议。可以将午餐作为两次会议的一个更长久的休息。但是要在同一天完成 Sprint 规划第一部分，在 Sprint 中，每周该会议占用时间为 60 分钟。</p>
<h2 id="扑克牌估算"><a href="#扑克牌估算" class="headerlink" title="扑克牌估算"></a>扑克牌估算</h2><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><p> • 每个人各自估算后独立出暗牌，听口令一起开牌。<br> • 数值最大者与最小者PK，其他人旁听也可参考。<br> • 讨论结束后重新出牌和开牌。<br> • 重复上述过程，直到结果比较接近。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>1、为什么任务要分给组而不是个人？<br>答：因为怕出错了牌又说不出所以然，这样即使日后他不做这个功能，也对这个功能很了解。</p>
<p>2、为什么不让最后领任务的人自己估算？<br>答：因为他很可能因为不知道某代码可用、不知道某软件不行….而选择了错误的实现方法。</p>
<p>3、为什么不让师傅估算大家采纳，他不是最厉害吗？<br>答：师傅的想法常常是徒弟们理解不了的，比如为什么不留在女儿国而偏偏去西天取经之类的，共同估算就是让大家在思考中对照自己的实现方法和师傅差异的过程。</p>
<h2 id="Sprint评审会议-Review-Meeting"><a href="#Sprint评审会议-Review-Meeting" class="headerlink" title="Sprint评审会议(Review Meeting)"></a>Sprint评审会议(Review Meeting)</h2><h3 id="会议目的-4"><a href="#会议目的-4" class="headerlink" title="会议目的"></a>会议目的</h3><p> •  <font color="red">Scrum 团队在会议中向最终用户展示工作成果，团队成员希望得到反馈，并以之创建或变更 Backlog 条目。</font><br> •  根据情况确定该会议,可能存在不需要用户反馈的spring,但是一定要做到,设法得到用户对团队的反馈;有时候未必能接触用户,只能接触PO</p>
<h3 id="基本要求-5"><a href="#基本要求-5" class="headerlink" title="基本要求"></a>基本要求</h3><p> • Sprint 复审会议允许所有的参与者尝试由团队展示的新功能。<br> • 由团队展示有可能发布的产品增量。</p>
<h3 id="会议输出-5"><a href="#会议输出-5" class="headerlink" title="会议输出"></a>会议输出</h3><p> • 来自最终用户的反馈。<br> • 障碍 Backlog 的输入。<br> • 团队 Backlog 的输入。<br> • 来自团队的反馈为 Product Backlog 产生输入。</p>
<p>持续时间：90分钟，在 Sprint 结束时进行。</p>
<h3 id="会议过程-4"><a href="#会议过程-4" class="headerlink" title="会议过程"></a>会议过程</h3><p> • Product Owner 欢迎大家来参加 Sprint 复审会议。<br> • Product Owner 提醒大家关于本次 Sprint 的目的：Sprint 目标、Scrum 团队在本次 Sprint 中选定要开发的故事。<br> • 产品开发团队展示新功能，并让最终用户尝试新功能。<br> • Scrum Master 推进会议进程。<br> • 最终用户的反馈将会由 Product Owner 和/或 Scrum Master 记录在案。</p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p> • 不要展示不可能发布的产品增量。<br> • Scrum Master 不要负责展示结果。<br> • 团队不要针对 Product Owner 展示。</p>
<h2 id="Sprint反思会议-Retrospective-Meeting"><a href="#Sprint反思会议-Retrospective-Meeting" class="headerlink" title="Sprint反思会议(Retrospective Meeting)"></a>Sprint反思会议(Retrospective Meeting)</h2><h3 id="会议目的-5"><a href="#会议目的-5" class="headerlink" title="会议目的"></a>会议目的</h3><p> • 该会议的对应隐喻：医疗诊断！其目的不是为了找到治愈方案，而是要发现哪些方面需要改进。</p>
<h3 id="构成部分"><a href="#构成部分" class="headerlink" title="构成部分"></a>构成部分</h3><p> • <font color="red">参与人员：团队成员、Scrum Master</font></p>
<h3 id="基本要求-6"><a href="#基本要求-6" class="headerlink" title="基本要求"></a>基本要求</h3><p> • 从过去中学习，指导将来。<br> • 改进团队的生产力。</p>
<p>注意事项<br> • 不要让管理层人员参与会议。<br> • 不要在团队之外讨论找到的东西。</p>
<h3 id="会议输出-6"><a href="#会议输出-6" class="headerlink" title="会议输出"></a>会议输出</h3><p> • 障碍 Backlog 的输入。<br> • 团队 Backlog 的输入。</p>
<p>持续时间：90分钟，在 Sprint 评审会议结束后几分钟开始。</p>
<h3 id="会议过程-5"><a href="#会议过程-5" class="headerlink" title="会议过程"></a>会议过程</h3><p> • good,ToImprove,suggestion,puzzle<br> • 准备一个写着“过去哪些做的不错？”的挂图。<br> • 准备一个写着“哪些应该改进？”的挂图。<br> • 绘制一条带有开始和结束日期的时间线。<br> • 给每个团队成员发放一叠即时贴。<br> • 开始回顾。<br> • 做一个安全练习。<br> • 收集事实：发放即时贴，用之构成一条时间线。每个团队成员(包括 Scrum Master)在每张即时贴上写上一个重要的事件。<br> • “过去哪些做的不错？”：采取收集事实同样的过程，不过这次要把即时贴放在准备好的挂图上。<br> • 做一个分隔，以区分“过去哪些做的不错”和接下来要产出的东西。<br> • “哪些应该改进？”：像“过去哪些做的不错”那样进行。<br> • 现在将即时贴分组：<br> • 我们能做什么》团队 Backlog 的输入。<br> • 哪些不在我们掌控之内？》障碍 Backlog 的输入。<br> • 根据团队成员的意见对两个列表排序。<br> • 将这两个列表作为下个 Sprint 的 Sprint 规划会议第一部分和 Sprint 规划会议第二部分的输入，并决定到时候要如何处理这些发现的信息。</p>
]]></content>
      <categories>
        <category>Project Management</category>
      </categories>
      <tags>
        <tag>Scrum</tag>
        <tag>敏捷</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrum流程</title>
    <url>/2021/01/05/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%AE%80%E6%98%93Scrum%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/testertechnology/p/10974959.html" target="_blank" rel="noopener">敏捷测试团队的测试流程</a></p>
<h2 id="初学者简易Scrum教程"><a href="#初学者简易Scrum教程" class="headerlink" title="初学者简易Scrum教程"></a><a href="https://segmentfault.com/a/1190000018474870" target="_blank" rel="noopener">初学者简易Scrum教程</a></h2><p>Agile是一种软件开发方法，可以使用1至4周的短迭代逐步构建软件，以便开发过程与不断变化的业务需求保持一致。而不是预先预测所有要求和风险的6到18个月的单程开发，敏捷采用频繁反馈的过程，其中在1到4周的迭代后交付可行的产品。<br><img src="/scrum/001.png" alt="001" title="001"></p>
<h3 id="敏捷中的角色"><a href="#敏捷中的角色" class="headerlink" title="敏捷中的角色"></a><a href="https://www.visual-paradigm.com/scrum/what-is-scrum-team/" target="_blank" rel="noopener">敏捷中的角色</a></h3><h4 id="跨职能团队"><a href="#跨职能团队" class="headerlink" title="跨职能团队"></a>跨职能团队</h4><p>每个敏捷团队都应该是一个自给自足的团队，拥有5到9名团队成员，平均经验为6到10年。通常，敏捷团队由3到4名开发人员，1名测试人员，1名技术主管，1名产品所有者和1名Scrum主人组成。产品负责人和Scrum master被认为是Team Interface的一部分，而其他成员则是Technical Interface的一部分。<br><img src="/scrum/002.png" alt="002" title="002"></p>
<h4 id="Scrum-Master"><a href="#Scrum-Master" class="headerlink" title="Scrum Master"></a>Scrum Master</h4><p>Scrum Master是团队领导者和推动者，帮助团队成员遵循敏捷实践，以便他们能够履行承诺。Scrum master的职责如下 -</p>
<ul>
<li>实现所有角色和功能之间的紧密合作。</li>
<li>删除任何块。</li>
<li>保护团队免受任何干扰。</li>
<li>与组织合作以跟踪公司的进度和流程。</li>
<li>确保Agile Inspect＆Adapt流程得到适当利用，包括<ol>
<li>每日站立(daliy meeting)</li>
<li>计划会议(planning meeting)</li>
<li>演示</li>
<li>评论(review meeting)</li>
<li>回顾会议(retro meeting)</li>
<li>促进团队会议和决策过程</li>
</ol>
</li>
</ul>
<h4 id="Product-Owner-产品拥有者"><a href="#Product-Owner-产品拥有者" class="headerlink" title="Product Owner(产品拥有者)"></a>Product Owner(产品拥有者)</h4><p>接受符合完成和已定义验收标准定义的用户故事。</p>
<ul>
<li>定义需求并确定其值的优先级。</li>
<li>确定发布日期和内容。</li>
<li>在迭代计划和发布计划会议中发挥积极作用。</li>
<li>确保团队致力于最有价值的要求。</li>
<li>代表客户的声音。</li>
<li>接受符合完成和已定义验收标准定义的用户故事。</li>
</ul>
<h3 id="敏捷团队如何规划其工作？"><a href="#敏捷团队如何规划其工作？" class="headerlink" title="敏捷团队如何规划其工作？"></a>敏捷团队如何规划其工作？</h3><p>敏捷团队在迭代中工作，以提供每次迭代为10到15天的用户故事。每个用户故事都是根据其积压优先级和大小来规划的。团队使用其能力 - 团队可以使用多少小时来完成任务 - 来决定他们计划的范围。<br><img src="/scrum/003.png" alt="003" title="003"></p>
<h3 id="敏捷-故事"><a href="#敏捷-故事" class="headerlink" title="敏捷-故事"></a>敏捷-故事</h3><h4 id="什么是用户故事？"><a href="#什么是用户故事？" class="headerlink" title="什么是用户故事？"></a>什么是用户故事？</h4><p>用户故事是定义用户需要什么作为功能的要求。用户故事可以有两种形式 -</p>
<ul>
<li>作为&lt;用户角色&gt;我想要&lt;功能&gt;以便&lt;业务价值&gt;</li>
<li>为了&lt;业务价值&gt;作为&lt;用户角色&gt;我想要&lt;功能&gt;<br>在发布计划期间，使用相对比例作为点对用户故事进行粗略估计。在迭代计划期间，故事被分解为任务。</li>
</ul>
<h4 id="评估故事-Story-Point"><a href="#评估故事-Story-Point" class="headerlink" title="评估故事(Story Point)"></a>评估故事(Story Point)</h4><p>复杂度，繁琐度，风险系数<br>Point定义了团队可以提交多少。一点通常指8小时。每个故事都以分数估算。<br>容量定义了个人可以提交多少。容量估计为小时。</p>
<h4 id="用户故事与任务的关系"><a href="#用户故事与任务的关系" class="headerlink" title="用户故事与任务的关系"></a>用户故事与任务的关系</h4><ul>
<li>用户故事讲述了要做什么。它定义了用户需要的内容。</li>
<li>任务谈论如何完成。它定义了如何实现功能。</li>
<li>故事由任务实现。每个故事都是一系列任务。</li>
<li>用户故事在当前迭代中计划时分为任务。</li>
<li>任务以小时计算，通常为2至12小时。</li>
<li>使用验收测试验证故事。<br><img src="/scrum/004.png" alt="004" title="004"></li>
</ul>
<h4 id="故事完成标准"><a href="#故事完成标准" class="headerlink" title="故事完成标准"></a>故事完成标准</h4><p>故事决定做什么意味着什么-标准可能是</p>
<ul>
<li>所有任务（开发，测试）都已完成。</li>
<li>所有验收测试都在运行并通过。</li>
<li>没有缺陷是开放的。</li>
<li>产品所有者已经接受了这个故事</li>
<li>可交付给最终用户。</li>
</ul>
<h4 id="如何定义需求任务？"><a href="#如何定义需求任务？" class="headerlink" title="如何定义需求任务？"></a>如何定义需求任务？</h4><p>要求定义为</p>
<ul>
<li>用户故事</li>
<li>有验收标准:定义功能所需的功能，行为和性能，以便产品所有者可以接受。它定义了要做什么，以便开发人员知道用户故事何时完成。</li>
<li>实现故事的任务。</li>
</ul>
<h3 id="敏捷-特征"><a href="#敏捷-特征" class="headerlink" title="敏捷 - 特征"></a>敏捷 - 特征</h3><h4 id="迭代-增量和准备进化"><a href="#迭代-增量和准备进化" class="headerlink" title="迭代/增量和准备进化"></a>迭代/增量和准备进化</h4><p>大多数敏捷开发方法都将问题分解为较小的任务。任何要求都没有直接的长期规划。通常，计划的迭代具有变化的短时间段，例如1至4周。为每个迭代创建一个跨职能团队，该团队适用于软件开发的所有功能，如规划，需求分析，设计，编码，单元测试和验收测试。迭代结束时的结果是一个工作产品，它在迭代结束时向利益相关者展示。演示之后，将审核评论并计划根据需要合并到工作软件中。</p>
<h4 id="面对面交流"><a href="#面对面交流" class="headerlink" title="面对面交流"></a>面对面交流</h4><p>每个敏捷团队都应该有一个客户代表，例如scrum方法中的产品所有者。该代表被授权代表利益相关者行事，他可以在迭代之间回答开发人员的查询。<br>信息辐射器（物理显示器）通常位于办公室的显眼位置，路人可以看到敏捷团队的进度。此信息散热器显示项目状态的最新摘要。  </p>
<h4 id="反馈回路"><a href="#反馈回路" class="headerlink" title="反馈回路"></a>反馈回路</h4><p>每日站立是任何敏捷开发的共同文化; 它也被称为每日Scrum。这是一种简短的会话，每个团队成员互相报告他们所做的事情，下一步该做什么以及他们面临的任何问题。</p>
<h3 id="敏捷-每日站立运作-daliy-meeting"><a href="#敏捷-每日站立运作-daliy-meeting" class="headerlink" title="敏捷-每日站立运作(daliy meeting)"></a>敏捷-每日站立运作(daliy meeting)</h3><p>顾名思义，每日站立是敏捷团队所有成员之间的每日状态会议。它不仅提供定期更新的论坛，而且还将团队成员的问题集中在一起，以便快速解决。无论办公地点如何，无论如何建立敏捷团队，每日站立都是必须的做法。</p>
<h4 id="每日站立"><a href="#每日站立" class="headerlink" title="每日站立"></a>每日站立</h4><ul>
<li>每日站立是所有团队成员之间的每日状态会议，大约持续15分钟。</li>
<li>每个成员都必须回答三个重要问题 -<ol>
<li>我昨天做了什么？</li>
<li>我今天要做什么？</li>
<li>我面临的任何障碍…… /我因……而被封锁</li>
</ol>
</li>
<li>每日站立是为了状态更新，而不是任何讨论。对于讨论，团队成员应该在不同的时间安排另一次会议。</li>
<li>参与者通常站立而不是坐着，以便会议快速结束。</li>
</ul>
<h4 id="为什么站立是重要的？"><a href="#为什么站立是重要的？" class="headerlink" title="为什么站立是重要的？"></a>为什么站立是重要的？</h4><p>每日站立敏捷的好处如下 -</p>
<ul>
<li>团队可以每天评估进度，看看他们是否可以按照迭代计划进行交付。</li>
<li>每个团队成员都会告知他/她当天的承诺。</li>
<li>它可以让团队了解任何延迟或障碍。</li>
</ul>
<h4 id="谁出席了站立？"><a href="#谁出席了站立？" class="headerlink" title="谁出席了站立？"></a>谁出席了站立？</h4><ul>
<li>Scrum主管，产品所有者和交付团队应每天参加站立。</li>
<li>鼓励利益相关者和客户参加会议，他们可以作为观察员，但他们不应该参加站立。</li>
<li>Scrum主管有责任记录每个团队成员的疑问及他们面临的问题。</li>
</ul>
<h4 id="地理位置分散的团队"><a href="#地理位置分散的团队" class="headerlink" title="地理位置分散的团队"></a>地理位置分散的团队</h4><p>如果敏捷团队成员在不同的时区运营，可以通过多种方式进行站立 -</p>
<ul>
<li>轮流选择会员，谁可以参加位于不同时区的团队的站立会议。</li>
<li>每个团队单独站立，在Rally，SharePoint，Wikis等工具中更新站立状态。</li>
<li>拥有各种各样的通信工具，如电话会议，视频会议，即时消息或任何其他第三方知识共享工具。</li>
</ul>
<h3 id="敏捷-完成的定义"><a href="#敏捷-完成的定义" class="headerlink" title="敏捷 - 完成的定义"></a>敏捷 - 完成的定义</h3><h4 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h4><p>用户故事是在用户的日常用语中用几句话表达的要求，并且应该在迭代内完成。用户故事在何时完成</p>
<ul>
<li>所有相关代码都已签入。</li>
<li>所有单元测试用例都已通过。</li>
<li>所有验收测试用例均已通过。</li>
<li>帮助文本已写入。</li>
<li>产品负责人接受了这个故事。</li>
</ul>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>迭代是在产品发布中处理和接受的用户故事/缺陷的时间盒装集合。迭代在迭代计划会议期间定义，并通过迭代演示和审阅会议完成。迭代也称为冲刺。迭代完成时</p>
<ul>
<li>产品备份完成。</li>
<li>性能已经过测试。</li>
<li>用户故事已被接受或移至下一次迭代。</li>
<li>缺陷已被修复或推迟到下一次迭代。</li>
</ul>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>版本是一个重要的里程碑，代表产品/系统的工作，测试版本的内部或外部交付。发布时就完成了</p>
<ul>
<li>系统经过压力测试。</li>
<li>性能得到了调整。</li>
<li>进行安全验证。</li>
<li>灾难恢复计划已经过测试。</li>
</ul>
<h3 id="敏捷-发布计划"><a href="#敏捷-发布计划" class="headerlink" title="敏捷 - 发布计划"></a>敏捷 - 发布计划</h3><p>发布计划的目的是创建一个计划，以便为产品提供增量。每2至3个月完成一次。</p>
<h4 id="谁参与了？"><a href="#谁参与了？" class="headerlink" title="谁参与了？"></a>谁参与了？</h4><ul>
<li>Scrum Master - Scrum master是敏捷交付团队的推动者。</li>
<li>产品负责人 - 产品负责人代表产品待办事项的一般视图。</li>
<li>敏捷团队 - 敏捷交付团队提供有关技术可行性或任何依赖关系的见解。</li>
<li>利益相关者 - 像客户，项目经理，主题专家这样的利益相关者担任顾问，因为决策是围绕发布计划做出的。</li>
</ul>
<h4 id="规划的先决条件"><a href="#规划的先决条件" class="headerlink" title="规划的先决条件"></a>规划的先决条件</h4><p>发布计划的先决条件如下 -</p>
<ul>
<li>由产品负责人管理的排名产品积压。通常采用五到十个特征，产品所有者认为可以包含在版本中</li>
<li>团队关于能力，已知速度或任何技术挑战的意见</li>
<li>高层愿景</li>
<li>市场和业务目标</li>
<li>确认是否需要新产品积压项目</li>
</ul>
<h4 id="所需材料"><a href="#所需材料" class="headerlink" title="所需材料"></a>所需材料</h4><p>发布计划所需的材料清单如下 -</p>
<ul>
<li>发表议程，目的</li>
<li>翻转图表，白板，标记</li>
<li>投影仪，在计划会议期间共享具有所需数据/工具的计算机的方式</li>
<li>规划数据</li>
</ul>
<h4 id="规划数据"><a href="#规划数据" class="headerlink" title="规划数据"></a>规划数据</h4><p>进行发布计划所需的数据列表如下 -</p>
<ul>
<li>以前的迭代或发布计划结果</li>
<li>各利益相关方对产品，市场状况和截止日期的反馈</li>
<li>先前版本/迭代的行动计划</li>
<li>要考虑的特征或缺陷</li>
<li>先前版本/估计的速度。</li>
<li>组织和个人日历</li>
<li>来自其他团队和主题专家的输入，以管理任何依赖关系</li>
</ul>
<h4 id="产量"><a href="#产量" class="headerlink" title="产量"></a>产量</h4><p>发布计划的输出可以是以下 -</p>
<ul>
<li>发布计划</li>
<li>承诺</li>
<li>要监控的问题，顾虑，依赖关系和假设</li>
<li>建议改进未来的发布计划</li>
</ul>
<h4 id="议程"><a href="#议程" class="headerlink" title="议程"></a>议程</h4><p>发布计划的议程可以是 -</p>
<ul>
<li>开幕式 - 欢迎辞，审查目的和议程，组织工具和商业赞助商介绍。</li>
<li>产品愿景，路线图 - 展示产品的大图。</li>
<li>查看以前的版本 - 讨论可能影响计划的任何项目。</li>
<li>发布名称/主题 - 检查路线图主题的当前状态并执行所需的调整（如果有）。</li>
<li>速度 - 显示当前版本和先前版本的速度。</li>
<li>发布计划 - 审核关键里程碑并决定发布时的发布和迭代时间框。</li>
<li>问题和顾虑 - 检查任何问题或问题并记录下来。</li>
<li>回顾和更新所做的定义 -回顾的定义完成，并根据技术，技能或团队成员自上次迭代/释放变化作适当的改变。</li>
<li>要考虑的故事和项目 - 显示产品待办事项中的用户故事和功能，以便在当前版本中进行安排。</li>
<li>确定大小调整值 - 如果速度未知，则计划要在发布计划中使用的大小调整值。</li>
<li>粗略的故事大小 - 交付团队确定所考虑故事的适当大小，并在故事太大时将故事分成多个迭代。产品所有者和主题专家澄清疑虑，详细说明验收标准，并进行适当的故事分割。Scrum master促进了协作。</li>
<li>将故事映射到迭代 - 交付团队和产品所有者根据大小和速度移动迭代中的故事/缺陷。Scrum master促进了协作。</li>
<li>新的顾虑或问题 - 根据以往的经验检查任何新问题并记录相同的问题。</li>
<li>依赖关系和假设 - 检查在发布计划期间计划的任何依赖关系/假设。</li>
<li>提交 - Scrum master要求进行规划。交付团队和产品负责人将其视为最佳计划，然后承诺进入下一级计划，即迭代计划。</li>
<li>沟通和物流规划 - 审核/更新发布的沟通和后勤规划。</li>
<li>停车场 - 处理停车场意味着所有项目都应该被解决或设置为行动项目。</li>
<li>分发行动项目和行动计划 - 在其所有者之间分配行动项目，处理行动计划。</li>
<li>回顾 - 征求参与者的反馈意见，使会议取得成功。</li>
<li>关闭 - 庆祝成功。</li>
</ul>
<h3 id="敏捷-迭代计划"><a href="#敏捷-迭代计划" class="headerlink" title="敏捷 - 迭代计划"></a>敏捷 - 迭代计划</h3><p>迭代计划的目的是让团队完成一系列排名靠前的产品积压项目。此承诺是基于迭代长度和团队速度的时间框。<br><img src="/scrum/007.png" alt="007" title="007"></p>
<h4 id="谁参与了？-1"><a href="#谁参与了？-1" class="headerlink" title="谁参与了？"></a>谁参与了？</h4><p>Scrum Master - Scrum master是敏捷交付团队的推动者。<br>产品负责人 - 产品负责人处理产品待办事项的详细视图及其验收标准。<br>敏捷团队 - 敏捷交付定义了他们的任务，并设置了履行承诺所需的工作量估算。</p>
<h4 id="规划的先决条件-1"><a href="#规划的先决条件-1" class="headerlink" title="规划的先决条件"></a>规划的先决条件</h4><ul>
<li>产品待办事项中的项目已调整大小并分配了相对故事点。</li>
<li>产品所有者已对产品组合项进行了排名。</li>
<li>已为每个项目组合项目明确说明了接受标准。</li>
</ul>
<h4 id="规划过程"><a href="#规划过程" class="headerlink" title="规划过程"></a>规划过程</h4><p>以下是迭代计划中涉及的步骤 -</p>
<ul>
<li>确定迭代中可以容纳多少个故事。</li>
<li>将这些故事分解为任务并将每个任务分配给其所有者。</li>
<li>每项任务都以小时为单位进行估算。</li>
<li>这些估计值可帮助团队成员检查每个成员为迭代执行的任务小时数。</li>
<li>考虑到团队成员的速度或能力，他们会被分配任务，以免他们负担过重。</li>
</ul>
<h4 id="速度计算"><a href="#速度计算" class="headerlink" title="速度计算"></a>速度计算</h4><p>敏捷团队根据过去的迭代计算速度。Velocity是在迭代中完成用户故事所需的平均单位数。例如，如果团队在最后三次迭代中在每次迭代中花费了12,14,10个故事点，则团队可以将12作为下一次迭代的速度。<br>计划速度告诉团队在当前迭代中可以完成多少用户故事。如果团队快速完成分配的任务，则可以提取更多用户故事。否则，故事也可以移出到下一次迭代。</p>
<h4 id="任务能力"><a href="#任务能力" class="headerlink" title="任务能力"></a>任务能力</h4><p>团队的能力来自以下三个事实 -</p>
<ul>
<li>一天中理想的工作时数</li>
<li>迭代中的人的可用天数</li>
<li>成员专门为团队提供的时间百分比。</li>
</ul>
<p>假设一个团队有5名成员，他们致力于在项目中全职工作（每天8小时），并且在迭代期间没有人休假，那么两周迭代的任务能力将是 -<br>5×8×10 = 400小时</p>
<h4 id="规划步骤"><a href="#规划步骤" class="headerlink" title="规划步骤"></a>规划步骤</h4><ul>
<li>产品负责人描述了排名最高的产品待办事项。</li>
<li>团队描述完成项目所需的任务。</li>
<li>团队成员拥有这些任务。</li>
<li>团队成员估计完成每项任务的时间。</li>
<li>对迭代中的所有项重复这些步骤。</li>
<li>如果任何个人的任务过载，那么他/她的任务将分配给其他团队成员。</li>
</ul>
<h3 id="敏捷-产品Backlog"><a href="#敏捷-产品Backlog" class="headerlink" title="敏捷 - 产品Backlog"></a>敏捷 - 产品Backlog</h3><p>产品待办事项是要完成的项目列表。项目按功能描述排名。在理想情况下，项目应分解为用户故事。</p>
<h4 id="产品Backlog为何重要？"><a href="#产品Backlog为何重要？" class="headerlink" title="产品Backlog为何重要？"></a>产品Backlog为何重要？</h4><ul>
<li>它是经过准备的，可以对每个特征进行估算。</li>
<li>它有助于规划产品的路线图。</li>
<li>它有助于对功能进行重新排名，从而可以为产品添加更多价值。</li>
<li>它有助于确定优先排序的内容。团队对项目进行排名，然后建立价值。</li>
</ul>
<h4 id="产品积压的特征"><a href="#产品积压的特征" class="headerlink" title="产品积压的特征"></a>产品积压的特征</h4><ul>
<li>每个产品应该有一个产品积压，可以有一组大到大的功能。</li>
<li>多个团队可以处理单个产品待办事项。</li>
<li>功能排名基于业务价值，技术价值，风险管理或战略适应性。</li>
<li>在发布计划期间，排名最高的项目会被分解为较小的故事，以便在将来的迭代中完成。</li>
</ul>
<h3 id="敏捷-实用术语"><a href="#敏捷-实用术语" class="headerlink" title="敏捷 - 实用术语"></a>敏捷 - 实用术语</h3><h4 id="验收标准"><a href="#验收标准" class="headerlink" title="验收标准"></a>验收标准</h4><p>这是产品所有者或客户设定的条件，以便接受有效且符合其要求的功能。</p>
<h4 id="积压修饰"><a href="#积压修饰" class="headerlink" title="积压修饰"></a>积压修饰</h4><p><img src="/scrum/008.png" alt="008" title="008"><br>这是一个持续的过程，产品经理或客户通过从敏捷团队获得反馈来管理产品待办事项。这个过程包括对项目组合项目进行优先排序，将它们分解为较小的项目，为将来的迭代计划它们，创建新的故事，更新验收标准或详细阐述验收标准。</p>
<h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>这是团队在一次迭代中完成的工作量。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>这是团队在一次迭代中完成的工作量。</p>
<h4 id="增量"><a href="#增量" class="headerlink" title="增量"></a>增量</h4><p>增量是产品在逐渐发展时的变化状态。它通常由里程碑或固定迭代次数表示。</p>
<h4 id="产品拥有者"><a href="#产品拥有者" class="headerlink" title="产品拥有者"></a>产品拥有者</h4><p>产品所有者是敏捷交付团队的成员，负责收集产品待办事项中的业务需求并对其进行排名。产品所有者在发布/迭代中传达要执行的操作。他/她设定承诺并负责保护团队在迭代期间不受任何需求变化的影响。</p>
<h4 id="产品积压"><a href="#产品积压" class="headerlink" title="产品积压"></a>产品积压</h4><p>一套功能性和非功能性产品要求。</p>
<h4 id="产品待办事项"><a href="#产品待办事项" class="headerlink" title="产品待办事项"></a>产品待办事项</h4><p>可能是敏捷团队要开发的用户故事，缺陷和功能。</p>
<h4 id="点"><a href="#点" class="headerlink" title="点"></a>点</h4><p>用于设置用户故事，功能或任何其他项目组合项的相对大小的常用单位。</p>
<h4 id="发布-1"><a href="#发布-1" class="headerlink" title="发布"></a>发布</h4><p>一个时间框，用于完成工作以支持向软件提供可测试的增量。在scrum中，发布包含多次迭代。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>满足所述合同或功能的软件产品规范。用户故事和项目组合项目是需求类型。</p>
<h4 id="故事点"><a href="#故事点" class="headerlink" title="故事点"></a>故事点</h4><p>敏捷团队用于估计用户故事和功能的相对大小的单元。</p>
<h4 id="短跑"><a href="#短跑" class="headerlink" title="短跑"></a>短跑</h4><p>与迭代相同。</p>
<h4 id="时间盒"><a href="#时间盒" class="headerlink" title="时间盒"></a>时间盒</h4><p>确定可交付成果的固定持续时间。通常，随着时间框的修复开始和结束日期，资源的数量也是固定的。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>它是一个工作单元，有助于在迭代中完成用户故事。用户故事被分解为多个任务，每个任务可以在团队成员之间划分，并将其标记为任务的所有者。团队成员可以根据需要负责每项任务，更新估算，记录已完成的工作或待办事项。</p>
<h4 id="用户故事-1"><a href="#用户故事-1" class="headerlink" title="用户故事"></a>用户故事</h4><p>列出的验收标准，以满足用户的某些要求。它通常是从最终用户的角度编写的。</p>
<h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>在迭代或时间框中对接受的工作进行加权的度量。通常它是迭代中接受的故事点的总和。</p>
]]></content>
      <categories>
        <category>Project Management</category>
      </categories>
      <tags>
        <tag>Scrum</tag>
        <tag>敏捷</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理流程总结</title>
    <url>/2021/01/05/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="项目简单介绍"><a href="#项目简单介绍" class="headerlink" title="项目简单介绍"></a>项目简单介绍</h2><h3 id="什么是项目管理？"><a href="#什么是项目管理？" class="headerlink" title="什么是项目管理？"></a>什么是项目管理？</h3><p>工作涉及项目管理，生活同样涉及：婚礼、旅游、聚餐。甚至交女朋友也是需要一点项目管理知识的。<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861.png" alt="项目管理1" title="项目管理1"></p>
<h3 id="项目管理计划部分"><a href="#项目管理计划部分" class="headerlink" title="项目管理计划部分"></a>项目管理计划部分</h3><p>项目管理中，最费时的是第二部分：计划<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%862.png" alt="项目管理2" title="项目管理2"></p>
<h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><h3 id="项目管理启动要做什么"><a href="#项目管理启动要做什么" class="headerlink" title="项目管理启动要做什么"></a>项目管理启动要做什么</h3><p>项目管理启动要做什么？很多人会忽略W和H的问题。其中一个原因是很多课程都有这种提炼，很多人自己乱了。<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%863.png" alt="项目管理3" title="项目管理3"></p>
<h3 id="搞清楚为什么立项-Why"><a href="#搞清楚为什么立项-Why" class="headerlink" title="搞清楚为什么立项(Why)"></a>搞清楚为什么立项(Why)</h3><p>先搞清楚为什么很重要，磨刀不误砍柴工<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%864.png" alt="搞清楚为什么立项" title="搞清楚为什么立项"></p>
<h3 id="搞清楚项目目标是什么"><a href="#搞清楚项目目标是什么" class="headerlink" title="搞清楚项目目标是什么"></a>搞清楚项目目标是什么</h3><p>大多数时候，这里有KPI<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%867.png" alt="搞清楚项目目标是什么" title="搞清楚项目目标是什么"></p>
<h4 id="识别需求"><a href="#识别需求" class="headerlink" title="识别需求"></a>识别需求</h4><p>识别真实有用的需求(有价值):有女朋友的人一定很明白这个道理：want ≠ need<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%865.png" alt="识别需求" title="识别需求"></p>
<h4 id="三要素分析"><a href="#三要素分析" class="headerlink" title="三要素分析"></a>三要素分析</h4><p>上级要求你在成本削减的情况下，仍然要保质保量，你怎么办？你要学习另一门课程《向上管理》<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%866.png" alt="三要素分析" title="三要素分析"></p>
<h4 id="项目目标标准"><a href="#项目目标标准" class="headerlink" title="项目目标标准:"></a>项目目标标准:</h4><p>做好项目目标需要了解以下几点：</p>
<ul>
<li>1.设计和开发经常挑战产品经理的需求要明确；</li>
<li>2.做市场的同学可能会比较头疼；</li>
<li>3.启动时要考虑的；</li>
<li>4.要考虑臣妾的能力；</li>
<li>5.项目管理都是有周期的。<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%868.png" alt="项目目标标准" title="项目目标标准"></li>
</ul>
<h4 id="如何写项目目标"><a href="#如何写项目目标" class="headerlink" title="如何写项目目标"></a>如何写项目目标</h4><p>对着列出这几点很重要<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%869.png" alt="如何写项目目标" title="如何写项目目标"></p>
<h3 id="谁是相关方-Who"><a href="#谁是相关方-Who" class="headerlink" title="谁是相关方(Who)"></a>谁是相关方(Who)</h3><p>关于相关方，宝洁的方法论是找出PACE。P是Participant（参与者），A是Approver（审批者），C是Consultant（顾问），E是Executor（执行者）<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861001.png" alt="谁是相关方" title="谁是相关方"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861002.png" alt="谁是相关方" title="谁是相关方"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861003.png" alt="谁是相关方" title="谁是相关方"></p>
<h3 id="怎么样立项-How"><a href="#怎么样立项-How" class="headerlink" title="怎么样立项(How)"></a>怎么样立项(How)</h3><p>这里主要是流程立项，通常来说会召开一个启动大会<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%8611.png" alt="怎么样立项" title="怎么样立项"></p>
<h2 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h2><h3 id="分解工作包WBS"><a href="#分解工作包WBS" class="headerlink" title="分解工作包WBS"></a>分解工作包WBS</h3><p>工作分解的方法论，涉及很多细节，需要有足够的精力来完成这一部分。因为这一部分是重中之重<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%8612.png" alt="分解工作包WBS" title="分解工作包WBS"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861201.png" alt="分解工作包WBS" title="分解工作包WBS"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861202.png" alt="分解工作包WBS" title="分解工作包WBS"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861203.png" alt="分解工作包WBS" title="分解工作包WBS"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861204.png" alt="分解工作包WBS" title="分解工作包WBS"></p>
<h3 id="任务排序"><a href="#任务排序" class="headerlink" title="任务排序"></a>任务排序</h3><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861205.png" alt="任务排序" title="任务排序"></p>
<h3 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h3><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861301.png" alt="项目进度" title="项目进度"></p>
<h3 id="项目风险"><a href="#项目风险" class="headerlink" title="项目风险"></a>项目风险</h3><p>最大的风险有时候会来自内部：领导要求变更<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861302.png" alt="项目风险" title="项目风险"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861303.png" alt="项目风险" title="项目风险"></p>
<h2 id="项目执行与监督控制"><a href="#项目执行与监督控制" class="headerlink" title="项目执行与监督控制"></a>项目执行与监督控制</h2><h3 id="项目执行与控制"><a href="#项目执行与控制" class="headerlink" title="项目执行与控制"></a>项目执行与控制</h3><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861305.png" alt="项目执行与控制" title="项目执行与控制"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861306.png" alt="项目执行与控制" title="项目执行与控制"></p>
<h3 id="项目变更"><a href="#项目变更" class="headerlink" title="项目变更"></a>项目变更</h3><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861307.png" alt="项目变更" title="项目变更"><br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%861308.png" alt="项目变更" title="项目变更"></p>
<h2 id="项目收尾-交付与总结"><a href="#项目收尾-交付与总结" class="headerlink" title="项目收尾(交付与总结)"></a>项目收尾(交付与总结)</h2><p>有很多人可能会忽视了总结。一个项目做完了就是做完了，没有内容整理存档和个人经验提升的总结意识<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%8614.png" alt="项目收尾" title="项目收尾"></p>
<h2 id="项目整体流程总结"><a href="#项目整体流程总结" class="headerlink" title="项目整体流程总结"></a>项目整体流程总结</h2><p>内容回顾，这张图适合打印出来放在工位<br><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%8615.png" alt="项目整体流程细节" title="项目整体流程细节"></p>
<h2 id="最后实际的tips"><a href="#最后实际的tips" class="headerlink" title="最后实际的tips"></a>最后实际的tips</h2><p><img src="/pmp/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%8616.png" alt="最后实际的tips" title="最后实际的tips"></p>
<p>就像开头说的，项目管理是很多人的痛点。做好项目管理能让自己省很多工夫。项目管理本身不生产价值，但是促使价值产生。<br>做好项目管理，拒绝无谓加班。至少，不能让别人把自己催得暴跳如雷</p>
]]></content>
      <categories>
        <category>Project Management</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理注意事项</title>
    <url>/2021/01/05/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>在技术岗上，你的成功就只是决定于你做得有多好；在管理岗上，你的成功决定于别人做得有多好。成为管理者，一定要有这个思维方式的转变，重点是让别人（主要是属下）做好，而不是自己亲自动手。改倾听方式，反思沟通技巧,以问题导向,总分总结构说明问题。工作然后阶段得有规划，沟通要有目标和结构化，汇报工作要有结构化理清楚做了什么，有什么问题，可以解决方案，有什么计划</p>
<h2 id="项目经理频繁出现的7大问题及应对"><a href="#项目经理频繁出现的7大问题及应对" class="headerlink" title="项目经理频繁出现的7大问题及应对"></a>项目经理频繁出现的7大问题及应对</h2><p>在项目实施过程中,经常会遇到很多意想不到的情况,如:计划有问题、人员能力不足、进度赶不上资源环境有问题等,这些问题一股脑的抛给项目经理,于是项目经理成了项目中最忙碌的人,不是在救火就是在去救火的路上。本文剖析了项目经理频繁救火的七个问题及应对,希望能给大家带来帮助。</p>
<h3 id="关注当前进度-缺乏全面规划问题"><a href="#关注当前进度-缺乏全面规划问题" class="headerlink" title="关注当前进度,缺乏全面规划问题:"></a>关注当前进度,缺乏全面规划问题:</h3><p>项目初期,只关注项目当前进廛计划,忽略了对项目整体目标达成的其他计划的制定,只顾眼前,缺乏长远规划。</p>
<ol>
<li>项目经理在启动阶段做好项目的实施路径的规划及每个阶段的目标、范围和预期价值</li>
<li>每个阶段的计划要全面,包含:进度、质量、成本、沟通、资源、风险等,可以根据项目的不同而有所侧重,但都需要有规划</li>
<li>部分计划在渐进明细的过程中,需要同步评估其影响范围,对受影响的计划也要做同步调整。</li>
</ol>
<h3 id="依赖制度流程-忽略团队自组织问题"><a href="#依赖制度流程-忽略团队自组织问题" class="headerlink" title="依赖制度流程,忽略团队自组织问题:"></a>依赖制度流程,忽略团队自组织问题:</h3><p>过廛依赖组织的项目管理成熟度,当有成员未尽其责时,未自发进行组织内的有效治理。应对:</p>
<ol>
<li>启动阶段明确项目的组织架构和成员职责,并与囝队达成一致</li>
<li>在项目执行过程中如有成员不履职,项目经理需及时沟通和处理,切不可因为怕得罪人不去进行相关的治理工作,要确保项目成员,在其位谋其政,任其职尽其责。</li>
</ol>
<h3 id="利用个人能力-不懂授权赋责问题"><a href="#利用个人能力-不懂授权赋责问题" class="headerlink" title="利用个人能力,不懂授权赋责问题:"></a>利用个人能力,不懂授权赋责问题:</h3><p>事必躬亲,疲于奔命,不懂得给他人授权赋能,引导和协调成员,发挥成员的最大价值,导致成员逐渐沦为“看客应对:</p>
<ol>
<li>成员遇到问题时,必须按照问题沟通和上升机制来应对,对于未按流程要求执行的,明确给予拒绝,同时做好解释,使其从心里接受</li>
<li>项目成员问题上升后仍无法解决的,则项目经理需带看成员一起解决,一方面可以培养成员解决问题的责任心,另一方面可以让成员参与问题解决过程,从而提升成员解决问题的能力。</li>
</ol>
<h3 id="个人评估风险-简化评估流程问题"><a href="#个人评估风险-简化评估流程问题" class="headerlink" title="个人评估风险,简化评估流程问题:"></a>个人评估风险,简化评估流程问题:</h3><p>对于风险问题的影响评估过于乐观,未按照风险管理标准流程来识别、并制定有效的应对措施,导致风险问题由小变大,最后失控应对:</p>
<ol>
<li>创建风险登记册、建立风险评估机制、跟踪风险应对策略的效果等流程和机制,所有的风险问题的管理都按照流程来识别和应对</li>
<li>所有的风险问题不论大小都要有“敬畏”的心,强化风险意识,按流程来识别和应对,切不可自认为是“小风险”而跳过相关流程,简化处理</li>
</ol>
<h3 id="解决表象问题-缺乏根因分析问题"><a href="#解决表象问题-缺乏根因分析问题" class="headerlink" title="解决表象问题,缺乏根因分析问题:"></a>解决表象问题,缺乏根因分析问题:</h3><p>遇到问题“头痛医头脚痛医脚”,未识别出问题的根本原因,导致应对策略无效,“按下葫芦浮起瓢”,陷入不断救火的恶性循环。应对</p>
<ol>
<li>根因分析∶遇到风险问题先组织项目成员分析问题的根本原因;</li>
<li>制定应对策略∶根据分析出的根本原因,群策群力组织项目成员制定应对策略</li>
<li>应对策略跟踪∶跟踪应对策略是否产生了实际效果并评估实际结果与预期效果是否一致,如果产生了偏差则需要组织新评估新的应对策略</li>
<li>引入专家:通过引入专家(架构师、技术/产品总监等)参与问题的分析和应对策略的制定,增加问是识别的准确性和风险应对策略的有效性</li>
</ol>
<h3 id="偏信接收信息-不做深入调研问题"><a href="#偏信接收信息-不做深入调研问题" class="headerlink" title="偏信接收信息,不做深入调研问题:"></a>偏信接收信息,不做深入调研问题:</h3><p>对于项目成员反馈的问题或进度的真实性未做确认,当项目成员存在谎报或瞒报的情况时,无法及时发现项目问题。应对</p>
<ol>
<li>通过晨会、周例会等正式渠道,对反馈的进度或问进行确认,并将信思同步给项目团队,避免私下单独确认</li>
<li>项目初期,通过访谈,识别出有谎报或瞒报的历史的成员,对这类成员进行重点监控,做到有的放矢3、对于反馈的问题或进度可以通过关联方来进行确认,比如:到联调时间,外围系统未收到配合联调的请求,那就需要对实际进度进行确认。</li>
</ol>
<h3 id="仅做任务执行-不分轻重缓急问题"><a href="#仅做任务执行-不分轻重缓急问题" class="headerlink" title="仅做任务执行,不分轻重缓急问题:"></a>仅做任务执行,不分轻重缓急问题:</h3><p>项目经理自身缺之有效的时间官理,做事不分轻重缓急,因为琐事而使一些重要的工作被延误而一拖再拖,给项目带来了较大的影响应对:</p>
<ol>
<li>做事分轻重缓急:将事情按照重要、不重要、紧急、不紧急的四象限进行管理,紧急重要的要立即去做,重要不紧急的事情有计划去做,紧急不重要的事情授权或拒绝,不重要不紧急的事情尽量别做;</li>
<li>做好工作计划:通过对工作的梳理,在有限的时间内,使工作更有条理,更有成效。08、总结因项目不确定性的特定属性,项目经理无法百分百做到不救火,但通过避免上述的“着火点”,可以减少项目团队内可控的火(风)灾(险)发生,从而减少救火的频率,使项目经理能够从容不迫的掌控全局。</li>
</ol>
<h2 id="你的项目为什么永远在延期"><a href="#你的项目为什么永远在延期" class="headerlink" title="你的项目为什么永远在延期?"></a>你的项目为什么永远在延期?</h2><p>做过项目管理的人,都肯定有所体会,这里面充满了坑点你以为会按时间顺利完成,但往往充满波折,甚至最后实现的东西,可能和你最初的设想千差万别。比如:<br>项目准备得很充分,但是到最后却没有资源执行落地评审完后,开发估计的工时太久或者太短,和真实情况差别巨大你的方案考虑很周全,但是开发做出来和你想的很不一样项目开发过程中,遇到方案修改、人员变动、突发事故,导致协作不畅,项目延期,你辛辛苦苦做出来的东西,业务方感觉不满意,弃之不用</p>
<p>项目落地,就是一次冒险之旅,任何地方都有可能出绝对的完美实现不存在,我们在做项目之前,就需要有足够的预期。对可能遇到的问题,做足够的心理准项目不顺利时,很多人都喜欢抱怨,甩锅给领导,甩锅给开发,甚至甩锅给项目本身但其实,项目组员都是普通人,我们也不应该期待人有超人的能力比起责怪外界,倒不如做好自己可控的部分,让项进展更可控、更顺利一些下面具体说说上述几个坑点的应对方法</p>
<ol>
<li><p>统一目标,调动积极性做项目,最重要的就是让大家认可项目目标,觉得有奔头,这个时候大家才会全力以赴如果项目意义不大,或者大家一开始就不重视项目,甚至有反感情绪,那么项目再如何管理,都难以保质保量所以,作为项目负责人,通常在项目启动前,会拉一个立项会,就是在告诉大家,这件事情很重要,我们要认真开干了。甚至还需要提供很多真实的调研信息、用户反馈、数据结论,来增加说服力。此外,在企业内部,很多项目都是自上而下推进的这个时候,由于领导的关注与介入,会使得项目具备额外的价值。所以,如果能够在项目开始前,取得重要领导的认那么推进会顺利得多。相反,如果领导不认可,那么推进会处处受阻。举个例子,曾经搜狗王小川想做浏览器,领导张朝阳不认可,甚至还收回了王小川的管理权限,差点让这个项目胎死腹好在王小川自己非常坚持,拉了一两个小伙伴,加班加点把东西做了出来,然后客观事实让张朝阳看到了机会,于是才重新授权推进浏览器项人类都是追求意义的动物,有明确一致的目标,才能让大家力往一处使。如果大家没有激情,不妨先耐下性子,做做目标统一的思想工作</p>
</li>
<li><p>评审要沟通清楚大部分的需求评审,产品都是自说自话,把内的讲完,并不考虑开发同学是否真的听明白了但其实需求评审的核心目标,是让开发知道该做什么,标准是什么如果他们没听明白,就相当于白费功夫了,事后要花大量的时间来所以一定要站到对方的角度,把需求的背景、目标每个环节的重点注薏事项都强调淸楚,避免含混不此外,还得积极回答各方提出的疑问,甚至主动引导对方提问,比如询问对应的开发,这块是否有不明确的地方会议还得有明确的结论和待办事项,比如多端合作接口的分工、争议功能的处理结论、会后确定排期的时间等等。做到了这些,才算一次合格的需求评审,否则就仅仅是走了个过场。</p>
</li>
<li><p>拆分任务再评估做项目的朋友,经常可能会有这样的疑问,明明感觉很简单的功能,开发给我排了2、3周的工作量,对方是不是在忽悠我?在面对自己不熟悉的内容时,作为外行的产品经理当然没法准确预估工时。甚至有的时候,一些开发自己预估的时间都不准确这个时候,项目管理人除了讨价还价外,还有什么办法呢项目管理里有个WBS(工作分解结构)过程,可以帮我们把大的项目任务,拆分成小的、易于管理的模块。一般而言,任务的颗粒度细到3人日左右。这个时候,由于任务拆分得足够细,因此开发评估起来会更加准确。而且这个WBS需要发送给项目组留存,其他人也会看到,所以开发估时太久也会不合适。此外,在项目进行的过程中,还需要回顾对比,因此忽悠排期的成本变得很高。<br><img src="/acp/WBS%E5%88%86%E8%A7%A3.png" alt="WBS分解.png" title="WBS分解"></p>
</li>
<li><p>敢于去拍 deadline项目无限延期的一个重要原因,就是没有 deadline,正所谓 deadline是第一生产力,有了压力,才有急追对于项目负责人来说,与其费尽心思,去督促下游执行者的各项过程,还不如直接拍一个 deadline当然,自己臆想出来的 deadline肯定没有意义,这个dheadline一定要取得项目干系人的认可,并且是有可能实现的。比如可以获得开发 leader、项目领导认可,之后把这个时间公布给其他执行同事,这个时间就开始具备了真实效力。善于使用这个方法,才能高效产出。否则很容易陷入无穷无尽的被动等待中。</p>
</li>
<li><p>定期 review,及时反馈管理非常重要的一个环节,就是定期rev在项问题一定会发生,与其期待项目完美执不如及时做出应对相反,如果不管不顾,让问题积少成多,事情就会变难解,容易出现大规模的延期。走期能让我们及时发现问题,比如项目延期、方案理解有误、实现方式调整等等因为足够及时,足够高频,所以无论是修改方案还是加班赶工,都很容易解决问题对于一些紧急项目,我们会每天开站会,就是在及review,review会上,我们一般会过一下上—天的任务、问题处理情况,有没有遇到什么新问题,需要什么样的帮如果需要资源帮助,会快速对接解决。把延期的风险处理,分解到每一天后,项目整体就会非常顺利了。</p>
</li>
<li><p>方案变更,要周知各方项目变更是个经常发生的事情。比如技术方案调整产品需求调整、人员调整等等变更不可「怕的是变更后大家不知道,还按照原来的方式做因为信息不同步,所以大家做的东西就不兼容,容易必要的在变更后清楚的告知各方,让他们明的知道哪些东西变了重大的变化,还需要专门拉会同此外,我们还要做好备忘记录,避免将来交接,或者查询历史文档的时候,出现误解。</p>
</li>
</ol>
<h3 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结:"></a>最后总结:</h3><p>墨菲定律告诉我们,凡事能出错的,都会出错。从概率的角说,这个定律并不正确。但是从项目管理的角度来说,墨菲定律非常具有指导性。在项目管理中,我们不要期待完美实现的奇迹,不要过分相信执行者的完美表现。相反,要时刻做好最坏准备,应对突发情况,应对问题,应对延期。用机制和流程,去管控项目进度,提前规避风险这样你才能有信心,说这个项目会圆满成功。</p>
]]></content>
      <categories>
        <category>Project Management</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
</search>
